<!DOCTYPE html>
<html lang="en-us">
  <head>
    
<meta charset="UTF-8">
<title>Highlighting | Elasticsearch Reference [1.7] | Elastic</title>
<link rel="home" href="index.html" title="Elasticsearch Reference [1.7]"/>
<link rel="up" href="search-request-body.html" title="Request Body Search"/>
<link rel="prev" href="search-request-post-filter.html" title="Post filter"/>
<link rel="next" href="search-request-rescore.html" title="Rescoring"/>
<meta name="DC.type" content="Learn/Docs/Elasticsearch/Reference/1.7"/>
<meta name="DC.subject" content="Elasticsearch"/>
<meta name="DC.identifier" content="1.7"/>
<meta name="robots" content="noindex,nofollow"/>

    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <script src="https://cdn.optimizely.com/js/18132920325.js"></script>
    <link rel="apple-touch-icon" sizes="57x57" href="/apple-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="60x60" href="/apple-icon-60x60.png">
    <link rel="apple-touch-icon" sizes="72x72" href="/apple-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="/apple-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="/apple-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="/apple-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="/apple-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="/apple-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-icon-180x180.png">
    <link rel="icon" type="image/png" href="/favicon-32x32.png" sizes="32x32">
    <link rel="icon" type="image/png" href="/android-chrome-192x192.png" sizes="192x192">
    <link rel="icon" type="image/png" href="/favicon-96x96.png" sizes="96x96">
    <link rel="icon" type="image/png" href="/favicon-16x16.png" sizes="16x16">
    <link rel="manifest" href="/manifest.json">
    <meta name="apple-mobile-web-app-title" content="Elastic">
    <meta name="application-name" content="Elastic">
    <meta name="msapplication-TileColor" content="#ffffff">
    <meta name="msapplication-TileImage" content="/mstile-144x144.png">
    <meta name="theme-color" content="#ffffff">
    <meta name="naver-site-verification" content="936882c1853b701b3cef3721758d80535413dbfd" />
    <meta name="yandex-verification" content="d8a47e95d0972434" />
    <meta name="localized" content="true" />
    <meta name="st:robots" content="follow,index" />
    <meta property="og:image" content="https://www.elastic.co/static/images/elastic-logo-200.png" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <link rel="apple-touch-icon-precomposed" sizes="64x64" href="/favicon_64x64_16bit.png">
    <link rel="apple-touch-icon-precomposed" sizes="32x32" href="/favicon_32x32.png">
    <link rel="apple-touch-icon-precomposed" sizes="16x16" href="/favicon_16x16.png">
    <!-- Give IE8 a fighting chance -->
    <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
    <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
    <link rel="stylesheet" type="text/css" href="/guide/static/styles.css" />
  </head>

  <body>
    <!-- Google Tag Manager -->
    <script>dataLayer = [];</script><noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-58RLH5" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
    <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start': new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0], j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src= '//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f); })(window,document,'script','dataLayer','GTM-58RLH5');</script>
    <!-- End Google Tag Manager -->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-12395217-16"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-12395217-16');
    </script>

    <!--BEGIN QUALTRICS WEBSITE FEEDBACK SNIPPET-->
    <script type='text/javascript'>
      (function(){var g=function(e,h,f,g){
      this.get=function(a){for(var a=a+"=",c=document.cookie.split(";"),b=0,e=c.length;b<e;b++){for(var d=c[b];" "==d.charAt(0);)d=d.substring(1,d.length);if(0==d.indexOf(a))return d.substring(a.length,d.length)}return null};
      this.set=function(a,c){var b="",b=new Date;b.setTime(b.getTime()+6048E5);b="; expires="+b.toGMTString();document.cookie=a+"="+c+b+"; path=/; "};
      this.check=function(){var a=this.get(f);if(a)a=a.split(":");else if(100!=e)"v"==h&&(e=Math.random()>=e/100?0:100),a=[h,e,0],this.set(f,a.join(":"));else return!0;var c=a[1];if(100==c)return!0;switch(a[0]){case "v":return!1;case "r":return c=a[2]%Math.floor(100/c),a[2]++,this.set(f,a.join(":")),!c}return!0};
      this.go=function(){if(this.check()){var a=document.createElement("script");a.type="text/javascript";a.src=g;document.body&&document.body.appendChild(a)}};
      this.start=function(){var a=this;window.addEventListener?window.addEventListener("load",function(){a.go()},!1):window.attachEvent&&window.attachEvent("onload",function(){a.go()})}};
      try{(new g(100,"r","QSI_S_ZN_emkP0oSe9Qrn7kF","https://znemkp0ose9qrn7kf-elastic.siteintercept.qualtrics.com/WRSiteInterceptEngine/?Q_ZID=ZN_emkP0oSe9Qrn7kF")).start()}catch(i){}})();
    </script><div id='ZN_emkP0oSe9Qrn7kF'><!--DO NOT REMOVE-CONTENTS PLACED HERE--></div>
    <!--END WEBSITE FEEDBACK SNIPPET-->

    <div id='elastic-nav' style="display:none;"></div>
    <script src='https://www.elastic.co/elastic-nav.js'></script>

    <!-- Subnav -->
    <div>
      <div>
        <div class="tertiary-nav d-none d-md-block">
          <div class="container">
            <div class="p-t-b-15 d-flex justify-content-between nav-container">
              <div class="breadcrum-wrapper"><span><a href="/guide/" style="font-size: 14px; font-weight: 600; color: #000;">Docs</a></span></div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="main-container">
      <section id="content" >
        <div class="content-wrapper">

          <section id="guide" lang="en">
            <div class="container">
              <div class="row">
                <div class="col-xs-12 col-sm-8 col-md-8 guide-section">
                  <!-- start body -->
                  <div class="page_header">
<p>
  <strong>WARNING</strong>: Version 1.7 of Elasticsearch has passed its 
  <a href="https://www.elastic.co/support/eol">EOL date</a>. 
</p>  
<p>
  This documentation is no longer being maintained and may be removed. 
  If you are running this version, we strongly advise you to upgrade. 
  For the latest information, see the 
  <a href="../current/index.html">current release documentation</a>. 
</p>
</div>
<div id="content">
<div class="breadcrumbs">
<span class="breadcrumb-link"><a href="index.html">Elasticsearch Reference [1.7]</a></span>
»
<span class="breadcrumb-link"><a href="search.html">Search APIs</a></span>
»
<span class="breadcrumb-link"><a href="search-request-body.html">Request Body Search</a></span>
»
<span class="breadcrumb-node">Highlighting</span>
</div>
<div class="navheader">
<span class="prev">
<a href="search-request-post-filter.html">« Post filter</a>
</span>
<span class="next">
<a href="search-request-rescore.html">Rescoring »</a>
</span>
</div>
<div class="section">
<div class="titlepage"><div><div>
<h2 class="title"><a id="search-request-highlighting"></a>Highlighting<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch/edit/1.7/docs/reference/search/request/highlighting.asciidoc">edit</a></h2>
</div></div></div>
<p>Allows to highlight search results on one or more fields. The
implementation uses either the lucene <code class="literal">highlighter</code>, <code class="literal">fast-vector-highlighter</code>
or <code class="literal">postings-highlighter</code>. The following is an example of the  search request
body:</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">{
    "query" : {...},
    "highlight" : {
        "fields" : {
            "content" : {}
        }
    }
}</pre>
</div>
<p>In the above case, the <code class="literal">content</code> field will be highlighted for each
search hit (there will be another element in each search hit, called
<code class="literal">highlight</code>, which includes the highlighted fields and the highlighted
fragments).</p>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p>In order to perform highlighting, the actual content of the field is
required. If the field in question is stored (has <code class="literal">store</code> set to <code class="literal">true</code>
in the mapping) it will be used, otherwise, the actual <code class="literal">_source</code> will
be loaded and the relevant field will be extracted from it.</p>
<p>The <code class="literal">_all</code> field cannot be extracted from <code class="literal">_source</code>, so it can only
be used for highlighting if it mapped to have <code class="literal">store</code> set to <code class="literal">true</code>.</p>
</div>
</div>
<p>The field name supports wildcard notation. For example, using <code class="literal">comment_*</code>
will cause all fields that match the expression to be highlighted.</p>
<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="postings-highlighter"></a>Postings highlighter<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch/edit/1.7/docs/reference/search/request/highlighting.asciidoc">edit</a></h3>
</div></div></div>
<p>If <code class="literal">index_options</code> is set to <code class="literal">offsets</code> in the mapping the postings highlighter
will be used instead of the plain highlighter. The postings highlighter:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
Is faster since it doesn&#8217;t require to reanalyze the text to be highlighted:
the larger the documents the better the performance gain should be
</li>
<li class="listitem">
Requires less disk space than term_vectors, needed for the fast vector
highlighter
</li>
<li class="listitem">
Breaks the text into sentences and highlights them. Plays really well with
natural languages, not as well with fields containing for instance html markup
</li>
<li class="listitem">
Treats the document as the whole corpus, and scores individual sentences as
if they were documents in this corpus, using the  BM25 algorithm
</li>
</ul>
</div>
<p>Here is an example of setting the <code class="literal">content</code> field to allow for
highlighting using the postings highlighter on it:</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">{
    "type_name" : {
        "content" : {"index_options" : "offsets"}
    }
}</pre>
</div>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p>Note that the postings highlighter is meant to perform simple query terms
highlighting, regardless of their positions. That means that when used for
instance in combination with a phrase query, it will highlight all the terms
that the query is composed of, regardless of whether they are actually part of
a query match, effectively ignoring their positions.</p>
</div>
</div>
<div class="warning admon">
<div class="icon"></div>
<div class="admon_content">
<p>The postings highlighter does support highlighting of multi term queries, like
prefix queries, wildcard queries and so on. On the other hand, this requires
the queries to be rewritten using a proper
<a class="xref" href="query-dsl-multi-term-rewrite.html" title="Multi Term Query Rewrite">rewrite method</a> that supports multi term
extraction, which is a potentially expensive operation.</p>
</div>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="fast-vector-highlighter"></a>Fast vector highlighter<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch/edit/1.7/docs/reference/search/request/highlighting.asciidoc">edit</a></h3>
</div></div></div>
<p>If <code class="literal">term_vector</code> information is provided by setting <code class="literal">term_vector</code> to
<code class="literal">with_positions_offsets</code> in the mapping then the fast vector highlighter
will be used instead of the plain highlighter.  The fast vector highlighter:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
Is faster especially for large fields (&gt; <code class="literal">1MB</code>)
</li>
<li class="listitem">
Can be customized with <code class="literal">boundary_chars</code>, <code class="literal">boundary_max_scan</code>, and
<code class="literal">fragment_offset</code> (see <a class="xref" href="search-request-highlighting.html#boundary-characters" title="Boundary Characters">below</a>)
</li>
<li class="listitem">
Requires setting <code class="literal">term_vector</code> to <code class="literal">with_positions_offsets</code> which
increases the size of the index
</li>
<li class="listitem">
Can combine matches from multiple fields into one result.  See
<code class="literal">matched_fields</code>
</li>
<li class="listitem">
Can assign different weights to matches at different positions allowing
for things like phrase matches being sorted above term matches when
highlighting a Boosting Query that boosts phrase matches over term matches
</li>
</ul>
</div>
<p>Here is an example of setting the <code class="literal">content</code> field to allow for
highlighting using the fast vector highlighter on it (this will cause
the index to be bigger):</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">{
    "type_name" : {
        "content" : {"term_vector" : "with_positions_offsets"}
    }
}</pre>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_force_highlighter_type"></a>Force highlighter type<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch/edit/1.7/docs/reference/search/request/highlighting.asciidoc">edit</a></h3>
</div></div></div>
<p>The <code class="literal">type</code> field allows to force a specific highlighter type. This is useful
for instance when needing to use the plain highlighter on a field that has
<code class="literal">term_vectors</code> enabled. The allowed values are: <code class="literal">plain</code>, <code class="literal">postings</code> and <code class="literal">fvh</code>.
The following is an example that forces the use of the plain highlighter:</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">{
    "query" : {...},
    "highlight" : {
        "fields" : {
            "content" : {"type" : "plain"}
        }
    }
}</pre>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_force_highlighting_on_source"></a>Force highlighting on source<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch/edit/1.7/docs/reference/search/request/highlighting.asciidoc">edit</a></h3>
</div></div></div>
<p>Forces the highlighting to highlight fields based on the source even if fields are
stored separately. Defaults to <code class="literal">false</code>.</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">{
    "query" : {...},
    "highlight" : {
        "fields" : {
            "content" : {"force_source" : true}
        }
    }
}</pre>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="tags"></a>Highlighting Tags<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch/edit/1.7/docs/reference/search/request/highlighting.asciidoc">edit</a></h3>
</div></div></div>
<p>By default, the highlighting will wrap highlighted text in <code class="literal">&lt;em&gt;</code> and
<code class="literal">&lt;/em&gt;</code>. This can be controlled by setting <code class="literal">pre_tags</code> and <code class="literal">post_tags</code>,
for example:</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">{
    "query" : {...},
    "highlight" : {
        "pre_tags" : ["&lt;tag1&gt;"],
        "post_tags" : ["&lt;/tag1&gt;"],
        "fields" : {
            "_all" : {}
        }
    }
}</pre>
</div>
<p>Using the fast vector highlighter there can be more tags, and the "importance"
is ordered.</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">{
    "query" : {...},
    "highlight" : {
        "pre_tags" : ["&lt;tag1&gt;", "&lt;tag2&gt;"],
        "post_tags" : ["&lt;/tag1&gt;", "&lt;/tag2&gt;"],
        "fields" : {
            "_all" : {}
        }
    }
}</pre>
</div>
<p>There are also built in "tag" schemas, with currently a single schema
called <code class="literal">styled</code> with the following <code class="literal">pre_tags</code>:</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">&lt;em class="hlt1"&gt;, &lt;em class="hlt2"&gt;, &lt;em class="hlt3"&gt;,
&lt;em class="hlt4"&gt;, &lt;em class="hlt5"&gt;, &lt;em class="hlt6"&gt;,
&lt;em class="hlt7"&gt;, &lt;em class="hlt8"&gt;, &lt;em class="hlt9"&gt;,
&lt;em class="hlt10"&gt;</pre>
</div>
<p>and <code class="literal">&lt;/em&gt;</code> as <code class="literal">post_tags</code>. If you think of more nice to have built in tag
schemas, just send an email to the mailing list or open an issue. Here
is an example of switching tag schemas:</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">{
    "query" : {...},
    "highlight" : {
        "tags_schema" : "styled",
        "fields" : {
            "content" : {}
        }
    }
}</pre>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_encoder"></a>Encoder<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch/edit/1.7/docs/reference/search/request/highlighting.asciidoc">edit</a></h3>
</div></div></div>
<p>An <code class="literal">encoder</code> parameter can be used to define how highlighted text will
be encoded. It can be either <code class="literal">default</code> (no encoding) or <code class="literal">html</code> (will
escape html, if you use html highlighting tags).</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_highlighted_fragments"></a>Highlighted Fragments<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch/edit/1.7/docs/reference/search/request/highlighting.asciidoc">edit</a></h3>
</div></div></div>
<p>Each field highlighted can control the size of the highlighted fragment
in characters (defaults to <code class="literal">100</code>), and the maximum number of fragments
to return (defaults to <code class="literal">5</code>).
For example:</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">{
    "query" : {...},
    "highlight" : {
        "fields" : {
            "content" : {"fragment_size" : 150, "number_of_fragments" : 3}
        }
    }
}</pre>
</div>
<p>The <code class="literal">fragment_size</code> is ignored when using the postings highlighter, as it
outputs sentences regardless of their length.</p>
<p>On top of this it is possible to specify that highlighted fragments need
to be sorted by score:</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">{
    "query" : {...},
    "highlight" : {
        "order" : "score",
        "fields" : {
            "content" : {"fragment_size" : 150, "number_of_fragments" : 3}
        }
    }
}</pre>
</div>
<p>If the <code class="literal">number_of_fragments</code> value is set to <code class="literal">0</code> then no fragments are
produced, instead the whole content of the field is returned, and of
course it is highlighted. This can be very handy if short texts (like
document title or address) need to be highlighted but no fragmentation
is required. Note that <code class="literal">fragment_size</code> is ignored in this case.</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">{
    "query" : {...},
    "highlight" : {
        "fields" : {
            "_all" : {},
            "bio.title" : {"number_of_fragments" : 0}
        }
    }
}</pre>
</div>
<p>When using <code class="literal">fast-vector-highlighter</code> one can use <code class="literal">fragment_offset</code>
parameter to control the margin to start highlighting from.</p>
<p>In the case where there is no matching fragment to highlight, the default is
to not return anything. Instead, we can return a snippet of text from the
beginning of the field by setting <code class="literal">no_match_size</code> (default <code class="literal">0</code>) to the length
of the text that you want returned. The actual length may be shorter than
specified as it tries to break on a word boundary. When using the postings
highlighter it is not possible to control the actual size of the snippet,
therefore the first sentence gets returned whenever <code class="literal">no_match_size</code> is
greater than <code class="literal">0</code>.</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">{
    "query" : {...},
    "highlight" : {
        "fields" : {
            "content" : {
                "fragment_size" : 150,
                "number_of_fragments" : 3,
                "no_match_size": 150
            }
        }
    }
}</pre>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_highlight_query"></a>Highlight query<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch/edit/1.7/docs/reference/search/request/highlighting.asciidoc">edit</a></h3>
</div></div></div>
<p>It is also possible to highlight against a query other than the search
query by setting <code class="literal">highlight_query</code>.  This is especially useful if you
use a rescore query because those are not taken into account by
highlighting by default.  Elasticsearch does not validate that
<code class="literal">highlight_query</code> contains the search query in any way so it is possible
to define it so legitimate query results aren&#8217;t highlighted at all.
Generally it is better to include the search query in the
<code class="literal">highlight_query</code>.  Here is an example of including both the search
query and the rescore query in <code class="literal">highlight_query</code>.</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">{
    "fields": [ "_id" ],
    "query" : {
        "match": {
            "content": {
                "query": "foo bar"
            }
        }
    },
    "rescore": {
        "window_size": 50,
        "query": {
            "rescore_query" : {
                "match_phrase": {
                    "content": {
                        "query": "foo bar",
                        "phrase_slop": 1
                    }
                }
            },
            "rescore_query_weight" : 10
        }
    },
    "highlight" : {
        "order" : "score",
        "fields" : {
            "content" : {
                "fragment_size" : 150,
                "number_of_fragments" : 3,
                "highlight_query": {
                    "bool": {
                        "must": {
                            "match": {
                                "content": {
                                    "query": "foo bar"
                                }
                            }
                        },
                        "should": {
                            "match_phrase": {
                                "content": {
                                    "query": "foo bar",
                                    "phrase_slop": 1,
                                    "boost": 10.0
                                }
                            }
                        },
                        "minimum_should_match": 0
                    }
                }
            }
        }
    }
}</pre>
</div>
<p>Note that the score of text fragment in this case is calculated by the Lucene
highlighting framework. For implementation details you can check the
<code class="literal">ScoreOrderFragmentsBuilder.java</code> class. On the other hand when using the
postings highlighter the fragments are scored using, as mentioned above,
the BM25 algorithm.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="highlighting-settings"></a>Global Settings<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch/edit/1.7/docs/reference/search/request/highlighting.asciidoc">edit</a></h3>
</div></div></div>
<p>Highlighting settings can be set on a global level and then overridden
at the field level.</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">{
    "query" : {...},
    "highlight" : {
        "number_of_fragments" : 3,
        "fragment_size" : 150,
        "tag_schema" : "styled",
        "fields" : {
            "_all" : { "pre_tags" : ["&lt;em&gt;"], "post_tags" : ["&lt;/em&gt;"] },
            "bio.title" : { "number_of_fragments" : 0 },
            "bio.author" : { "number_of_fragments" : 0 },
            "bio.content" : { "number_of_fragments" : 5, "order" : "score" }
        }
    }
}</pre>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="field-match"></a>Require Field Match<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch/edit/1.7/docs/reference/search/request/highlighting.asciidoc">edit</a></h3>
</div></div></div>
<p><code class="literal">require_field_match</code> can be set to <code class="literal">true</code> which will cause a field to
be highlighted only if a query matched that field. <code class="literal">false</code> means that
terms are highlighted on all requested fields regardless if the query
matches specifically on them.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="boundary-characters"></a>Boundary Characters<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch/edit/1.7/docs/reference/search/request/highlighting.asciidoc">edit</a></h3>
</div></div></div>
<p>When highlighting a field using the fast vector highlighter,
<code class="literal">boundary_chars</code> can be configured to define what constitutes a boundary
for highlighting. It&#8217;s a single string with each boundary character
defined in it. It defaults to <code class="literal">.,!? \t\n</code>.</p>
<p>The <code class="literal">boundary_max_scan</code> allows to control how far to look for boundary
characters, and defaults to <code class="literal">20</code>.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="matched-fields"></a>Matched Fields<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch/edit/1.7/docs/reference/search/request/highlighting.asciidoc">edit</a></h3>
</div></div></div>
<p>The Fast Vector Highlighter can combine matches on multiple fields to
highlight a single field using <code class="literal">matched_fields</code>.  This is most
intuitive for multifields that analyze the same string in different
ways.  All <code class="literal">matched_fields</code> must have <code class="literal">term_vector</code> set to
<code class="literal">with_positions_offsets</code> but only the field to which the matches are
combined is loaded so only that field would benefit from having
<code class="literal">store</code> set to <code class="literal">yes</code>.</p>
<p>In the following examples <code class="literal">content</code> is analyzed by the <code class="literal">english</code>
analyzer and <code class="literal">content.plain</code> is analyzed by the <code class="literal">standard</code> analyzer.</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">{
    "query": {
        "query_string": {
            "query": "content.plain:running scissors",
            "fields": ["content"]
        }
    },
    "highlight": {
        "order": "score",
        "fields": {
            "content": {
                "matched_fields": ["content", "content.plain"],
                "type" : "fvh"
            }
        }
    }
}</pre>
</div>
<p>The above matches both "run with scissors" and "running with scissors"
and would highlight "running" and "scissors" but not "run". If both
phrases appear in a large document then "running with scissors" is
sorted above "run with scissors" in the fragments list because there
are more matches in that fragment.</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">{
    "query": {
        "query_string": {
            "query": "running scissors",
            "fields": ["content", "content.plain^10"]
        }
    },
    "highlight": {
        "order": "score",
        "fields": {
            "content": {
                "matched_fields": ["content", "content.plain"],
                "type" : "fvh"
            }
        }
    }
}</pre>
</div>
<p>The above highlights "run" as well as "running" and "scissors" but
still sorts "running with scissors" above "run with scissors" because
the plain match ("running") is boosted.</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">{
    "query": {
        "query_string": {
            "query": "running scissors",
            "fields": ["content", "content.plain^10"]
        }
    },
    "highlight": {
        "order": "score",
        "fields": {
            "content": {
                "matched_fields": ["content.plain"],
                "type" : "fvh"
            }
        }
    }
}</pre>
</div>
<p>The above query wouldn&#8217;t highlight "run" or "scissor" but shows that
it is just fine not to list the field to which the matches are combined
(<code class="literal">content</code>) in the matched fields.</p>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p>Technically it is also fine to add fields to <code class="literal">matched_fields</code> that
don&#8217;t share the same underlying string as the field to which the matches
are combined.  The results might not make much sense and if one of the
matches is off the end of the text then the whole query will fail.</p>
</div>
</div>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p>There is a small amount of overhead involved with setting
<code class="literal">matched_fields</code> to a non-empty array so always prefer</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">    "highlight": {
        "fields": {
            "content": {}
        }
    }</pre>
</div>
<p>to</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">    "highlight": {
        "fields": {
            "content": {
                "matched_fields": ["content"],
                "type" : "fvh"
            }
        }
    }</pre>
</div>
</div>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="phrase-limit"></a>Phrase Limit<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch/edit/1.7/docs/reference/search/request/highlighting.asciidoc">edit</a></h3>
</div></div></div>
<p>The <code class="literal">fast-vector-highlighter</code> has a <code class="literal">phrase_limit</code> parameter that prevents
it from analyzing too many phrases and eating tons of memory.  It defaults
to 256 so only the first 256 matching phrases in the document scored
considered.  You can raise the limit with the <code class="literal">phrase_limit</code> parameter but
keep in mind that scoring more phrases consumes more time and memory.</p>
<p>If using <code class="literal">matched_fields</code> keep in mind that <code class="literal">phrase_limit</code> phrases per
matched field are considered.</p>
<h3><a id="explicit-field-order"></a>Field Highlight Order<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch/edit/1.7/docs/reference/search/request/highlighting.asciidoc">edit</a></h3>
<p>Elasticsearch highlights the fields in the order that they are sent.  Per the
json spec objects are unordered but if you need to be explicit about the order
that fields are highlighted then you can use an array for <code class="literal">fields</code> like this:</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">    "highlight": {
        "fields": [
            {"title":{ /*params*/ }},
            {"text":{ /*params*/ }}
        ]
    }</pre>
</div>
<p>None of the highlighters built into Elasticsearch care about the order that the
fields are highlighted but a plugin may.</p>
</div>

</div>
<div class="navfooter">
<span class="prev">
<a href="search-request-post-filter.html">« Post filter</a>
</span>
<span class="next">
<a href="search-request-rescore.html">Rescoring »</a>
</span>
</div>
</div>

                  <!-- end body -->
                </div>
                <div class="col-xs-12 col-sm-4 col-md-4" id="right_col">
                  <div id="rtpcontainer" style="display: block;">
                    <div class="mktg-promo">
                      <h3>Most Popular</h3>
                      <ul class="icons">
                        <li class="icon-elasticsearch-white"><a href="https://www.elastic.co/webinars/getting-started-elasticsearch?baymax=default&elektra=docs&storm=top-video">Get Started with Elasticsearch: Video</a></li>
                        <li class="icon-kibana-white"><a href="https://www.elastic.co/webinars/getting-started-kibana?baymax=default&elektra=docs&storm=top-video">Intro to Kibana: Video</a></li>
                        <li class="icon-logstash-white"><a href="https://www.elastic.co/webinars/introduction-elk-stack?baymax=default&elektra=docs&storm=top-video">ELK for Logs & Metrics: Video</a></li>
                      </ul>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </section>

        </div>


<div id='elastic-footer'></div>
<script src='https://www.elastic.co/elastic-footer.js'></script>
<!-- Footer Section end-->

      </section>
    </div>

<script type="text/javascript">
	var suggestionsUrl = "https://search.elastic.co/suggest";
	var localeUrl = '{"relative_url_prefix":"/","code":"en-us","display_code":"en-us","url":"/guide_template"}';
</script>
<script src="/static/js/swiftype_app_search.umd.min.js"></script>
<script src="/guide/static/jquery.js"></script>
<script type="text/javascript" src="/guide/static/docs.js"></script>
<script type="text/javascript">
  window.initial_state = {}</script>
  </body>
</html>
