<!DOCTYPE html>
<html lang="en-us">
  <head>
    
<meta charset="UTF-8">
<title>Query string query | Elasticsearch Reference [7.10] | Elastic</title>
<link rel="home" href="index.html" title="Elasticsearch Reference [7.10]"/>
<link rel="up" href="full-text-queries.html" title="Full text queries"/>
<link rel="prev" href="query-dsl-common-terms-query.html" title="Common Terms Query"/>
<link rel="next" href="query-dsl-simple-query-string-query.html" title="Simple query string query"/>
<meta name="DC.type" content="Learn/Docs/Elasticsearch/Reference/7.10"/>
<meta name="DC.subject" content="Elasticsearch"/>
<meta name="DC.identifier" content="7.10"/>

    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="apple-touch-icon" sizes="57x57" href="/apple-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="60x60" href="/apple-icon-60x60.png">
    <link rel="apple-touch-icon" sizes="72x72" href="/apple-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="/apple-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="/apple-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="/apple-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="/apple-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="/apple-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-icon-180x180.png">
    <link rel="icon" type="image/png" href="/favicon-32x32.png" sizes="32x32">
    <link rel="icon" type="image/png" href="/android-chrome-192x192.png" sizes="192x192">
    <link rel="icon" type="image/png" href="/favicon-96x96.png" sizes="96x96">
    <link rel="icon" type="image/png" href="/favicon-16x16.png" sizes="16x16">
    <link rel="manifest" href="/manifest.json">
    <meta name="apple-mobile-web-app-title" content="Elastic">
    <meta name="application-name" content="Elastic">
    <meta name="msapplication-TileColor" content="#ffffff">
    <meta name="msapplication-TileImage" content="/mstile-144x144.png">
    <meta name="theme-color" content="#ffffff">
    <meta name="naver-site-verification" content="936882c1853b701b3cef3721758d80535413dbfd" />
    <meta name="yandex-verification" content="d8a47e95d0972434" />
    <meta name="localized" content="true" />
    <meta name="st:robots" content="follow,index" />
    <meta property="og:image" content="https://www.elastic.co/static/images/elastic-logo-200.png" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <link rel="apple-touch-icon-precomposed" sizes="64x64" href="/favicon_64x64_16bit.png">
    <link rel="apple-touch-icon-precomposed" sizes="32x32" href="/favicon_32x32.png">
    <link rel="apple-touch-icon-precomposed" sizes="16x16" href="/favicon_16x16.png">
    <!-- Give IE8 a fighting chance -->
    <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
    <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
    <link rel="stylesheet" type="text/css" href="/guide/static/styles.css" />
  </head>

  <body>
    <!-- Google Tag Manager -->
    <script>dataLayer = [];</script><noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-58RLH5" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
    <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start': new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0], j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src= '//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f); })(window,document,'script','dataLayer','GTM-58RLH5');</script>
    <!-- End Google Tag Manager -->
    
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-12395217-16"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-12395217-16');
    </script>

    <!--BEGIN QUALTRICS WEBSITE FEEDBACK SNIPPET-->
    <script type='text/javascript'>
      (function(){var g=function(e,h,f,g){
      this.get=function(a){for(var a=a+"=",c=document.cookie.split(";"),b=0,e=c.length;b<e;b++){for(var d=c[b];" "==d.charAt(0);)d=d.substring(1,d.length);if(0==d.indexOf(a))return d.substring(a.length,d.length)}return null};
      this.set=function(a,c){var b="",b=new Date;b.setTime(b.getTime()+6048E5);b="; expires="+b.toGMTString();document.cookie=a+"="+c+b+"; path=/; "};
      this.check=function(){var a=this.get(f);if(a)a=a.split(":");else if(100!=e)"v"==h&&(e=Math.random()>=e/100?0:100),a=[h,e,0],this.set(f,a.join(":"));else return!0;var c=a[1];if(100==c)return!0;switch(a[0]){case "v":return!1;case "r":return c=a[2]%Math.floor(100/c),a[2]++,this.set(f,a.join(":")),!c}return!0};
      this.go=function(){if(this.check()){var a=document.createElement("script");a.type="text/javascript";a.src=g;document.body&&document.body.appendChild(a)}};
      this.start=function(){var a=this;window.addEventListener?window.addEventListener("load",function(){a.go()},!1):window.attachEvent&&window.attachEvent("onload",function(){a.go()})}};
      try{(new g(100,"r","QSI_S_ZN_emkP0oSe9Qrn7kF","https://znemkp0ose9qrn7kf-elastic.siteintercept.qualtrics.com/WRSiteInterceptEngine/?Q_ZID=ZN_emkP0oSe9Qrn7kF")).start()}catch(i){}})();
    </script><div id='ZN_emkP0oSe9Qrn7kF'><!--DO NOT REMOVE-CONTENTS PLACED HERE--></div>
    <!--END WEBSITE FEEDBACK SNIPPET-->

    <div id='elastic-nav' style="display:none;"></div>
    <script src='https://www.elastic.co/elastic-nav.js'></script>

    <!-- Subnav -->
    <div>
      <div>
        <div class="tertiary-nav d-none d-md-block">
          <div class="container">
            <div class="p-t-b-15 d-flex justify-content-between nav-container">
              <div class="breadcrum-wrapper"><span><a href="/guide/" style="font-size: 14px; font-weight: 600; color: #000;">Docs</a></span></div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="main-container">
      <section id="content" >
        <div class="content-wrapper">

          <section id="guide" lang="en">
            <div class="container">
              <div class="row">
                <div class="col-xs-12 col-sm-8 col-md-8 guide-section">
                  <!-- start body -->
                  <div class="page_header">
You are looking at preliminary documentation for a future release.
Not what you want? See the
<a href="../current/index.html">current release documentation</a>.
</div>
<div id="content">
<div class="breadcrumbs">
<span class="breadcrumb-link"><a href="index.html">Elasticsearch Reference [7.10]</a></span>
»
<span class="breadcrumb-link"><a href="query-dsl.html">Query DSL</a></span>
»
<span class="breadcrumb-link"><a href="full-text-queries.html">Full text queries</a></span>
»
<span class="breadcrumb-node">Query string query</span>
</div>
<div class="navheader">
<span class="prev">
<a href="query-dsl-common-terms-query.html">« Common Terms Query</a>
</span>
<span class="next">
<a href="query-dsl-simple-query-string-query.html">Simple query string query »</a>
</span>
</div>
<div class="section">
<div class="titlepage"><div><div>
<h2 class="title"><a id="query-dsl-query-string-query"></a>Query string query<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/query-dsl/query-string-query.asciidoc">edit</a></h2>
</div></div></div>

<p>Returns documents based on a provided query string, using a parser with a strict
syntax.</p>
<p>This query uses a <a class="xref" href="query-dsl-query-string-query.html#query-string-syntax" title="Query string syntax">syntax</a> to parse and split the provided
query string based on operators, such as <code class="literal">AND</code> or <code class="literal">NOT</code>. The query
then <a class="xref" href="analysis.html" title="Text analysis">analyzes</a> each split text independently before returning
matching documents.</p>
<p>You can use the <code class="literal">query_string</code> query to create a complex search that includes
wildcard characters, searches across multiple fields, and more. While versatile,
the query is strict and returns an error if the query string includes any
invalid syntax.</p>
<div class="warning admon">
<div class="icon"></div>
<div class="admon_content">
<p>Because it returns an error for any invalid syntax, we don&#8217;t recommend using
the <code class="literal">query_string</code> query for search boxes.</p>
<p>If you don&#8217;t need to support a query syntax, consider using the
<a class="xref" href="query-dsl-match-query.html" title="Match query"><code class="literal">match</code></a> query. If you need the features of a query
syntax, use the <a class="xref" href="query-dsl-simple-query-string-query.html" title="Simple query string query"><code class="literal">simple_query_string</code></a>
query, which is less strict.</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="query-string-query-ex-request"></a>Example request<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/query-dsl/query-string-query.asciidoc">edit</a></h3>
</div></div></div>
<p>When running the following search, the <code class="literal">query_string</code> query splits <code class="literal">(new york
city) OR (big apple)</code> into two parts: <code class="literal">new york city</code> and <code class="literal">big apple</code>. The
<code class="literal">content</code> field&#8217;s analyzer then independently converts each part into tokens
before returning matching documents. Because the query syntax does not use
whitespace as an operator, <code class="literal">new york city</code> is passed as-is to the analyzer.</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
  "query": {
    "query_string": {
      "query": "(new york city) OR (big apple)",
      "default_field": "content"
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/795.console"></div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="query-string-top-level-params"></a>Top-level parameters for <code class="literal">query_string</code><a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/query-dsl/query-string-query.asciidoc">edit</a></h3>
</div></div></div>
<div class="variablelist">
<dl class="variablelist">
<dt>
<span class="term">
<code class="literal">query</code>
</span>
</dt>
<dd>
(Required, string) Query string you wish to parse and use for search. See
<a class="xref" href="query-dsl-query-string-query.html#query-string-syntax" title="Query string syntax">Query string syntax</a>.
</dd>
<dt>
<span class="term">
<code class="literal">default_field</code>
</span>
</dt>
<dd>
<p>(Optional, string) Default field you wish to search if no field is provided in
the query string.</p>
<p>Defaults to the <code class="literal">index.query.default_field</code> index setting, which has a default
value of <code class="literal">*</code>. The <code class="literal">*</code> value extracts all fields that are eligible for term
queries and filters the metadata fields. All extracted fields are then
combined to build a query if no <code class="literal">prefix</code> is specified.</p>
<p>Searching across all eligible fields does not include <a class="xref" href="nested.html" title="Nested field type">nested
documents</a>. Use a <a class="xref" href="query-dsl-nested-query.html" title="Nested query"><code class="literal">nested</code> query</a> to search those
documents.</p>
<div id="WARNING" class="exampleblock">
<div class="content">
<p>For mappings with a large number of fields, searching across all eligible fields
could be expensive.</p>
<p>There is a limit on the number of fields that can be queried at once.
It is defined by the <code class="literal">indices.query.bool.max_clause_count</code>
<a class="xref" href="search-settings.html" title="Search settings">search setting</a>, which defaults to 1024.</p>
</div>
</div>
</dd>
<dt>
<span class="term">
<code class="literal">allow_leading_wildcard</code>
</span>
</dt>
<dd>
(Optional, Boolean) If <code class="literal">true</code>, the wildcard characters <code class="literal">*</code> and <code class="literal">?</code> are allowed
as the first character of the query string. Defaults to <code class="literal">true</code>.
</dd>
<dt>
<span class="term">
<code class="literal">analyze_wildcard</code>
</span>
</dt>
<dd>
(Optional, Boolean) If <code class="literal">true</code>, the query attempts to analyze wildcard terms in
the query string. Defaults to <code class="literal">false</code>.
</dd>
<dt>
<span class="term">
<code class="literal">analyzer</code>
</span>
</dt>
<dd>
(Optional, string) <a class="xref" href="analysis.html" title="Text analysis">Analyzer</a> used to convert text in the
query string into tokens. Defaults to the
<a class="xref" href="specify-analyzer.html#specify-index-time-analyzer" title="How Elasticsearch determines the index analyzer">index-time analyzer</a> mapped for the
<code class="literal">default_field</code>. If no analyzer is mapped, the index&#8217;s default analyzer is used.
</dd>
<dt>
<span class="term">
<code class="literal">auto_generate_synonyms_phrase_query</code>
</span>
</dt>
<dd>
(Optional, Boolean) If <code class="literal">true</code>, <a class="xref" href="query-dsl-match-query-phrase.html" title="Match phrase query">match phrase</a>
queries are automatically created for multi-term synonyms. Defaults to <code class="literal">true</code>.
See <a class="xref" href="query-dsl-query-string-query.html#query-string-synonyms" title="Synonyms and the query_string query">Synonyms and the <code class="literal">query_string</code> query</a> for an example.
</dd>
<dt>
<span class="term">
<code class="literal">boost</code>
</span>
</dt>
<dd>
<p>(Optional, float) Floating point number used to decrease or increase the
<a class="xref" href="query-filter-context.html#relevance-scores" title="Relevance scores">relevance scores</a> of the query. Defaults to <code class="literal">1.0</code>.</p>
<p>Boost values are relative to the default value of <code class="literal">1.0</code>. A boost value between
<code class="literal">0</code> and <code class="literal">1.0</code> decreases the relevance score. A value greater than <code class="literal">1.0</code>
increases the relevance score.</p>
</dd>
<dt>
<span class="term">
<code class="literal">default_operator</code>
</span>
</dt>
<dd>
<p>(Optional, string) Default boolean logic used to interpret text in the query
string if no operators are specified. Valid values are:</p>
<div class="variablelist">
<dl class="variablelist">
<dt>
<span class="term">
<code class="literal">OR</code> (Default)
</span>
</dt>
<dd>
For example, a query string of <code class="literal">capital of Hungary</code> is interpreted as <code class="literal">capital
OR of OR Hungary</code>.
</dd>
<dt>
<span class="term">
<code class="literal">AND</code>
</span>
</dt>
<dd>
For example, a query string of <code class="literal">capital of Hungary</code> is interpreted as <code class="literal">capital
AND of AND Hungary</code>.
</dd>
</dl>
</div>
</dd>
<dt>
<span class="term">
<code class="literal">enable_position_increments</code>
</span>
</dt>
<dd>
(Optional, Boolean) If <code class="literal">true</code>, enable position increments in queries constructed
from a <code class="literal">query_string</code> search. Defaults to <code class="literal">true</code>.
</dd>
<dt>
<span class="term">
<code class="literal">fields</code>
</span>
</dt>
<dd>
<p>(Optional, array of strings) Array of fields you wish to search.</p>
<p>You can use this parameter query to search across multiple fields. See
<a class="xref" href="query-dsl-query-string-query.html#query-string-multi-field" title="Search multiple fields">Search multiple fields</a>.</p>
</dd>
<dt>
<span class="term">
<code class="literal">fuzziness</code>
</span>
</dt>
<dd>
(Optional, string) Maximum edit distance allowed for matching. See <a class="xref" href="common-options.html#fuzziness" title="Fuzziness">Fuzziness</a>
for valid values and more information.
</dd>
<dt>
<span class="term">
<code class="literal">fuzzy_max_expansions</code>
</span>
</dt>
<dd>
(Optional, integer) Maximum number of terms to which the query expands for fuzzy
matching. Defaults to <code class="literal">50</code>.
</dd>
<dt>
<span class="term">
<code class="literal">fuzzy_prefix_length</code>
</span>
</dt>
<dd>
(Optional, integer) Number of beginning characters left unchanged for fuzzy
matching. Defaults to <code class="literal">0</code>.
</dd>
<dt>
<span class="term">
<code class="literal">fuzzy_transpositions</code>
</span>
</dt>
<dd>
(Optional, Boolean) If <code class="literal">true</code>, edits for fuzzy matching include
transpositions of two adjacent characters (ab → ba). Defaults to <code class="literal">true</code>.
</dd>
<dt>
<span class="term">
<code class="literal">lenient</code>
</span>
</dt>
<dd>
(Optional, Boolean) If <code class="literal">true</code>, format-based errors, such as providing a text
value for a <a class="xref" href="number.html" title="Numeric field types">numeric</a> field, are ignored. Defaults to <code class="literal">false</code>.
</dd>
<dt>
<span class="term">
<code class="literal">max_determinized_states</code>
</span>
</dt>
<dd>
<p>(Optional, integer) Maximum number of
<a href="https://en.wikipedia.org/wiki/Deterministic_finite_automaton" class="ulink" target="_top">automaton states</a>
required for the query. Default is <code class="literal">10000</code>.</p>
<p>Elasticsearch uses <a href="https://lucene.apache.org/core/" class="ulink" target="_top">Apache Lucene</a> internally to parse
regular expressions. Lucene converts each regular expression to a finite
automaton containing a number of determinized states.</p>
<p>You can use this parameter to prevent that conversion from unintentionally
consuming too many resources. You may need to increase this limit to run complex
regular expressions.</p>
</dd>
<dt>
<span class="term">
<code class="literal">minimum_should_match</code>
</span>
</dt>
<dd>
(Optional, string) Minimum number of clauses that must match for a document to
be returned. See the <a class="xref" href="query-dsl-minimum-should-match.html" title="minimum_should_match parameter"><code class="literal">minimum_should_match</code>
parameter</a> for valid values and more information. See
<a class="xref" href="query-dsl-query-string-query.html#query-string-min-should-match" title="How minimum_should_match works">How <code class="literal">minimum_should_match</code> works</a> for an example.
</dd>
<dt>
<span class="term">
<code class="literal">quote_analyzer</code>
</span>
</dt>
<dd>
<p>(Optional, string) <a class="xref" href="analysis.html" title="Text analysis">Analyzer</a> used to convert quoted text in the
query string into tokens. Defaults to the
<a class="xref" href="analyzer.html#search-quote-analyzer" title="search_quote_analyzer"><code class="literal">search_quote_analyzer</code></a> mapped for the
<code class="literal">default_field</code>.</p>
<p>For quoted text, this parameter overrides the analyzer specified in the
<code class="literal">analyzer</code> parameter.</p>
</dd>
<dt>
<span class="term">
<code class="literal">phrase_slop</code>
</span>
</dt>
<dd>
(Optional, integer) Maximum number of positions allowed between matching tokens
for phrases. Defaults to <code class="literal">0</code>. If <code class="literal">0</code>, exact phrase matches are required.
Transposed terms have a slop of <code class="literal">2</code>.
</dd>
<dt>
<span class="term">
<code class="literal">quote_field_suffix</code>
</span>
</dt>
<dd>
<p>(Optional, string) Suffix appended to quoted text in the query string.</p>
<p>You can use this suffix to use a different analysis method for exact matches.
See <a class="xref" href="mixing-exact-search-with-stemming.html" title="Mixing exact search with stemming">Mixing exact search with stemming</a>.</p>
</dd>
<dt>
<span class="term">
<code class="literal">rewrite</code>
</span>
</dt>
<dd>
(Optional, string) Method used to rewrite the query. For valid values and more
information, see the <a class="xref" href="query-dsl-multi-term-rewrite.html" title="rewrite parameter"><code class="literal">rewrite</code> parameter</a>.
</dd>
<dt>
<span class="term">
<code class="literal">time_zone</code>
</span>
</dt>
<dd>
<p>(Optional, string)
<a href="https://en.wikipedia.org/wiki/List_of_UTC_time_offsets" class="ulink" target="_top">Coordinated Universal
Time (UTC) offset</a> or
<a href="https://en.wikipedia.org/wiki/List_of_tz_database_time_zones" class="ulink" target="_top">IANA time zone</a>
used to convert <code class="literal">date</code> values in the query string to UTC.</p>
<p>Valid values are ISO 8601 UTC offsets, such as <code class="literal">+01:00</code> or -<code class="literal">08:00</code>, and IANA
time zone IDs, such as <code class="literal">America/Los_Angeles</code>.</p>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p>The <code class="literal">time_zone</code> parameter does <span class="strong strong"><strong>not</strong></span> affect the <a class="xref" href="common-options.html#date-math" title="Date Math">date math</a> value
of <code class="literal">now</code>. <code class="literal">now</code> is always the current system time in UTC. However, the
<code class="literal">time_zone</code> parameter does convert dates calculated using <code class="literal">now</code> and
<a class="xref" href="common-options.html#date-math" title="Date Math">date math rounding</a>. For example, the <code class="literal">time_zone</code> parameter will
convert a value of <code class="literal">now/d</code>.</p>
</div>
</div>
</dd>
</dl>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="query-string-query-notes"></a>Notes<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/query-dsl/query-string-query.asciidoc">edit</a></h3>
</div></div></div>
<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="query-string-syntax"></a>Query string syntax<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/query-dsl/query-string-syntax.asciidoc">edit</a></h4>
</div></div></div>
<p>The query string &#8220;mini-language&#8221; is used by the
<a class="xref" href="query-dsl-query-string-query.html" title="Query string query">Query string</a> and by the
<code class="literal">q</code> query string parameter in the <a class="xref" href="search-search.html" title="Search API"><code class="literal">search</code> API</a>.</p>
<p>The query string is parsed into a series of <em>terms</em> and <em>operators</em>. A
term can be a single word&#8201;&#8212;&#8201;<code class="literal">quick</code> or <code class="literal">brown</code>&#8201;&#8212;&#8201;or a phrase, surrounded by
double quotes&#8201;&#8212;&#8201;<code class="literal">"quick brown"</code>&#8201;&#8212;&#8201;which searches for all the words in the
phrase, in the same order.</p>
<p>Operators allow you to customize the search&#8201;&#8212;&#8201;the available options are
explained below.</p>
<div class="section">
<div class="titlepage"><div><div>
<h5 class="title"><a id="_field_names"></a>Field names<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/query-dsl/query-string-syntax.asciidoc">edit</a></h5>
</div></div></div>
<p>You can specify fields to search in the query syntax:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
<p>where the <code class="literal">status</code> field contains <code class="literal">active</code></p>
<pre class="literallayout">status:active</pre>

</li>
<li class="listitem">
<p>where the <code class="literal">title</code> field contains <code class="literal">quick</code> or <code class="literal">brown</code></p>
<pre class="literallayout">title:(quick OR brown)</pre>

</li>
<li class="listitem">
<p>where the <code class="literal">author</code> field contains the exact phrase <code class="literal">"john smith"</code></p>
<pre class="literallayout">author:"John Smith"</pre>

</li>
<li class="listitem">
<p>where the <code class="literal">first name</code> field contains <code class="literal">Alice</code> (note how we need to escape
the space with a backslash)</p>
<pre class="literallayout">first\ name:Alice</pre>

</li>
<li class="listitem">
<p>where any of the fields <code class="literal">book.title</code>, <code class="literal">book.content</code> or <code class="literal">book.date</code> contains
<code class="literal">quick</code> or <code class="literal">brown</code> (note how we need to escape the <code class="literal">*</code> with a backslash):</p>
<pre class="literallayout">book.\*:(quick OR brown)</pre>

</li>
<li class="listitem">
<p>where the field <code class="literal">title</code> has any non-null value:</p>
<pre class="literallayout">_exists_:title</pre>

</li>
</ul>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h5 class="title"><a id="query-string-wildcard"></a>Wildcards<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/query-dsl/query-string-syntax.asciidoc">edit</a></h5>
</div></div></div>
<p>Wildcard searches can be run on individual terms, using <code class="literal">?</code> to replace
a single character, and <code class="literal">*</code> to replace zero or more characters:</p>
<pre class="literallayout">qu?ck bro*</pre>

<p>Be aware that wildcard queries can use an enormous amount of memory and
perform very badly&#8201;&#8212;&#8201;just think how many terms need to be queried to
match the query string <code class="literal">"a* b* c*"</code>.</p>
<div class="warning admon">
<div class="icon"></div>
<div class="admon_content">
<p>Pure wildcards <code class="literal">\*</code> are rewritten to <a class="xref" href="query-dsl-exists-query.html" title="Exists query"><code class="literal">exists</code></a> queries for efficiency.
As a consequence, the wildcard <code class="literal">"field:*"</code> would match documents with an empty value
 like the following:</p>
<pre class="screen">{
  "field": ""
}</pre>
<p>... and would <span class="strong strong"><strong>not</strong></span> match if the field is missing or set with an explicit null
value like the following:</p>
<pre class="screen">{
  "field": null
}</pre>
</div>
</div>
<div class="warning admon">
<div class="icon"></div>
<div class="admon_content">
<p>Allowing a wildcard at the beginning of a word (eg <code class="literal">"*ing"</code>) is particularly
heavy, because all terms in the index need to be examined, just in case
they match.  Leading wildcards can be disabled by setting
<code class="literal">allow_leading_wildcard</code> to <code class="literal">false</code>.</p>
</div>
</div>
<p>Only parts of the analysis chain that operate at the character level are
applied. So for instance, if the analyzer performs both lowercasing and
stemming, only the lowercasing will be applied: it would be wrong to perform
stemming on a word that is missing some of its letters.</p>
<p>By setting <code class="literal">analyze_wildcard</code> to true, queries that end with a <code class="literal">*</code> will be
analyzed and a boolean query will be built out of the different tokens, by
ensuring exact matches on the first N-1 tokens, and prefix match on the last
token.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h5 class="title"><a id="_regular_expressions"></a>Regular expressions<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/query-dsl/query-string-syntax.asciidoc">edit</a></h5>
</div></div></div>
<p>Regular expression patterns can be embedded in the query string by
wrapping them in forward-slashes (<code class="literal">"/"</code>):</p>
<pre class="literallayout">name:/joh?n(ath[oa]n)/</pre>

<p>The supported regular expression syntax is explained in <a class="xref" href="regexp-syntax.html" title="Regular expression syntax"><em>Regular expression syntax</em></a>.</p>
<div class="warning admon">
<div class="icon"></div>
<div class="admon_content">
<p>The <code class="literal">allow_leading_wildcard</code> parameter does not have any control over
regular expressions.  A query string such as the following would force
Elasticsearch to visit every term in the index:</p>
<pre class="literallayout">/.*n/</pre>

<p>Use with caution!</p>
</div>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h5 class="title"><a id="query-string-fuzziness"></a>Fuzziness<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/query-dsl/query-string-syntax.asciidoc">edit</a></h5>
</div></div></div>
<p>We can search for terms that are
similar to, but not exactly like our search terms, using the &#8220;fuzzy&#8221;
operator:</p>
<pre class="literallayout">quikc~ brwn~ foks~</pre>

<p>This uses the
<a href="https://en.wikipedia.org/wiki/Damerau-Levenshtein_distance" class="ulink" target="_top">Damerau-Levenshtein distance</a>
to find all terms with a maximum of
two changes, where a change is the insertion, deletion
or substitution of a single character, or transposition of two adjacent
characters.</p>
<p>The default <em>edit distance</em> is <code class="literal">2</code>, but an edit distance of <code class="literal">1</code> should be
sufficient to catch 80% of all human misspellings. It can be specified as:</p>
<pre class="literallayout">quikc~1</pre>

<div class="warning admon">
<div class="icon"></div>
<div class="admon_content">
<h3>Avoid mixing fuzziness with wildcards<a id="avoid-widlcards-fuzzy-searches"></a></h3>
<p>Mixing <a class="xref" href="common-options.html#fuzziness" title="Fuzziness">fuzzy</a> and <a class="xref" href="query-dsl-query-string-query.html#query-string-wildcard" title="Wildcards">wildcard</a> operators is
<em>not</em> supported. When mixed, one of the operators is not applied. For example,
you can search for <code class="literal">app~1</code> (fuzzy) or <code class="literal">app*</code> (wildcard), but searches for
<code class="literal">app*~1</code> do not apply the fuzzy operator (<code class="literal">~1</code>).</p>
</div>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h5 class="title"><a id="_proximity_searches"></a>Proximity searches<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/query-dsl/query-string-syntax.asciidoc">edit</a></h5>
</div></div></div>
<p>While a phrase query (eg <code class="literal">"john smith"</code>) expects all of the terms in exactly
the same order, a proximity query allows the specified words to be further
apart or in a different order.  In the same way that fuzzy queries can
specify a maximum edit distance for characters in a word, a proximity search
allows us to specify a maximum edit distance of words in a phrase:</p>
<pre class="literallayout">"fox quick"~5</pre>

<p>The closer the text in a field is to the original order specified in the
query string, the more relevant that document is considered to be. When
compared to the above example query, the phrase <code class="literal">"quick fox"</code> would be
considered more relevant than <code class="literal">"quick brown fox"</code>.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h5 class="title"><a id="_ranges"></a>Ranges<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/query-dsl/query-string-syntax.asciidoc">edit</a></h5>
</div></div></div>
<p>Ranges can be specified for date, numeric or string fields. Inclusive ranges
are specified with square brackets <code class="literal">[min TO max]</code> and exclusive ranges with
curly brackets <code class="literal">{min TO max}</code>.</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
<p>All days in 2012:</p>
<pre class="literallayout">date:[2012-01-01 TO 2012-12-31]</pre>

</li>
<li class="listitem">
<p>Numbers 1..5</p>
<pre class="literallayout">count:[1 TO 5]</pre>

</li>
<li class="listitem">
<p>Tags between <code class="literal">alpha</code> and <code class="literal">omega</code>, excluding <code class="literal">alpha</code> and <code class="literal">omega</code>:</p>
<pre class="literallayout">tag:{alpha TO omega}</pre>

</li>
<li class="listitem">
<p>Numbers from 10 upwards</p>
<pre class="literallayout">count:[10 TO *]</pre>

</li>
<li class="listitem">
<p>Dates before 2012</p>
<pre class="literallayout">date:{* TO 2012-01-01}</pre>

</li>
</ul>
</div>
<p>Curly and square brackets can be combined:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
<p>Numbers from 1 up to but not including 5</p>
<pre class="literallayout">count:[1 TO 5}</pre>

</li>
</ul>
</div>
<p>Ranges with one side unbounded can use the following syntax:</p>
<pre class="literallayout">age:&gt;10
age:&gt;=10
age:&lt;10
age:&lt;=10</pre>

<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p>To combine an upper and lower bound with the simplified syntax, you
would need to join two clauses with an <code class="literal">AND</code> operator:</p>
<pre class="literallayout">age:(&gt;=10 AND &lt;20)
age:(+&gt;=10 +&lt;20)</pre>

</div>
</div>
<p>The parsing of ranges in query strings can be complex and error prone. It is
much more reliable to use an explicit <a class="xref" href="query-dsl-range-query.html" title="Range query"><code class="literal">range</code> query</a>.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h5 class="title"><a id="_boosting"></a>Boosting<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/query-dsl/query-string-syntax.asciidoc">edit</a></h5>
</div></div></div>
<p>Use the <em>boost</em> operator <code class="literal">^</code> to make one term more relevant than another.
For instance, if we want to find all documents about foxes, but we are
especially interested in quick foxes:</p>
<pre class="literallayout">quick^2 fox</pre>

<p>The default <code class="literal">boost</code> value is 1, but can be any positive floating point number.
Boosts between 0 and 1 reduce relevance.</p>
<p>Boosts can also be applied to phrases or to groups:</p>
<pre class="literallayout">"john smith"^2   (foo bar)^4</pre>

</div>

<div class="section">
<div class="titlepage"><div><div>
<h5 class="title"><a id="_boolean_operators"></a>Boolean operators<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/query-dsl/query-string-syntax.asciidoc">edit</a></h5>
</div></div></div>
<p>By default, all terms are optional, as long as one term matches.  A search
for <code class="literal">foo bar baz</code> will find any document that contains one or more of
<code class="literal">foo</code> or <code class="literal">bar</code> or <code class="literal">baz</code>.  We have already discussed the <code class="literal">default_operator</code>
above which allows you to force all terms to be required, but there are
also <em>boolean operators</em> which can be used in the query string itself
to provide more control.</p>
<p>The preferred operators are <code class="literal">+</code> (this term <span class="strong strong"><strong>must</strong></span> be present) and <code class="literal">-</code>
(this term <span class="strong strong"><strong>must not</strong></span> be present). All other terms are optional.
For example, this query:</p>
<pre class="literallayout">quick brown +fox -news</pre>

<p>states that:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
<code class="literal">fox</code> must be present
</li>
<li class="listitem">
<code class="literal">news</code> must not be present
</li>
<li class="listitem">
<code class="literal">quick</code> and <code class="literal">brown</code> are optional&#8201;&#8212;&#8201;their presence increases the relevance
</li>
</ul>
</div>
<p>The familiar boolean operators <code class="literal">AND</code>, <code class="literal">OR</code> and <code class="literal">NOT</code> (also written <code class="literal">&amp;&amp;</code>, <code class="literal">||</code>
and <code class="literal">!</code>) are also supported but beware that they do not honor the usual
precedence rules, so parentheses should be used whenever multiple operators are
used together. For instance the previous query could be rewritten as:</p>
<div class="variablelist">
<dl class="variablelist">
<dt>
<span class="term">
<code class="literal">((quick AND fox) OR (brown AND fox) OR fox) AND NOT news</code>
</span>
</dt>
<dd>
This form now replicates the logic from the original query correctly, but
the relevance scoring bears little resemblance to the original.
</dd>
</dl>
</div>
<p>In contrast, the same query rewritten using the <a class="xref" href="query-dsl-match-query.html" title="Match query"><code class="literal">match</code> query</a>
would look like this:</p>
<pre class="literallayout">{
    "bool": {
        "must":     { "match": "fox"         },
        "should":   { "match": "quick brown" },
        "must_not": { "match": "news"        }
    }
}</pre>

</div>

<div class="section">
<div class="titlepage"><div><div>
<h5 class="title"><a id="_grouping"></a>Grouping<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/query-dsl/query-string-syntax.asciidoc">edit</a></h5>
</div></div></div>
<p>Multiple terms or clauses can be grouped together with parentheses, to form
sub-queries:</p>
<pre class="literallayout">(quick OR brown) AND fox</pre>

<p>Groups can be used to target a particular field, or to boost the result
of a sub-query:</p>
<pre class="literallayout">status:(active OR pending) title:(full text search)^2</pre>

</div>

<div class="section">
<div class="titlepage"><div><div>
<h5 class="title"><a id="_reserved_characters"></a>Reserved characters<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/query-dsl/query-string-syntax.asciidoc">edit</a></h5>
</div></div></div>
<p>If you need to use any of the characters which function as operators in your
query itself (and not as operators), then you should escape them with
a leading backslash. For instance, to search for <code class="literal">(1+1)=2</code>, you would
need to write your query as <code class="literal">\(1\+1\)\=2</code>. When using JSON for the request body, two preceding backslashes (<code class="literal">\\</code>) are required; the backslash is a reserved escaping character in JSON strings.</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /my-index-000001/_search
{
  "query" : {
    "query_string" : {
      "query" : "kimchy\\!",
      "fields"  : ["user.id"]
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/796.console"></div>
<p>The reserved characters are:  <code class="literal">+ - = &amp;&amp; || &gt; &lt; ! ( ) { } [ ] ^ " ~ * ? : \ /</code></p>
<p>Failing to escape these special characters correctly could lead to a syntax error which prevents your query from running.</p>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p><code class="literal">&lt;</code> and <code class="literal">&gt;</code> can&#8217;t be escaped at all. The only way to prevent them from
attempting to create a range query is to remove them from the query string
entirely.</p>
</div>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h5 class="title"><a id="_whitespaces_and_empty_queries"></a>Whitespaces and empty queries<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/query-dsl/query-string-syntax.asciidoc">edit</a></h5>
</div></div></div>
<p>Whitespace is not considered an operator.</p>
<p>If the query string is empty or only contains whitespaces the query will
yield an empty result set.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h5 class="title"><a id="query-string-nested"></a>Avoid using the <code class="literal">query_string</code> query for nested documents<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/query-dsl/query-string-query.asciidoc">edit</a></h5>
</div></div></div>
<p><code class="literal">query_string</code> searches do not return <a class="xref" href="nested.html" title="Nested field type">nested</a> documents. To search
nested documents, use the <a class="xref" href="query-dsl-nested-query.html" title="Nested query"><code class="literal">nested</code> query</a>.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h5 class="title"><a id="query-string-multi-field"></a>Search multiple fields<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/query-dsl/query-string-query.asciidoc">edit</a></h5>
</div></div></div>
<p>You can use the <code class="literal">fields</code> parameter to perform a <code class="literal">query_string</code> search across
multiple fields.</p>
<p>The idea of running the <code class="literal">query_string</code> query against multiple fields is to
expand each query term to an OR clause like this:</p>
<pre class="screen">field1:query_term OR field2:query_term | ...</pre>
<p>For example, the following query</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
  "query": {
    "query_string": {
      "fields": [ "content", "name" ],
      "query": "this AND that"
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/797.console"></div>
<p>matches the same words as</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
  "query": {
    "query_string": {
      "query": "(content:this OR name:this) AND (content:that OR name:that)"
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/798.console"></div>
<p>Since several queries are generated from the individual search terms,
combining them is automatically done using a <code class="literal">dis_max</code> query with a <code class="literal">tie_breaker</code>.
For example (the <code class="literal">name</code> is boosted by 5 using <code class="literal">^5</code> notation):</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
  "query": {
    "query_string" : {
      "fields" : ["content", "name^5"],
      "query" : "this AND that OR thus",
      "tie_breaker" : 0
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/799.console"></div>
<p>Simple wildcard can also be used to search "within" specific inner
elements of the document. For example, if we have a <code class="literal">city</code> object with
several fields (or inner object with fields) in it, we can automatically
search on all "city" fields:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
  "query": {
    "query_string" : {
      "fields" : ["city.*"],
      "query" : "this AND that OR thus"
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/800.console"></div>
<p>Another option is to provide the wildcard fields search in the query
string itself (properly escaping the <code class="literal">*</code> sign), for example:
<code class="literal">city.\*:something</code>:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
  "query": {
    "query_string" : {
      "query" : "city.\\*:(this AND that OR thus)"
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/801.console"></div>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p>Since <code class="literal">\</code> (backslash) is a special character in json strings, it needs to
be escaped, hence the two backslashes in the above <code class="literal">query_string</code>.</p>
</div>
</div>
<p>The fields parameter can also include pattern based field names,
allowing to automatically expand to the relevant fields (dynamically
introduced fields included). For example:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
  "query": {
    "query_string" : {
      "fields" : ["content", "name.*^5"],
      "query" : "this AND that OR thus"
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/802.console"></div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h5 class="title"><a id="query-string-multi-field-parms"></a>Additional parameters for multiple field searches<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/query-dsl/query-string-query.asciidoc">edit</a></h5>
</div></div></div>
<p>When running the <code class="literal">query_string</code> query against multiple fields, the
following additional parameters are supported.</p>
<div class="variablelist">
<dl class="variablelist">
<dt>
<span class="term">
<code class="literal">type</code>
</span>
</dt>
<dd>
<p>(Optional, string) Determines how the query matches and scores documents. Valid
values are:</p>
<div class="variablelist">
<dl class="variablelist">
<dt>
<span class="term">
<code class="literal">best_fields</code> (Default)
</span>
</dt>
<dd>
Finds documents which match any field and uses the highest
<a class="xref" href="query-filter-context.html#relevance-scores" title="Relevance scores"><code class="literal">_score</code></a> from any matching field. See
<a class="xref" href="query-dsl-multi-match-query.html#type-best-fields" title="best_fields"><code class="literal">best_fields</code></a>.
</dd>
<dt>
<span class="term">
<code class="literal">bool_prefix</code>
</span>
</dt>
<dd>
Creates a <code class="literal">match_bool_prefix</code> query on each field and combines the <code class="literal">_score</code> from
each field. See <a class="xref" href="query-dsl-multi-match-query.html#type-bool-prefix" title="bool_prefix"><code class="literal">bool_prefix</code></a>.
</dd>
<dt>
<span class="term">
<code class="literal">cross_fields</code>
</span>
</dt>
<dd>
Treats fields with the same <code class="literal">analyzer</code> as though they were one big field. Looks
for each word in <span class="strong strong"><strong>any</strong></span> field. See <a class="xref" href="query-dsl-multi-match-query.html#type-cross-fields" title="cross_fields"><code class="literal">cross_fields</code></a>.
</dd>
<dt>
<span class="term">
<code class="literal">most_fields</code>
</span>
</dt>
<dd>
Finds documents which match any field and combines the <code class="literal">_score</code> from each field.
See <a class="xref" href="query-dsl-multi-match-query.html#type-most-fields" title="most_fields"><code class="literal">most_fields</code></a>.
</dd>
<dt>
<span class="term">
<code class="literal">phrase</code>
</span>
</dt>
<dd>
Runs a <code class="literal">match_phrase</code> query on each field and uses the <code class="literal">_score</code> from the best
field. See <a class="xref" href="query-dsl-multi-match-query.html#type-phrase" title="phrase and phrase_prefix"><code class="literal">phrase</code> and <code class="literal">phrase_prefix</code></a>.
</dd>
<dt>
<span class="term">
<code class="literal">phrase_prefix</code>
</span>
</dt>
<dd>
Runs a <code class="literal">match_phrase_prefix</code> query on each field and uses the <code class="literal">_score</code> from the
best field. See <a class="xref" href="query-dsl-multi-match-query.html#type-phrase" title="phrase and phrase_prefix"><code class="literal">phrase</code> and <code class="literal">phrase_prefix</code></a>.
</dd>
</dl>
</div>
<p>NOTE:
Additional top-level <code class="literal">multi_match</code> parameters may be available based on the
<a class="xref" href="query-dsl-multi-match-query.html#multi-match-types" title="Types of multi_match query:"><code class="literal">type</code></a> value.</p>
</dd>
</dl>
</div>
</div>

</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="query-string-synonyms"></a>Synonyms and the <code class="literal">query_string</code> query<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/query-dsl/query-string-query.asciidoc">edit</a></h4>
</div></div></div>
<p>The <code class="literal">query_string</code> query supports multi-terms synonym expansion with the <a class="xref" href="analysis-synonym-graph-tokenfilter.html" title="Synonym graph token filter">synonym_graph</a> token filter. When this filter is used, the parser creates a phrase query for each multi-terms synonyms.
For example, the following synonym: <code class="literal">ny, new york</code> would produce:</p>
<p><code class="literal">(ny OR ("new york"))</code></p>
<p>It is also possible to match multi terms synonyms with conjunctions instead:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
   "query": {
       "query_string" : {
           "default_field": "title",
           "query" : "ny city",
           "auto_generate_synonyms_phrase_query" : false
       }
   }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/803.console"></div>
<p>The example above creates a boolean query:</p>
<p><code class="literal">(ny OR (new AND york)) city</code></p>
<p>that matches documents with the term <code class="literal">ny</code> or the conjunction <code class="literal">new AND york</code>.
By default the parameter <code class="literal">auto_generate_synonyms_phrase_query</code> is set to <code class="literal">true</code>.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="query-string-min-should-match"></a>How <code class="literal">minimum_should_match</code> works<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/query-dsl/query-string-query.asciidoc">edit</a></h4>
</div></div></div>
<p>The <code class="literal">query_string</code> splits the query around each operator to create a boolean
query for the entire input. You can use <code class="literal">minimum_should_match</code> to control how
many "should" clauses in the resulting query should match.</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
  "query": {
    "query_string": {
      "fields": [
        "title"
      ],
      "query": "this that thus",
      "minimum_should_match": 2
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/804.console"></div>
<p>The example above creates a boolean query:</p>
<p><code class="literal">(title:this title:that title:thus)~2</code></p>
<p>that matches documents with at least two of the terms <code class="literal">this</code>, <code class="literal">that</code> or <code class="literal">thus</code>
in the single field <code class="literal">title</code>.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="query-string-min-should-match-multi"></a>How <code class="literal">minimum_should_match</code> works for multiple fields<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/query-dsl/query-string-query.asciidoc">edit</a></h4>
</div></div></div>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
  "query": {
    "query_string": {
      "fields": [
        "title",
        "content"
      ],
      "query": "this that thus",
      "minimum_should_match": 2
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/805.console"></div>
<p>The example above creates a boolean query:</p>
<p><code class="literal">((content:this content:that content:thus) | (title:this title:that title:thus))</code></p>
<p>that matches documents with the disjunction max over the fields <code class="literal">title</code> and
<code class="literal">content</code>. Here the <code class="literal">minimum_should_match</code> parameter can&#8217;t be applied.</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
  "query": {
    "query_string": {
      "fields": [
        "title",
        "content"
      ],
      "query": "this OR that OR thus",
      "minimum_should_match": 2
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/806.console"></div>
<p>Adding explicit operators forces each term to be considered as a separate clause.</p>
<p>The example above creates a boolean query:</p>
<p><code class="literal">((content:this | title:this) (content:that | title:that) (content:thus | title:thus))~2</code></p>
<p>that matches documents with at least two of the three "should" clauses, each of
them made of the disjunction max over the fields for each term.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="query-string-min-should-match-cross"></a>How <code class="literal">minimum_should_match</code> works for cross-field searches<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/query-dsl/query-string-query.asciidoc">edit</a></h4>
</div></div></div>
<p>A <code class="literal">cross_fields</code> value in the <code class="literal">type</code> field indicates fields with the same
analyzer are grouped together when the input is analyzed.</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
  "query": {
    "query_string": {
      "fields": [
        "title",
        "content"
      ],
      "query": "this OR that OR thus",
      "type": "cross_fields",
      "minimum_should_match": 2
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/807.console"></div>
<p>The example above creates a boolean query:</p>
<p><code class="literal">(blended(terms:[field2:this, field1:this]) blended(terms:[field2:that, field1:that]) blended(terms:[field2:thus, field1:thus]))~2</code></p>
<p>that matches documents with at least two of the three per-term blended queries.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="_allow_expensive_queries"></a>Allow expensive queries<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.10/docs/reference/query-dsl/query-string-query.asciidoc">edit</a></h4>
</div></div></div>
<p>Query string query can be internally be transformed to a <a class="xref" href="query-dsl-prefix-query.html" title="Prefix query"><code class="literal">prefix query</code></a> which means
that if the prefix queries are disabled as explained <a class="xref" href="query-dsl-prefix-query.html#prefix-query-allow-expensive-queries" title="Allow expensive queries">here</a> the query will not be
executed and an exception will be thrown.</p>
</div>

</div>

</div>
<div class="navfooter">
<span class="prev">
<a href="query-dsl-common-terms-query.html">« Common Terms Query</a>
</span>
<span class="next">
<a href="query-dsl-simple-query-string-query.html">Simple query string query »</a>
</span>
</div>
</div>

                  <!-- end body -->
                </div>
                <div class="col-xs-12 col-sm-4 col-md-4" id="right_col">
                  <div id="rtpcontainer" style="display: block;">
                    <div class="mktg-promo">
                      <h3>Most Popular</h3>
                      <ul class="icons">
                        <li class="icon-elasticsearch-white"><a href="https://www.elastic.co/webinars/getting-started-elasticsearch?baymax=default&elektra=docs&storm=top-video">Get Started with Elasticsearch: Video</a></li>
                        <li class="icon-kibana-white"><a href="https://www.elastic.co/webinars/getting-started-kibana?baymax=default&elektra=docs&storm=top-video">Intro to Kibana: Video</a></li>
                        <li class="icon-logstash-white"><a href="https://www.elastic.co/webinars/introduction-elk-stack?baymax=default&elektra=docs&storm=top-video">ELK for Logs & Metrics: Video</a></li>
                      </ul>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </section>

        </div>


<div id='elastic-footer'></div>
<script src='https://www.elastic.co/elastic-footer.js'></script>
<!-- Footer Section end-->

      </section>
    </div>

<script type="text/javascript">
	var suggestionsUrl = "https://search.elastic.co/suggest";
	var localeUrl = '{"relative_url_prefix":"/","code":"en-us","display_code":"en-us","url":"/guide_template"}';
</script>
<script src="/static/js/swiftype_app_search.umd.min.js"></script>
<script src="/guide/static/jquery.js"></script>
<script type="text/javascript" src="/guide/static/docs.js"></script>
<script type="text/javascript">
  window.initial_state = {}</script>
  </body>
</html>
