<!DOCTYPE html>
<html lang="en-us">
  <head>
    
<meta charset="UTF-8">
<title>Paginate search results | Elasticsearch Guide [master] | Elastic</title>
<meta class="elastic" name="content" content="Paginate search results | Elasticsearch Guide [master]">

<link rel="home" href="index.html" title="Elasticsearch Guide [master]"/>
<link rel="up" href="search-your-data.html" title="The search API"/>
<link rel="prev" href="sort-search-results.html" title="Sort search results"/>
<link rel="next" href="search-fields.html" title="Retrieve selected fields from a search"/>
<meta class="elastic" name="product_version" content="master"/>
<meta class="elastic" name="product_name" content="Elasticsearch"/>
<meta class="elastic" name="website_area" content="documentation"/>
<meta name="DC.type" content="Learn/Docs/Elasticsearch/Reference/master"/>
<meta name="DC.subject" content="Elasticsearch"/>
<meta name="DC.identifier" content="master"/>
<meta name="robots" content="noindex,nofollow"/>

    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <script src="https://cdn.optimizely.com/js/18132920325.js"></script>
    <link rel="apple-touch-icon" sizes="57x57" href="/apple-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="60x60" href="/apple-icon-60x60.png">
    <link rel="apple-touch-icon" sizes="72x72" href="/apple-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="/apple-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="/apple-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="/apple-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="/apple-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="/apple-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-icon-180x180.png">
    <link rel="icon" type="image/png" href="/favicon-32x32.png" sizes="32x32">
    <link rel="icon" type="image/png" href="/android-chrome-192x192.png" sizes="192x192">
    <link rel="icon" type="image/png" href="/favicon-96x96.png" sizes="96x96">
    <link rel="icon" type="image/png" href="/favicon-16x16.png" sizes="16x16">
    <link rel="manifest" href="/manifest.json">
    <meta name="apple-mobile-web-app-title" content="Elastic">
    <meta name="application-name" content="Elastic">
    <meta name="msapplication-TileColor" content="#ffffff">
    <meta name="msapplication-TileImage" content="/mstile-144x144.png">
    <meta name="theme-color" content="#ffffff">
    <meta name="naver-site-verification" content="936882c1853b701b3cef3721758d80535413dbfd" />
    <meta name="yandex-verification" content="d8a47e95d0972434" />
    <meta name="localized" content="true" />
    <meta name="st:robots" content="follow,index" />
    <meta property="og:image" content="https://static-www.elastic.co/v3/assets/bltefdd0b53724fa2ce/blt280217a63b82a734/6202d3378b1f312528798412/elastic-logo.svg" />
    <meta property="og:image:width" content="500" />
    <meta property="og:image:height" content="172" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <link rel="apple-touch-icon-precomposed" sizes="64x64" href="/favicon_64x64_16bit.png">
    <link rel="apple-touch-icon-precomposed" sizes="32x32" href="/favicon_32x32.png">
    <link rel="apple-touch-icon-precomposed" sizes="16x16" href="/favicon_16x16.png">
    <!-- Give IE8 a fighting chance -->
    <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
    <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
    <link rel="stylesheet" type="text/css" href="/guide/static/styles-v1.css" />
  </head>

  <!--© 2015-2025 Elasticsearch B.V. -->
  <!-- All Elastic documentation is licensed under a Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License. -->
  <!-- http://creativecommons.org/licenses/by-nc-nd/4.0/ -->

  <body>
    <!-- Google Tag Manager -->
    <script>dataLayer = [];</script><noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-58RLH5" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
    <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start': new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0], j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src= '//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f); })(window,document,'script','dataLayer','GTM-58RLH5');</script>
    <!-- End Google Tag Manager -->

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-12395217-16"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-12395217-16');
    </script>

    <!-- Google Tag Manager for GA4 -->
    <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start': new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0], j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src='https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);})(window,document,'script','dataLayer','GTM-KNJMG2M');</script>
    <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-KNJMG2M" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
    <!-- End Google Tag Manager for GA4-->

    <div id='elastic-nav' style="display:none;"></div>
    <script src='https://www.elastic.co/elastic-nav.js'></script>

    <div class="main-container">
      <section id="content" >
        <div class="content-wrapper">

          <section id="guide" lang="en">
            <div class="container-fluid">
              <div class="row pb-3">
                <div class="col-12 order-2 col-md-4 order-md-1 col-lg-3 h-almost-full-md sticky-top-md" id="left_col">
                  <!-- The TOC is appended here -->
                </div>

                <div class="col-12 order-1 col-md-8 order-md-2 col-lg-7 order-lg-2 guide-section" id="middle_col">
                  <!-- start body -->
                  
<div class="page_header">
This documentation contains work-in-progress information for future Elastic Stack and Cloud releases. Use the version selector to view supported release docs. It also contains some Elastic Cloud serverless information. Check out our <a href="https://www.elastic.co/docs/current/serverless">serverless docs</a> for more details.
</div>
<div class="navheader">
<span class="prev">
<a href="sort-search-results.html">« Sort search results</a>
</span>
<span class="next">
<a href="search-fields.html">Retrieve selected fields from a search »</a>
</span>
</div>
<div class="book" lang="en">
<div class="titlepage">
<div class="breadcrumbs">
<span class="breadcrumb-link"><a href="/guide/">Elastic Docs</a></span>
<span class="chevron-right">›</span><span class="breadcrumb-link"><a href="index.html">Elasticsearch Guide [master]</a></span>
<span class="chevron-right">›</span><span class="breadcrumb-link"><a href="search-with-elasticsearch.html">Search your data</a></span>
<span class="chevron-right">›</span><span class="breadcrumb-link"><a href="search-your-data.html">The search API</a></span>
</div>
<div>
<div><h1 class="title"><a id="id-1"></a>Paginate search results</h1><a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/main/docs/reference/search/search-your-data/paginate-search-results.asciidoc">edit</a></div>
</div>
<!--EXTRA-->
</div>
<div id="content">
<div class="section">
<div class="titlepage"><div><div>
<h2 class="title"><a id="paginate-search-results"></a>Paginate search results<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/main/docs/reference/search/search-your-data/paginate-search-results.asciidoc">edit</a></h2>
</div></div></div>
<p>By default, searches return the top 10 matching hits. To page through a larger
set of results, you can use the <a class="xref" href="search-search.html" title="Search API">search API</a>'s <code class="literal">from</code> and <code class="literal">size</code>
parameters. The <code class="literal">from</code> parameter defines the number of hits to skip, defaulting
to <code class="literal">0</code>. The <code class="literal">size</code> parameter is the maximum number of hits to return. Together,
these two parameters define a page of results.</p>
<div class="pre_wrapper lang-ruby alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-ruby alternative">response = client.search(
  body: {
    from: 5,
    size: 20,
    query: {
      match: {
        'user.id' =&gt; 'kimchy'
      }
    }
  }
)
puts response</pre>
</div>
<div class="pre_wrapper lang-go alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-go alternative">res, err := es.Search(
	es.Search.WithBody(strings.NewReader(`{
	  "from": 5,
	  "size": 20,
	  "query": {
	    "match": {
	      "user.id": "kimchy"
	    }
	  }
	}`)),
	es.Search.WithPretty(),
)
fmt.Println(res, err)</pre>
</div>
<div class="pre_wrapper lang-js alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-js alternative">const response = await client.search({
  from: 5,
  size: 20,
  query: {
    match: {
      "user.id": "kimchy",
    },
  },
});
console.log(response);</pre>
</div>
<a id="820f689eaaef15fc07abd1073fa880f8"></a>
<div class="pre_wrapper lang-console default has-ruby has-go has-js">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-console default has-ruby has-go has-js">GET /_search
{
  "from": 5,
  "size": 20,
  "query": {
    "match": {
      "user.id": "kimchy"
    }
  }
}</pre>
</div>
<div class="console_widget has-ruby has-go has-js" data-snippet="snippets/875.console"></div>
<p>Avoid using <code class="literal">from</code> and <code class="literal">size</code> to page too deeply or request too many results at
once. Search requests usually span multiple shards. Each shard must load its
requested hits and the hits for any previous pages into memory. For deep pages
or large sets of results, these operations can significantly increase memory and
CPU usage, resulting in degraded performance or node failures.</p>
<p>By default, you cannot use <code class="literal">from</code> and <code class="literal">size</code> to page through more than 10,000
hits. This limit is a safeguard set by the
<a class="xref" href="index-modules.html#index-max-result-window"><code class="literal">index.max_result_window</code></a> index setting. If you need
to page through more than 10,000 hits, use the <a class="xref" href="paginate-search-results.html#search-after" title="Search after"><code class="literal">search_after</code></a>
parameter instead.</p>
<div class="warning admon">
<div class="icon"></div>
<div class="admon_content">
<p>Elasticsearch uses Lucene&#8217;s internal doc IDs as tie-breakers. These internal doc
IDs can be completely different across replicas of the same data. When paging
search hits, you might occasionally see that documents with the same sort values
are not ordered consistently.</p>
</div>
</div>
<h3><a id="search-after"></a>Search after<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/main/docs/reference/search/search-your-data/paginate-search-results.asciidoc">edit</a></h3>
<p>You can use the <code class="literal">search_after</code> parameter to retrieve the next page of hits
using a set of <a class="xref" href="sort-search-results.html" title="Sort search results">sort values</a> from the previous page.</p>
<p>Using <code class="literal">search_after</code> requires multiple search requests with the same <code class="literal">query</code> and
<code class="literal">sort</code> values. The first step is to run an initial request. The following
example sorts the results by two fields (<code class="literal">date</code> and <code class="literal">tie_breaker_id</code>):</p>
<div class="pre_wrapper lang-ruby alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-ruby alternative">response = client.search(
  index: 'twitter',
  body: {
    query: {
      match: {
        title: 'elasticsearch'
      }
    },
    sort: [
      {
        date: 'asc'
      },
      {
        tie_breaker_id: 'asc'
      }
    ]
  }
)
puts response</pre>
</div>
<div class="pre_wrapper lang-js alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-js alternative">const response = await client.search({
  index: "twitter",
  query: {
    match: {
      title: "elasticsearch",
    },
  },
  sort: [
    {
      date: "asc",
    },
    {
      tie_breaker_id: "asc",
    },
  ],
});
console.log(response);</pre>
</div>
<a id="91750571c195718f0ff246e058e4bc63"></a>
<div class="pre_wrapper lang-console default has-ruby has-js">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-console default has-ruby has-js">GET twitter/_search
{
    "query": {
        "match": {
            "title": "elasticsearch"
        }
    },
    "sort": [
        {"date": "asc"},
        {"tie_breaker_id": "asc"}      <a id="CO211-1"></a><i class="conum" data-value="1"></i>
    ]
}</pre>
</div>
<div class="console_widget has-ruby has-js" data-snippet="snippets/876.console"></div>
<div class="calloutlist default has-ruby has-js lang-console">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO211-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>A copy of the <code class="literal">_id</code> field with <code class="literal">doc_values</code> enabled</p>
</td>
</tr>
</table>
</div>
<p>The search response includes an array of <code class="literal">sort</code> values for each hit:</p>
<a id="8a501f4a6e6de6ce8d467125400eabb8"></a>
<div class="pre_wrapper lang-console-result">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-console-result">{
  "took" : 17,
  "timed_out" : false,
  "_shards" : ...,
  "hits" : {
    "total" : ...,
    "max_score" : null,
    "hits" : [
      ...
      {
        "_index" : "twitter",
        "_id" : "654322",
        "_score" : null,
        "_source" : ...,
        "sort" : [
          1463538855,
          "654322"
        ]
      },
      {
        "_index" : "twitter",
        "_id" : "654323",
        "_score" : null,
        "_source" : ...,
        "sort" : [                                <a id="CO212-1"></a><i class="conum" data-value="1"></i>
          1463538857,
          "654323"
        ]
      }
    ]
  }
}</pre>
</div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO212-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>Sort values for the last returned hit.</p>
</td>
</tr>
</table>
</div>
<p>To retrieve the next page of results, repeat the request, take the <code class="literal">sort</code> values from the
last hit, and insert those into the <code class="literal">search_after</code> array:</p>
<div class="pre_wrapper lang-ruby alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-ruby alternative">response = client.search(
  index: 'twitter',
  body: {
    query: {
      match: {
        title: 'elasticsearch'
      }
    },
    search_after: [
      1_463_538_857,
      '654323'
    ],
    sort: [
      {
        date: 'asc'
      },
      {
        tie_breaker_id: 'asc'
      }
    ]
  }
)
puts response</pre>
</div>
<div class="pre_wrapper lang-js alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-js alternative">const response = await client.search({
  index: "twitter",
  query: {
    match: {
      title: "elasticsearch",
    },
  },
  search_after: [1463538857, "654323"],
  sort: [
    {
      date: "asc",
    },
    {
      tie_breaker_id: "asc",
    },
  ],
});
console.log(response);</pre>
</div>
<a id="d851282dba548251d10db5954a339307"></a>
<div class="pre_wrapper lang-console default has-ruby has-js">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-console default has-ruby has-js">GET twitter/_search
{
    "query": {
        "match": {
            "title": "elasticsearch"
        }
    },
    "search_after": [1463538857, "654323"],
    "sort": [
        {"date": "asc"},
        {"tie_breaker_id": "asc"}
    ]
}</pre>
</div>
<div class="console_widget has-ruby has-js" data-snippet="snippets/877.console"></div>
<p>Repeat this process by updating the <code class="literal">search_after</code> array every time you retrieve a
new page of results. If a <a class="xref" href="near-real-time.html" title="Near real-time search">refresh</a> occurs between these requests,
the order of your results may change, causing inconsistent results across pages. To
prevent this, you can create a <a class="xref" href="point-in-time-api.html" title="Point in time API">point in time (PIT)</a> to
preserve the current index state over your searches.</p>
<div class="pre_wrapper lang-ruby alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-ruby alternative">response = client.open_point_in_time(
  index: 'my-index-000001',
  keep_alive: '1m'
)
puts response</pre>
</div>
<div class="pre_wrapper lang-js alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-js alternative">const response = await client.openPointInTime({
  index: "my-index-000001",
  keep_alive: "1m",
});
console.log(response);</pre>
</div>
<a id="5987afb2c17c73fe3d860937565ef115"></a>
<div class="pre_wrapper lang-console default has-ruby has-js">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-console default has-ruby has-js">POST /my-index-000001/_pit?keep_alive=1m</pre>
</div>
<div class="console_widget has-ruby has-js" data-snippet="snippets/878.console"></div>
<p>The API returns a PIT ID.</p>
<a id="0ff873f3acf223856340dabff57e4ce8"></a>
<div class="pre_wrapper lang-console-result">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-console-result">{
  "id": "46ToAwMDaWR5BXV1aWQyKwZub2RlXzMAAAAAAAAAACoBYwADaWR4BXV1aWQxAgZub2RlXzEAAAAAAAAAAAEBYQADaWR5BXV1aWQyKgZub2RlXzIAAAAAAAAAAAwBYgACBXV1aWQyAAAFdXVpZDEAAQltYXRjaF9hbGw_gAAAAA=="
}</pre>
</div>
<p>To get the first page of results, submit a search request with a <code class="literal">sort</code>
argument. If using a PIT, specify the PIT ID in the <code class="literal">pit.id</code> parameter and omit
the target data stream or index from the request path.</p>
<div class="important admon">
<div class="icon"></div>
<div class="admon_content">
<p>All PIT search requests add an implicit sort tiebreaker field called <code class="literal">_shard_doc</code>,
which can also be provided explicitly.
If you cannot use a PIT, we recommend that you include a tiebreaker field
in your <code class="literal">sort</code>. This tiebreaker field should contain a unique value for each document.
If you don&#8217;t include a tiebreaker field, your paged results could miss or duplicate hits.</p>
</div>
</div>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p>Search after requests have optimizations that make them faster when the sort
order is <code class="literal">_shard_doc</code> and total hits are not tracked. If you want to iterate over all documents regardless of the
order, this is the most efficient option.</p>
</div>
</div>
<div class="important admon">
<div class="icon"></div>
<div class="admon_content">
<p>If the <code class="literal">sort</code> field is a <a class="xref" href="date.html" title="Date field type"><code class="literal">date</code></a> in some target data streams or indices
but a <a class="xref" href="date_nanos.html" title="Date nanoseconds field type"><code class="literal">date_nanos</code></a> field in other targets, use the <code class="literal">numeric_type</code> parameter
to convert the values to a single resolution and the <code class="literal">format</code> parameter to specify a
<a class="xref" href="mapping-date-format.html" title="format">date format</a> for the <code class="literal">sort</code> field. Otherwise, Elasticsearch won&#8217;t interpret
the search after parameter correctly in each request.</p>
</div>
</div>
<div class="pre_wrapper lang-js alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-js alternative">const response = await client.search({
  size: 10000,
  query: {
    match: {
      "user.id": "elkbee",
    },
  },
  pit: {
    id: "46ToAwMDaWR5BXV1aWQyKwZub2RlXzMAAAAAAAAAACoBYwADaWR4BXV1aWQxAgZub2RlXzEAAAAAAAAAAAEBYQADaWR5BXV1aWQyKgZub2RlXzIAAAAAAAAAAAwBYgACBXV1aWQyAAAFdXVpZDEAAQltYXRjaF9hbGw_gAAAAA==",
    keep_alive: "1m",
  },
  sort: [
    {
      "@timestamp": {
        order: "asc",
        format: "strict_date_optional_time_nanos",
        numeric_type: "date_nanos",
      },
    },
  ],
});
console.log(response);</pre>
</div>
<a id="47909e194d10743093f4a22c27a85925"></a>
<div class="pre_wrapper lang-console default has-js">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-console default has-js">GET /_search
{
  "size": 10000,
  "query": {
    "match" : {
      "user.id" : "elkbee"
    }
  },
  "pit": {
    "id":  "46ToAwMDaWR5BXV1aWQyKwZub2RlXzMAAAAAAAAAACoBYwADaWR4BXV1aWQxAgZub2RlXzEAAAAAAAAAAAEBYQADaWR5BXV1aWQyKgZub2RlXzIAAAAAAAAAAAwBYgACBXV1aWQyAAAFdXVpZDEAAQltYXRjaF9hbGw_gAAAAA==", <a id="CO213-1"></a><i class="conum" data-value="1"></i>
    "keep_alive": "1m"
  },
  "sort": [ <a id="CO213-2"></a><i class="conum" data-value="2"></i>
    {"@timestamp": {"order": "asc", "format": "strict_date_optional_time_nanos", "numeric_type" : "date_nanos" }}
  ]
}</pre>
</div>
<div class="console_widget has-js" data-snippet="snippets/879.console"></div>
<div class="calloutlist default has-js lang-console">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO213-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>PIT ID for the search.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO213-2"><i class="conum" data-value="2"></i></a></p>
</td>
<td align="left" valign="top">
<p>Sorts hits for the search with an implicit tiebreak on <code class="literal">_shard_doc</code> ascending.</p>
</td>
</tr>
</table>
</div>
<p>The search response includes an array of <code class="literal">sort</code> values for each hit. If you used
a PIT, a tiebreaker is included as the last <code class="literal">sort</code> values for each hit.
This tiebreaker called <code class="literal">_shard_doc</code> is added automatically on every search requests that use a PIT.
The <code class="literal">_shard_doc</code> value is the combination of the shard index within the PIT and the Lucene&#8217;s internal doc ID,
it is unique per document and constant within a PIT.
You can also add the tiebreaker explicitly in the search request to customize the order:</p>
<div class="pre_wrapper lang-js alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-js alternative">const response = await client.search({
  size: 10000,
  query: {
    match: {
      "user.id": "elkbee",
    },
  },
  pit: {
    id: "46ToAwMDaWR5BXV1aWQyKwZub2RlXzMAAAAAAAAAACoBYwADaWR4BXV1aWQxAgZub2RlXzEAAAAAAAAAAAEBYQADaWR5BXV1aWQyKgZub2RlXzIAAAAAAAAAAAwBYgACBXV1aWQyAAAFdXVpZDEAAQltYXRjaF9hbGw_gAAAAA==",
    keep_alive: "1m",
  },
  sort: [
    {
      "@timestamp": {
        order: "asc",
        format: "strict_date_optional_time_nanos",
      },
    },
    {
      _shard_doc: "desc",
    },
  ],
});
console.log(response);</pre>
</div>
<a id="4e50d9d25bfb07ac73e3a2be5d2fbbf7"></a>
<div class="pre_wrapper lang-console default has-js">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-console default has-js">GET /_search
{
  "size": 10000,
  "query": {
    "match" : {
      "user.id" : "elkbee"
    }
  },
  "pit": {
    "id":  "46ToAwMDaWR5BXV1aWQyKwZub2RlXzMAAAAAAAAAACoBYwADaWR4BXV1aWQxAgZub2RlXzEAAAAAAAAAAAEBYQADaWR5BXV1aWQyKgZub2RlXzIAAAAAAAAAAAwBYgACBXV1aWQyAAAFdXVpZDEAAQltYXRjaF9hbGw_gAAAAA==", <a id="CO214-1"></a><i class="conum" data-value="1"></i>
    "keep_alive": "1m"
  },
  "sort": [ <a id="CO214-2"></a><i class="conum" data-value="2"></i>
    {"@timestamp": {"order": "asc", "format": "strict_date_optional_time_nanos"}},
    {"_shard_doc": "desc"}
  ]
}</pre>
</div>
<div class="console_widget has-js" data-snippet="snippets/880.console"></div>
<div class="calloutlist default has-js lang-console">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO214-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>PIT ID for the search.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO214-2"><i class="conum" data-value="2"></i></a></p>
</td>
<td align="left" valign="top">
<p>Sorts hits for the search with an explicit tiebreak on <code class="literal">_shard_doc</code> descending.</p>
</td>
</tr>
</table>
</div>
<a id="2938ccebfbc8550cc49016a68d8ef032"></a>
<div class="pre_wrapper lang-console-result">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-console-result">{
  "pit_id" : "46ToAwMDaWR5BXV1aWQyKwZub2RlXzMAAAAAAAAAACoBYwADaWR4BXV1aWQxAgZub2RlXzEAAAAAAAAAAAEBYQADaWR5BXV1aWQyKgZub2RlXzIAAAAAAAAAAAwBYgACBXV1aWQyAAAFdXVpZDEAAQltYXRjaF9hbGw_gAAAAA==", <a id="CO215-1"></a><i class="conum" data-value="1"></i>
  "took" : 17,
  "timed_out" : false,
  "_shards" : ...,
  "hits" : {
    "total" : ...,
    "max_score" : null,
    "hits" : [
      ...
      {
        "_index" : "my-index-000001",
        "_id" : "FaslK3QBySSL_rrj9zM5",
        "_score" : null,
        "_source" : ...,
        "sort" : [                                <a id="CO215-2"></a><i class="conum" data-value="2"></i>
          "2021-05-20T05:30:04.832Z",
          4294967298                              <a id="CO215-3"></a><i class="conum" data-value="3"></i>
        ]
      }
    ]
  }
}</pre>
</div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO215-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>Updated <code class="literal">id</code> for the point in time.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO215-2"><i class="conum" data-value="2"></i></a></p>
</td>
<td align="left" valign="top">
<p>Sort values for the last returned hit.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO215-3"><i class="conum" data-value="3"></i></a></p>
</td>
<td align="left" valign="top">
<p>The tiebreaker value, unique per document within the <code class="literal">pit_id</code>.</p>
</td>
</tr>
</table>
</div>
<p>To get the next page of results, rerun the previous search using the last hit&#8217;s
sort values (including the tiebreaker) as the <code class="literal">search_after</code> argument. If using a PIT, use the latest PIT
ID in the <code class="literal">pit.id</code> parameter. The search&#8217;s <code class="literal">query</code> and <code class="literal">sort</code> arguments must
remain unchanged. If provided, the <code class="literal">from</code> argument must be <code class="literal">0</code> (default) or <code class="literal">-1</code>.</p>
<div class="pre_wrapper lang-js alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-js alternative">const response = await client.search({
  size: 10000,
  query: {
    match: {
      "user.id": "elkbee",
    },
  },
  pit: {
    id: "46ToAwMDaWR5BXV1aWQyKwZub2RlXzMAAAAAAAAAACoBYwADaWR4BXV1aWQxAgZub2RlXzEAAAAAAAAAAAEBYQADaWR5BXV1aWQyKgZub2RlXzIAAAAAAAAAAAwBYgACBXV1aWQyAAAFdXVpZDEAAQltYXRjaF9hbGw_gAAAAA==",
    keep_alive: "1m",
  },
  sort: [
    {
      "@timestamp": {
        order: "asc",
        format: "strict_date_optional_time_nanos",
      },
    },
  ],
  search_after: ["2021-05-20T05:30:04.832Z", 4294967298],
  track_total_hits: false,
});
console.log(response);</pre>
</div>
<a id="7846974b47a3eab1832a475663d23ad9"></a>
<div class="pre_wrapper lang-console default has-js">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-console default has-js">GET /_search
{
  "size": 10000,
  "query": {
    "match" : {
      "user.id" : "elkbee"
    }
  },
  "pit": {
    "id":  "46ToAwMDaWR5BXV1aWQyKwZub2RlXzMAAAAAAAAAACoBYwADaWR4BXV1aWQxAgZub2RlXzEAAAAAAAAAAAEBYQADaWR5BXV1aWQyKgZub2RlXzIAAAAAAAAAAAwBYgACBXV1aWQyAAAFdXVpZDEAAQltYXRjaF9hbGw_gAAAAA==", <a id="CO216-1"></a><i class="conum" data-value="1"></i>
    "keep_alive": "1m"
  },
  "sort": [
    {"@timestamp": {"order": "asc", "format": "strict_date_optional_time_nanos"}}
  ],
  "search_after": [                                <a id="CO216-2"></a><i class="conum" data-value="2"></i>
    "2021-05-20T05:30:04.832Z",
    4294967298
  ],
  "track_total_hits": false                        <a id="CO216-3"></a><i class="conum" data-value="3"></i>
}</pre>
</div>
<div class="console_widget has-js" data-snippet="snippets/881.console"></div>
<div class="calloutlist default has-js lang-console">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO216-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>PIT ID returned by the previous search.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO216-2"><i class="conum" data-value="2"></i></a></p>
</td>
<td align="left" valign="top">
<p>Sort values from the previous search&#8217;s last hit.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO216-3"><i class="conum" data-value="3"></i></a></p>
</td>
<td align="left" valign="top">
<p>Disable the tracking of total hits to speed up pagination.</p>
</td>
</tr>
</table>
</div>
<p>You can repeat this process to get additional pages of results. If using a PIT,
you can extend the PIT&#8217;s retention period using the
<code class="literal">keep_alive</code> parameter of each search request.</p>
<p>When you&#8217;re finished, you should delete your PIT.</p>
<div class="pre_wrapper lang-ruby alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-ruby alternative">response = client.close_point_in_time(
  body: {
    id: '46ToAwMDaWR5BXV1aWQyKwZub2RlXzMAAAAAAAAAACoBYwADaWR4BXV1aWQxAgZub2RlXzEAAAAAAAAAAAEBYQADaWR5BXV1aWQyKgZub2RlXzIAAAAAAAAAAAwBYgACBXV1aWQyAAAFdXVpZDEAAQltYXRjaF9hbGw_gAAAAA=='
  }
)
puts response</pre>
</div>
<div class="pre_wrapper lang-js alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-js alternative">const response = await client.closePointInTime({
  id: "46ToAwMDaWR5BXV1aWQyKwZub2RlXzMAAAAAAAAAACoBYwADaWR4BXV1aWQxAgZub2RlXzEAAAAAAAAAAAEBYQADaWR5BXV1aWQyKgZub2RlXzIAAAAAAAAAAAwBYgACBXV1aWQyAAAFdXVpZDEAAQltYXRjaF9hbGw_gAAAAA==",
});
console.log(response);</pre>
</div>
<a id="9ff9b2a73419a6c82f17a358b4991499"></a>
<div class="pre_wrapper lang-console default has-ruby has-js">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-console default has-ruby has-js">DELETE /_pit
{
    "id" : "46ToAwMDaWR5BXV1aWQyKwZub2RlXzMAAAAAAAAAACoBYwADaWR4BXV1aWQxAgZub2RlXzEAAAAAAAAAAAEBYQADaWR5BXV1aWQyKgZub2RlXzIAAAAAAAAAAAwBYgACBXV1aWQyAAAFdXVpZDEAAQltYXRjaF9hbGw_gAAAAA=="
}</pre>
</div>
<div class="console_widget has-ruby has-js" data-snippet="snippets/882.console"></div>
<h3><a id="scroll-search-results"></a>Scroll search results<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/main/docs/reference/search/search-your-data/paginate-search-results.asciidoc">edit</a></h3>
<div class="important admon">
<div class="icon"></div>
<div class="admon_content">
<p>We no longer recommend using the scroll API for deep pagination. If
you need to preserve the index state while paging through more than 10,000 hits,
use the <a class="xref" href="paginate-search-results.html#search-after" title="Search after"><code class="literal">search_after</code></a> parameter with a point in time (PIT).</p>
</div>
</div>
<p>While a <code class="literal">search</code> request returns a single &#8220;page&#8221; of results, the <code class="literal">scroll</code>
API can be used to retrieve large numbers of results (or even all results)
from a single search request, in much the same way as you would use a cursor
on a traditional database.</p>
<p>Scrolling is not intended for real time user requests, but rather for
processing large amounts of data, e.g. in order to reindex the contents of one
data stream or index into a new data stream or index with a different
configuration.</p>
<div class="sidebar">
<div class="titlepage"><div><div>
<p class="title"><strong>Client support for scrolling and reindexing</strong></p>
</div></div></div>
<p>Some of the officially supported clients provide helpers to assist with
scrolled searches and reindexing:</p>
<div class="variablelist">
<dl class="variablelist">
<dt>
<span class="term">
Perl
</span>
</dt>
<dd>
See <a href="https://metacpan.org/pod/Search::Elasticsearch::Client::5_0::Bulk" class="ulink" target="_top">Search::Elasticsearch::Client::5_0::Bulk</a>
and <a href="https://metacpan.org/pod/Search::Elasticsearch::Client::5_0::Scroll" class="ulink" target="_top">Search::Elasticsearch::Client::5_0::Scroll</a>
</dd>
<dt>
<span class="term">
Python
</span>
</dt>
<dd>
See <a href="https://elasticsearch-py.readthedocs.io/en/" class="ulink" target="_top">elasticsearch.helpers.*</a>
</dd>
<dt>
<span class="term">
JavaScript
</span>
</dt>
<dd>
See <a href="/guide/en/elasticsearch/client/javascript-api/current/client-helpers.html" class="ulink" target="_top">client.helpers.*</a>
</dd>
</dl>
</div>
</div>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p>The results that are returned from a scroll request reflect the state of
the data stream or index at the time that the initial <code class="literal">search</code> request was made, like a
snapshot in time. Subsequent changes to documents (index, update or delete)
will only affect later search requests.</p>
</div>
</div>
<p>In order to use scrolling, the initial search request should specify the
<code class="literal">scroll</code> parameter in the query string, which tells Elasticsearch how long it
should keep the &#8220;search context&#8221; alive (see <a class="xref" href="paginate-search-results.html#scroll-search-context" title="Keeping the search context alive">Keeping the search context alive</a>), eg <code class="literal">?scroll=1m</code>.</p>
<div class="pre_wrapper lang-ruby alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-ruby alternative">response = client.search(
  index: 'my-index-000001',
  scroll: '1m',
  body: {
    size: 100,
    query: {
      match: {
        message: 'foo'
      }
    }
  }
)
puts response</pre>
</div>
<div class="pre_wrapper lang-js alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-js alternative">const response = await client.search({
  index: "my-index-000001",
  scroll: "1m",
  size: 100,
  query: {
    match: {
      message: "foo",
    },
  },
});
console.log(response);</pre>
</div>
<a id="24f4dfdf9922d5aa79151675b7767742"></a>
<div class="pre_wrapper lang-console default has-ruby has-js">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-console default has-ruby has-js">POST /my-index-000001/_search?scroll=1m
{
  "size": 100,
  "query": {
    "match": {
      "message": "foo"
    }
  }
}</pre>
</div>
<div class="console_widget has-ruby has-js" data-snippet="snippets/883.console"></div>
<p>The result from the above request includes a <code class="literal">_scroll_id</code>, which should
be passed to the <code class="literal">scroll</code> API in order to retrieve the next batch of
results.</p>
<div class="pre_wrapper lang-go alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-go alternative">res, err := es.Scroll(
	es.Scroll.WithBody(strings.NewReader(`{
	  "scroll": "1m",
	  "scroll_id": "DXF1ZXJ5QW5kRmV0Y2gBAAAAAAAAAD4WYm9laVYtZndUQlNsdDcwakFMNjU1QQ=="
	}`)),
	es.Scroll.WithPretty(),
)
fmt.Println(res, err)</pre>
</div>
<div class="pre_wrapper lang-js alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-js alternative">const response = await client.scroll({
  scroll: "1m",
  scroll_id: "DXF1ZXJ5QW5kRmV0Y2gBAAAAAAAAAD4WYm9laVYtZndUQlNsdDcwakFMNjU1QQ==",
});
console.log(response);</pre>
</div>
<a id="add240aa149d8b11139947502b279ee0"></a>
<div class="pre_wrapper lang-console default has-go has-js">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-console default has-go has-js">POST /_search/scroll                                                               <a id="CO217-1"></a><i class="conum" data-value="1"></i>
{
  "scroll" : "1m",                                                                 <a id="CO217-2"></a><i class="conum" data-value="2"></i>
  "scroll_id" : "DXF1ZXJ5QW5kRmV0Y2gBAAAAAAAAAD4WYm9laVYtZndUQlNsdDcwakFMNjU1QQ==" <a id="CO217-3"></a><i class="conum" data-value="3"></i>
}</pre>
</div>
<div class="console_widget has-go has-js" data-snippet="snippets/884.console"></div>
<div class="calloutlist default has-go has-js lang-console">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO217-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p><code class="literal">GET</code> or <code class="literal">POST</code> can be used and the URL should not include the <code class="literal">index</code>
name&#8201;&#8212;&#8201;this is specified in the original <code class="literal">search</code> request instead.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO217-2"><i class="conum" data-value="2"></i></a></p>
</td>
<td align="left" valign="top">
<p>The <code class="literal">scroll</code> parameter tells Elasticsearch to keep the search context open
for another <code class="literal">1m</code>.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO217-3"><i class="conum" data-value="3"></i></a></p>
</td>
<td align="left" valign="top">
<p>The <code class="literal">scroll_id</code> parameter</p>
</td>
</tr>
</table>
</div>
<p>The <code class="literal">size</code> parameter allows you to configure the maximum number of hits to be
returned with each batch of results. Each call to the <code class="literal">scroll</code> API returns the
next batch of results until there are no more results left to return, ie the
<code class="literal">hits</code> array is empty.</p>
<div class="important admon">
<div class="icon"></div>
<div class="admon_content">
<p>The initial search request and each subsequent scroll request each
return a <code class="literal">_scroll_id</code>. While the <code class="literal">_scroll_id</code> may change between requests, it doesn’t
always change — in any case, only the most recently received <code class="literal">_scroll_id</code> should be used.</p>
</div>
</div>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p>If the request specifies aggregations, only the initial search response
will contain the aggregations results.</p>
</div>
</div>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p>Scroll requests have optimizations that make them faster when the sort
order is <code class="literal">_doc</code>. If you want to iterate over all documents regardless of the
order, this is the most efficient option:</p>
</div>
</div>
<div class="pre_wrapper lang-php alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-php alternative">$params = [
    'body' =&gt; [
        'sort' =&gt; [
            '_doc',
        ],
    ],
];
$response = $client-&gt;search($params);</pre>
</div>
<div class="pre_wrapper lang-ruby alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-ruby alternative">response = client.search(
  scroll: '1m',
  body: {
    sort: [
      '_doc'
    ]
  }
)
puts response</pre>
</div>
<div class="pre_wrapper lang-go alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-go alternative">res, err := es.Search(
	es.Search.WithBody(strings.NewReader(`{
	  "sort": [
	    "_doc"
	  ]
	}`)),
	es.Search.WithScroll(time.Duration(60000000000)),
	es.Search.WithPretty(),
)
fmt.Println(res, err)</pre>
</div>
<div class="pre_wrapper lang-js alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-js alternative">const response = await client.search({
  scroll: "1m",
  sort: ["_doc"],
});
console.log(response);</pre>
</div>
<a id="d5dcddc6398b473b6ad9bce5c6adf986"></a>
<div class="pre_wrapper lang-console default has-php has-ruby has-go has-js">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-console default has-php has-ruby has-go has-js">GET /_search?scroll=1m
{
  "sort": [
    "_doc"
  ]
}</pre>
</div>
<div class="console_widget has-php has-ruby has-go has-js" data-snippet="snippets/885.console"></div>
<h4><a id="scroll-search-context"></a>Keeping the search context alive<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/main/docs/reference/search/search-your-data/paginate-search-results.asciidoc">edit</a></h4>
<p>A scroll returns all the documents which matched the search at the time of the
initial search request. It ignores any subsequent changes to these documents.
The <code class="literal">scroll_id</code> identifies a <em>search context</em> which keeps track of everything
that Elasticsearch needs to return the correct documents. The search context is created
by the initial request and kept alive by subsequent requests.</p>
<p>The <code class="literal">scroll</code> parameter (passed to the <code class="literal">search</code> request and to every <code class="literal">scroll</code>
request) tells Elasticsearch how long it should keep the search context alive.
Its value (e.g. <code class="literal">1m</code>, see <a class="xref" href="api-conventions.html#time-units" title="Time units">Time units</a>) does not need to be long enough to
process all data&#8201;&#8212;&#8201;it just needs to be long enough to process the previous
batch of results. Each <code class="literal">scroll</code> request (with the <code class="literal">scroll</code> parameter) sets a
new expiry time. If a <code class="literal">scroll</code> request doesn&#8217;t pass in the <code class="literal">scroll</code>
parameter, then the search context will be freed as part of <em>that</em> <code class="literal">scroll</code>
request.</p>
<p>Normally, the background merge process optimizes the index by merging together
smaller segments to create new, bigger segments. Once the smaller segments are
no longer needed they are deleted. This process continues during scrolling, but
an open search context prevents the old segments from being deleted since they
are still in use.</p>
<div class="tip admon">
<div class="icon"></div>
<div class="admon_content">
<p>Keeping older segments alive means that more disk space and file handles
are needed. Ensure that you have configured your nodes to have ample free file
handles. See <a class="xref" href="file-descriptors.html" title="File Descriptors">File Descriptors</a>.</p>
</div>
</div>
<p>Additionally, if a segment contains deleted or updated documents then the
search context must keep track of whether each document in the segment was live
at the time of the initial search request. Ensure that your nodes have
sufficient heap space if you have many open scrolls on an index that is subject
to ongoing deletes or updates.</p>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p>To prevent against issues caused by having too many scrolls open, the
user is not allowed to open scrolls past a certain limit. By default, the
maximum number of open scrolls is 500. This limit can be updated with the
<code class="literal">search.max_open_scroll_context</code> cluster setting.</p>
</div>
</div>
<p>You can check how many search contexts are open with the
<a class="xref" href="cluster-nodes-stats.html" title="Nodes stats API">nodes stats API</a>:</p>
<div class="pre_wrapper lang-php alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-php alternative">$params = [
    'metric' =&gt; 'indices',
    'index_metric' =&gt; 'search',
];
$response = $client-&gt;nodes()-&gt;stats($params);</pre>
</div>
<div class="pre_wrapper lang-ruby alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-ruby alternative">response = client.nodes.stats(
  metric: 'indices',
  index_metric: 'search'
)
puts response</pre>
</div>
<div class="pre_wrapper lang-go alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-go alternative">res, err := es.Nodes.Stats(
	es.Nodes.Stats.WithMetric([]string{"indices"}...),
	es.Nodes.Stats.WithIndexMetric([]string{"search"}...),
)
fmt.Println(res, err)</pre>
</div>
<div class="pre_wrapper lang-js alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-js alternative">const response = await client.nodes.stats({
  metric: "indices",
  index_metric: "search",
});
console.log(response);</pre>
</div>
<a id="72beebe779a258c225dee7b023e60c52"></a>
<div class="pre_wrapper lang-console default has-php has-ruby has-go has-js">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-console default has-php has-ruby has-go has-js">GET /_nodes/stats/indices/search</pre>
</div>
<div class="console_widget has-php has-ruby has-go has-js" data-snippet="snippets/886.console"></div>
<h4><a id="clear-scroll"></a>Clear scroll<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/main/docs/reference/search/search-your-data/paginate-search-results.asciidoc">edit</a></h4>
<p>Search context are automatically removed when the <code class="literal">scroll</code> timeout has been
exceeded. However keeping scrolls open has a cost, as discussed in the
<a class="xref" href="paginate-search-results.html#scroll-search-context" title="Keeping the search context alive">previous section</a> so scrolls should be explicitly
cleared as soon as the scroll is not being used anymore using the
<code class="literal">clear-scroll</code> API:</p>
<div class="pre_wrapper lang-ruby alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-ruby alternative">response = client.clear_scroll(
  body: {
    scroll_id: 'DXF1ZXJ5QW5kRmV0Y2gBAAAAAAAAAD4WYm9laVYtZndUQlNsdDcwakFMNjU1QQ=='
  }
)
puts response</pre>
</div>
<div class="pre_wrapper lang-go alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-go alternative">res, err := es.ClearScroll(
	es.ClearScroll.WithBody(strings.NewReader(`{
	  "scroll_id": "DXF1ZXJ5QW5kRmV0Y2gBAAAAAAAAAD4WYm9laVYtZndUQlNsdDcwakFMNjU1QQ=="
	}`)),
)
fmt.Println(res, err)</pre>
</div>
<div class="pre_wrapper lang-js alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-js alternative">const response = await client.clearScroll({
  scroll_id: "DXF1ZXJ5QW5kRmV0Y2gBAAAAAAAAAD4WYm9laVYtZndUQlNsdDcwakFMNjU1QQ==",
});
console.log(response);</pre>
</div>
<a id="a69b1ce5cc9528fb3639185eaf241ae3"></a>
<div class="pre_wrapper lang-console default has-ruby has-go has-js">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-console default has-ruby has-go has-js">DELETE /_search/scroll
{
  "scroll_id" : "DXF1ZXJ5QW5kRmV0Y2gBAAAAAAAAAD4WYm9laVYtZndUQlNsdDcwakFMNjU1QQ=="
}</pre>
</div>
<div class="console_widget has-ruby has-go has-js" data-snippet="snippets/887.console"></div>
<p>Multiple scroll IDs can be passed as array:</p>
<div class="pre_wrapper lang-ruby alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-ruby alternative">response = client.clear_scroll(
  body: {
    scroll_id: [
      'DXF1ZXJ5QW5kRmV0Y2gBAAAAAAAAAD4WYm9laVYtZndUQlNsdDcwakFMNjU1QQ==',
      'DnF1ZXJ5VGhlbkZldGNoBQAAAAAAAAABFmtSWWRRWUJrU2o2ZExpSGJCVmQxYUEAAAAAAAAAAxZrUllkUVlCa1NqNmRMaUhiQlZkMWFBAAAAAAAAAAIWa1JZZFFZQmtTajZkTGlIYkJWZDFhQQAAAAAAAAAFFmtSWWRRWUJrU2o2ZExpSGJCVmQxYUEAAAAAAAAABBZrUllkUVlCa1NqNmRMaUhiQlZkMWFB'
    ]
  }
)
puts response</pre>
</div>
<div class="pre_wrapper lang-go alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-go alternative">res, err := es.ClearScroll(
	es.ClearScroll.WithBody(strings.NewReader(`{
	  "scroll_id": [
	    "DXF1ZXJ5QW5kRmV0Y2gBAAAAAAAAAD4WYm9laVYtZndUQlNsdDcwakFMNjU1QQ==",
	    "DnF1ZXJ5VGhlbkZldGNoBQAAAAAAAAABFmtSWWRRWUJrU2o2ZExpSGJCVmQxYUEAAAAAAAAAAxZrUllkUVlCa1NqNmRMaUhiQlZkMWFBAAAAAAAAAAIWa1JZZFFZQmtTajZkTGlIYkJWZDFhQQAAAAAAAAAFFmtSWWRRWUJrU2o2ZExpSGJCVmQxYUEAAAAAAAAABBZrUllkUVlCa1NqNmRMaUhiQlZkMWFB"
	  ]
	}`)),
)
fmt.Println(res, err)</pre>
</div>
<div class="pre_wrapper lang-js alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-js alternative">const response = await client.clearScroll({
  scroll_id: [
    "DXF1ZXJ5QW5kRmV0Y2gBAAAAAAAAAD4WYm9laVYtZndUQlNsdDcwakFMNjU1QQ==",
    "DnF1ZXJ5VGhlbkZldGNoBQAAAAAAAAABFmtSWWRRWUJrU2o2ZExpSGJCVmQxYUEAAAAAAAAAAxZrUllkUVlCa1NqNmRMaUhiQlZkMWFBAAAAAAAAAAIWa1JZZFFZQmtTajZkTGlIYkJWZDFhQQAAAAAAAAAFFmtSWWRRWUJrU2o2ZExpSGJCVmQxYUEAAAAAAAAABBZrUllkUVlCa1NqNmRMaUhiQlZkMWFB",
  ],
});
console.log(response);</pre>
</div>
<a id="4342ccf6cc24fd80bd3cd1f9a4c2ef8e"></a>
<div class="pre_wrapper lang-console default has-ruby has-go has-js">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-console default has-ruby has-go has-js">DELETE /_search/scroll
{
  "scroll_id" : [
    "DXF1ZXJ5QW5kRmV0Y2gBAAAAAAAAAD4WYm9laVYtZndUQlNsdDcwakFMNjU1QQ==",
    "DnF1ZXJ5VGhlbkZldGNoBQAAAAAAAAABFmtSWWRRWUJrU2o2ZExpSGJCVmQxYUEAAAAAAAAAAxZrUllkUVlCa1NqNmRMaUhiQlZkMWFBAAAAAAAAAAIWa1JZZFFZQmtTajZkTGlIYkJWZDFhQQAAAAAAAAAFFmtSWWRRWUJrU2o2ZExpSGJCVmQxYUEAAAAAAAAABBZrUllkUVlCa1NqNmRMaUhiQlZkMWFB"
  ]
}</pre>
</div>
<div class="console_widget has-ruby has-go has-js" data-snippet="snippets/888.console"></div>
<p>All search contexts can be cleared with the <code class="literal">_all</code> parameter:</p>
<div class="pre_wrapper lang-php alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-php alternative">$params = [
    'scroll_id' =&gt; '_all',
];
$response = $client-&gt;clearScroll($params);</pre>
</div>
<div class="pre_wrapper lang-ruby alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-ruby alternative">response = client.clear_scroll(
  scroll_id: '_all'
)
puts response</pre>
</div>
<div class="pre_wrapper lang-go alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-go alternative">res, err := es.ClearScroll(
	es.ClearScroll.WithScrollID("_all"),
)
fmt.Println(res, err)</pre>
</div>
<div class="pre_wrapper lang-js alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-js alternative">const response = await client.clearScroll({
  scroll_id: "_all",
});
console.log(response);</pre>
</div>
<a id="c2c21e2824fbf6b7198ede30419da82b"></a>
<div class="pre_wrapper lang-console default has-php has-ruby has-go has-js">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-console default has-php has-ruby has-go has-js">DELETE /_search/scroll/_all</pre>
</div>
<div class="console_widget has-php has-ruby has-go has-js" data-snippet="snippets/889.console"></div>
<p>The <code class="literal">scroll_id</code> can also be passed as a query string parameter or in the request body.
Multiple scroll IDs can be passed as comma separated values:</p>
<div class="pre_wrapper lang-php alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-php alternative">$params = [
    'scroll_id' =&gt; 'DXF1ZXJ5QW5kRmV0Y2gBAAAAAAAAAD4WYm9laVYtZndUQlNsdDcwakFMNjU1QQ==,DnF1ZXJ5VGhlbkZldGNoBQAAAAAAAAABFmtSWWRRWUJrU2o2ZExpSGJCVmQxYUEAAAAAAAAAAxZrUllkUVlCa1NqNmRMaUhiQlZkMWFBAAAAAAAAAAIWa1JZZFFZQmtTajZkTGlIYkJWZDFhQQAAAAAAAAAFFmtSWWRRWUJrU2o2ZExpSGJCVmQxYUEAAAAAAAAABBZrUllkUVlCa1NqNmRMaUhiQlZkMWFB',
];
$response = $client-&gt;clearScroll($params);</pre>
</div>
<div class="pre_wrapper lang-ruby alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-ruby alternative">response = client.clear_scroll(
  scroll_id: 'DXF1ZXJ5QW5kRmV0Y2gBAAAAAAAAAD4WYm9laVYtZndUQlNsdDcwakFMNjU1QQ==,DnF1ZXJ5VGhlbkZldGNoBQAAAAAAAAABFmtSWWRRWUJrU2o2ZExpSGJCVmQxYUEAAAAAAAAAAxZrUllkUVlCa1NqNmRMaUhiQlZkMWFBAAAAAAAAAAIWa1JZZFFZQmtTajZkTGlIYkJWZDFhQQAAAAAAAAAFFmtSWWRRWUJrU2o2ZExpSGJCVmQxYUEAAAAAAAAABBZrUllkUVlCa1NqNmRMaUhiQlZkMWFB'
)
puts response</pre>
</div>
<div class="pre_wrapper lang-go alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-go alternative">res, err := es.ClearScroll(
	es.ClearScroll.WithScrollID("DXF1ZXJ5QW5kRmV0Y2gBAAAAAAAAAD4WYm9laVYtZndUQlNsdDcwakFMNjU1QQ==", "DnF1ZXJ5VGhlbkZldGNoBQAAAAAAAAABFmtSWWRRWUJrU2o2ZExpSGJCVmQxYUEAAAAAAAAAAxZrUllkUVlCa1NqNmRMaUhiQlZkMWFBAAAAAAAAAAIWa1JZZFFZQmtTajZkTGlIYkJWZDFhQQAAAAAAAAAFFmtSWWRRWUJrU2o2ZExpSGJCVmQxYUEAAAAAAAAABBZrUllkUVlCa1NqNmRMaUhiQlZkMWFB"),
)
fmt.Println(res, err)</pre>
</div>
<div class="pre_wrapper lang-js alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-js alternative">const response = await client.clearScroll({
  scroll_id:
    "DXF1ZXJ5QW5kRmV0Y2gBAAAAAAAAAD4WYm9laVYtZndUQlNsdDcwakFMNjU1QQ==,DnF1ZXJ5VGhlbkZldGNoBQAAAAAAAAABFmtSWWRRWUJrU2o2ZExpSGJCVmQxYUEAAAAAAAAAAxZrUllkUVlCa1NqNmRMaUhiQlZkMWFBAAAAAAAAAAIWa1JZZFFZQmtTajZkTGlIYkJWZDFhQQAAAAAAAAAFFmtSWWRRWUJrU2o2ZExpSGJCVmQxYUEAAAAAAAAABBZrUllkUVlCa1NqNmRMaUhiQlZkMWFB",
});
console.log(response);</pre>
</div>
<a id="b94cee0f74f57742b3948f9b784dfdd4"></a>
<div class="pre_wrapper lang-console default has-php has-ruby has-go has-js">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-console default has-php has-ruby has-go has-js">DELETE /_search/scroll/DXF1ZXJ5QW5kRmV0Y2gBAAAAAAAAAD4WYm9laVYtZndUQlNsdDcwakFMNjU1QQ==,DnF1ZXJ5VGhlbkZldGNoBQAAAAAAAAABFmtSWWRRWUJrU2o2ZExpSGJCVmQxYUEAAAAAAAAAAxZrUllkUVlCa1NqNmRMaUhiQlZkMWFBAAAAAAAAAAIWa1JZZFFZQmtTajZkTGlIYkJWZDFhQQAAAAAAAAAFFmtSWWRRWUJrU2o2ZExpSGJCVmQxYUEAAAAAAAAABBZrUllkUVlCa1NqNmRMaUhiQlZkMWFB</pre>
</div>
<div class="console_widget has-php has-ruby has-go has-js" data-snippet="snippets/890.console"></div>
<h4><a id="slice-scroll"></a>Sliced scroll<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/main/docs/reference/search/search-your-data/paginate-search-results.asciidoc">edit</a></h4>
<p>When paging through a large number of documents, it can be helpful to split the search into multiple slices
to consume them independently:</p>
<div class="pre_wrapper lang-ruby alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-ruby alternative">response = client.search(
  index: 'my-index-000001',
  scroll: '1m',
  body: {
    slice: {
      id: 0,
      max: 2
    },
    query: {
      match: {
        message: 'foo'
      }
    }
  }
)
puts response

response = client.search(
  index: 'my-index-000001',
  scroll: '1m',
  body: {
    slice: {
      id: 1,
      max: 2
    },
    query: {
      match: {
        message: 'foo'
      }
    }
  }
)
puts response</pre>
</div>
<div class="pre_wrapper lang-js alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-js alternative">const response = await client.search({
  index: "my-index-000001",
  scroll: "1m",
  slice: {
    id: 0,
    max: 2,
  },
  query: {
    match: {
      message: "foo",
    },
  },
});
console.log(response);

const response1 = await client.search({
  index: "my-index-000001",
  scroll: "1m",
  slice: {
    id: 1,
    max: 2,
  },
  query: {
    match: {
      message: "foo",
    },
  },
});
console.log(response1);</pre>
</div>
<a id="3758b8f2ab9f6f28a764ee6c42c85766"></a>
<div class="pre_wrapper lang-console default has-ruby has-js">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-console default has-ruby has-js">GET /my-index-000001/_search?scroll=1m
{
  "slice": {
    "id": 0,                      <a id="CO218-1"></a><i class="conum" data-value="1"></i>
    "max": 2                      <a id="CO218-2"></a><i class="conum" data-value="2"></i>
  },
  "query": {
    "match": {
      "message": "foo"
    }
  }
}
GET /my-index-000001/_search?scroll=1m
{
  "slice": {
    "id": 1,
    "max": 2
  },
  "query": {
    "match": {
      "message": "foo"
    }
  }
}</pre>
</div>
<div class="console_widget has-ruby has-js" data-snippet="snippets/891.console"></div>
<div class="calloutlist default has-ruby has-js lang-console">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO218-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>The id of the slice</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO218-2"><i class="conum" data-value="2"></i></a></p>
</td>
<td align="left" valign="top">
<p>The maximum number of slices</p>
</td>
</tr>
</table>
</div>
<p>The result from the first request returned documents that belong to the first slice (id: 0) and
the result from the second request returned documents that belong to the second slice. Since the
maximum number of slices is set to 2 the union of the results of the two requests is equivalent
to the results of a scroll query without slicing. By default the splitting is done first on the
shards, then locally on each shard using the <code class="literal">_id</code> field. The local splitting follows the formula
<code class="literal">slice(doc) = floorMod(hashCode(doc._id), max))</code>.</p>
<p>Each scroll is independent and can be processed in parallel like any scroll request.</p>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p>If the number of slices is bigger than the number of shards the slice filter is very slow on
the first calls, it has a complexity of O(N) and a memory cost equals to N bits per slice where N
is the total number of documents in the shard. After few calls the filter should be cached and
subsequent calls should be faster but you should limit the number of sliced query you perform in
parallel to avoid the memory explosion.</p>
</div>
</div>
<p>The <a class="xref" href="point-in-time-api.html" title="Point in time API">point-in-time</a> API supports a more efficient partitioning strategy and
does not suffer from this problem. When possible, it&#8217;s recommended to use a point-in-time search
with slicing instead of a scroll.</p>
<p>Another way to avoid this high cost is to use the <code class="literal">doc_values</code> of another field to do the slicing.
The field must have the following properties:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
The field is numeric.
</li>
<li class="listitem">
<code class="literal">doc_values</code> are enabled on that field
</li>
<li class="listitem">
Every document should contain a single value. If a document has multiple values for the specified field, the first value is used.
</li>
<li class="listitem">
The value for each document should be set once when the document is created and never updated. This ensures that each
slice gets deterministic results.
</li>
<li class="listitem">
The cardinality of the field should be high. This ensures that each slice gets approximately the same amount of documents.
</li>
</ul>
</div>
<div class="pre_wrapper lang-ruby alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-ruby alternative">response = client.search(
  index: 'my-index-000001',
  scroll: '1m',
  body: {
    slice: {
      field: '@timestamp',
      id: 0,
      max: 10
    },
    query: {
      match: {
        message: 'foo'
      }
    }
  }
)
puts response</pre>
</div>
<div class="pre_wrapper lang-js alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-js alternative">const response = await client.search({
  index: "my-index-000001",
  scroll: "1m",
  slice: {
    field: "@timestamp",
    id: 0,
    max: 10,
  },
  query: {
    match: {
      message: "foo",
    },
  },
});
console.log(response);</pre>
</div>
<a id="187733e50c60350f3f75921bea3b72c2"></a>
<div class="pre_wrapper lang-console default has-ruby has-js">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-console default has-ruby has-js">GET /my-index-000001/_search?scroll=1m
{
  "slice": {
    "field": "@timestamp",
    "id": 0,
    "max": 10
  },
  "query": {
    "match": {
      "message": "foo"
    }
  }
}</pre>
</div>
<div class="console_widget has-ruby has-js" data-snippet="snippets/892.console"></div>
<p>For append only time-based indices, the <code class="literal">timestamp</code> field can be used safely.</p>
</div>
</div>
</div><div class="navfooter">
<span class="prev">
<a href="sort-search-results.html">« Sort search results</a>
</span>
<span class="next">
<a href="search-fields.html">Retrieve selected fields from a search »</a>
</span>
</div>

                  <!-- end body -->
                </div>

                <div class="col-12 order-3 col-lg-2 order-lg-3 h-almost-full-lg sticky-top-lg" id="right_col">
                  <div id="sticky_content">
                    <!-- The OTP is appended here -->
                    <div class="row">
                      <div class="col-0 col-md-4 col-lg-0" id="bottom_left_col"></div>
                      <div class="col-12 col-md-8 col-lg-12">
                        <div id="rtpcontainer">
                          <div class="mktg-promo" id="most-popular">
                            <p class="aside-heading">Most Popular</p>
                            <div class="pb-2">
                              <p class="media-type">Video</p>
                              <a href="https://www.elastic.co/webinars/getting-started-elasticsearch?page=docs&placement=top-video">
                                <p class="mb-0">Get Started with Elasticsearch</p>
                              </a>
                            </div>
                            <div class="pb-2">
                              <p class="media-type">Video</p>
                              <a href="https://www.elastic.co/webinars/getting-started-kibana?page=docs&placement=top-video">
                                <p class="mb-0">Intro to Kibana</p>
                              </a>
                            </div>
                            <div class="pb-2">
                              <p class="media-type">Video</p>
                              <a href="https://www.elastic.co/webinars/introduction-elk-stack?page=docs&placement=top-video">
                                <p class="mb-0">ELK for Logs & Metrics</p>
                              </a>
                            </div>
                          </div>
                        </div>

                        <!-- Feedback widget -->
                        <div id="feedbackWidgetContainer"></div>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </section>

        </div>


        <div id='elastic-footer'></div>
        <script src='https://www.elastic.co/elastic-footer.js'></script>
        <!-- Footer Section end-->

      </section>
    </div>

    <!-- Feedback modal -->
    <div id="feedbackModalContainer"></div>

    <script src="/guide/static/jquery.js"></script>
    <script type="text/javascript" src="/guide/static/docs-v1.js"></script>
    <script type="text/javascript">
  window.initial_state = {"alternatives":{"console":{"php":{"hasAny":true},"python":{"hasAny":true},"ruby":{"hasAny":true},"go":{"hasAny":true},"js":{"hasAny":true}}}}</script>
  </body>
</html>
