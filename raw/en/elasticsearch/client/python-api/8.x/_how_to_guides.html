<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>How-To Guides | Elasticsearch Python Client [8.x] | Elastic</title>
<meta class="elastic" name="content" content="How-To Guides | Elasticsearch Python Client [8.x]">

<link rel="home" href="index.html" title="Elasticsearch Python Client [8.x]"/>
<link rel="up" href="elasticsearch-dsl.html" title="Elasticsearch Python DSL"/>
<link rel="prev" href="_tutorials.html" title="Tutorials"/>
<link rel="next" href="_examples.html" title="Examples"/>
<meta class="elastic" name="product_version" content="8.x"/>
<meta class="elastic" name="product_name" content="Clients"/>
<meta class="elastic" name="website_area" content="documentation"/>
<meta name="DC.type" content="Learn/Docs/Clients/Python/8.x"/>
<meta name="DC.subject" content="Clients"/>
<meta name="DC.identifier" content="8.x"/>
<meta name="robots" content="noindex,nofollow"/>
</head>
<body>
<div class="page_header">
This documentation contains work-in-progress information for future Elastic Stack and Cloud releases. Use the version selector to view supported release docs. It also contains some Elastic Cloud serverless information. Check out our <a href="https://www.elastic.co/docs/current/serverless">serverless docs</a> for more details.
</div>
<div class="navheader">
<span class="prev">
<a href="_tutorials.html">« Tutorials</a>
</span>
<span class="next">
<a href="_examples.html">Examples »</a>
</span>
</div>
<div class="book" lang="en">
<div class="titlepage">
<div class="breadcrumbs">
<span class="breadcrumb-link"><a href="/guide/">Elastic Docs</a></span>
<span class="chevron-right">›</span><span class="breadcrumb-link"><a href="index.html">Elasticsearch Python Client [8.x]</a></span>
<span class="chevron-right">›</span><span class="breadcrumb-link"><a href="elasticsearch-dsl.html">Elasticsearch Python DSL</a></span>
</div>
<div>
<div><h1 class="title"><a id="id-1"></a>How-To Guides</h1><a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch-py/edit/8.19/docs/guide/dsl/howto.asciidoc">edit</a></div>
</div>
<!--EXTRA-->
</div>
<div id="content">
<div id="url-to-v3" class="version-warning">
    <strong>IMPORTANT</strong>: This documentation is no longer updated. Refer to <a href="https://www.elastic.co/support/eol">Elastic's version policy</a> and the <a href="https://www.elastic.co/docs/reference/elasticsearch/clients/python/dsl_how_to_guides">latest documentation</a>.
</div>
<div class="section">
<div class="titlepage"><div><div>
<div class="position-relative"><h2 class="title"><a id="_how_to_guides"></a>How-To Guides</h2><a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch-py/edit/8.19/docs/guide/dsl/howto.asciidoc">edit</a></div>
</div></div></div>
<div class="section">
<div class="titlepage"><div><div>
<div class="position-relative"><h3 class="title"><a id="search_dsl"></a>Search DSL</h3><a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch-py/edit/8.19/docs/guide/dsl/search_dsl.asciidoc">edit</a></div>
</div></div></div>
<div class="section">
<div class="titlepage"><div><div>
<div class="position-relative"><h4 class="title"><a id="_the_search_object"></a>The <code class="literal">Search</code> object</h4><a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch-py/edit/8.19/docs/guide/dsl/search_dsl.asciidoc">edit</a></div>
</div></div></div>
<p>The <code class="literal">Search</code> object represents the entire search request:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
queries
</li>
<li class="listitem">
filters
</li>
<li class="listitem">
aggregations
</li>
<li class="listitem">
k-nearest neighbor searches
</li>
<li class="listitem">
sort
</li>
<li class="listitem">
pagination
</li>
<li class="listitem">
highlighting
</li>
<li class="listitem">
suggestions
</li>
<li class="listitem">
collapsing
</li>
<li class="listitem">
additional parameters
</li>
<li class="listitem">
associated client
</li>
</ul>
</div>
<p>The API is designed to be chainable. With the exception of the
aggregations functionality this means that the <code class="literal">Search</code> object is
immutable -all changes to the object will result in a shallow copy being
created which contains the changes. This means you can safely pass the
<code class="literal">Search</code> object to foreign code without fear of it modifying your
objects as long as it sticks to the <code class="literal">Search</code> object APIs.</p>
<p>You can pass an instance of the
<a href="https://elasticsearch-py.readthedocs.io/" class="ulink" target="_top">elasticsearch client</a> when
instantiating the <code class="literal">Search</code> object:</p>
<div class="pre_wrapper lang-python">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-python">from elasticsearch import Elasticsearch
from elasticsearch.dsl import Search

client = Elasticsearch()

s = Search(using=client)</pre>
</div>
<p>You can also define the client at a later time (for more options see the
<code class="literal">configuration</code> chapter):</p>
<div class="pre_wrapper lang-python">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-python">s = s.using(client)</pre>
</div>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p>All methods return a <em>copy</em> of the object, making it safe to pass to
outside code.</p>
</div>
</div>
<p>The API is chainable, allowing you to combine multiple method calls in
one statement:</p>
<div class="pre_wrapper lang-python">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-python">s = Search().using(client).query("match", title="python")</pre>
</div>
<p>To send the request to Elasticsearch:</p>
<div class="pre_wrapper lang-python">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-python">response = s.execute()</pre>
</div>
<p>If you just want to iterate over the hits returned by your search you
can iterate over the <code class="literal">Search</code> object:</p>
<div class="pre_wrapper lang-python">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-python">for hit in s:
    print(hit.title)</pre>
</div>
<p>Search results will be cached. Subsequent calls to <code class="literal">execute</code> or trying
to iterate over an already executed <code class="literal">Search</code> object will not trigger
additional requests being sent to Elasticsearch. To force a request
specify <code class="literal">ignore_cache=True</code> when calling <code class="literal">execute</code>.</p>
<p>For debugging purposes you can serialize the <code class="literal">Search</code> object to a <code class="literal">dict</code>
explicitly:</p>
<div class="pre_wrapper lang-python">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-python">print(s.to_dict())</pre>
</div>
<div class="section">
<div class="titlepage"><div><div>
<div class="position-relative"><h5 class="title"><a id="_delete_by_query"></a>Delete By Query</h5><a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch-py/edit/8.19/docs/guide/dsl/search_dsl.asciidoc">edit</a></div>
</div></div></div>
<p>You can delete the documents matching a search by calling <code class="literal">delete</code> on
the <code class="literal">Search</code> object instead of <code class="literal">execute</code> like this:</p>
<div class="pre_wrapper lang-python">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-python">s = Search(index='i').query("match", title="python")
response = s.delete()</pre>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<div class="position-relative"><h5 class="title"><a id="_queries"></a>Queries</h5><a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch-py/edit/8.19/docs/guide/dsl/search_dsl.asciidoc">edit</a></div>
</div></div></div>
<p>The library provides classes for all Elasticsearch query types. Pass all
the parameters as keyword arguments. The classes accept any keyword
arguments, the dsl then takes all arguments passed to the constructor
and serializes them as top-level keys in the resulting dictionary (and
thus the resulting json being sent to elasticsearch). This means that
there is a clear one-to-one mapping between the raw query and its
equivalent in the DSL:</p>
<div class="pre_wrapper lang-python">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-python">from elasticsearch.dsl.query import MultiMatch, Match

# {"multi_match": {"query": "python django", "fields": ["title", "body"]}}
MultiMatch(query='python django', fields=['title', 'body'])

# {"match": {"title": {"query": "web framework", "type": "phrase"}}}
Match(title={"query": "web framework", "type": "phrase"})</pre>
</div>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p>In some cases this approach is not possible due to python&#8217;s restriction
on identifiers - for example if your field is called <code class="literal">@timestamp</code>. In
that case you have to fall back to unpacking a dictionary:
<code class="literal">Range(*+ {'@timestamp': {'lt': 'now'}})</code></p>
</div>
</div>
<p>You can use the <code class="literal">Q</code> shortcut to construct the instance using a name with
parameters or the raw <code class="literal">dict</code>:</p>
<div class="pre_wrapper lang-python">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-python">from elasticsearch.dsl import Q

Q("multi_match", query='python django', fields=['title', 'body'])
Q({"multi_match": {"query": "python django", "fields": ["title", "body"]}})</pre>
</div>
<p>To add the query to the <code class="literal">Search</code> object, use the <code class="literal">.query()</code> method:</p>
<div class="pre_wrapper lang-python">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-python">q = Q("multi_match", query='python django', fields=['title', 'body'])
s = s.query(q)</pre>
</div>
<p>The method also accepts all the parameters as the <code class="literal">Q</code> shortcut:</p>
<div class="pre_wrapper lang-python">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-python">s = s.query("multi_match", query='python django', fields=['title', 'body'])</pre>
</div>
<p>If you already have a query object, or a <code class="literal">dict</code> representing one, you
can just override the query used in the <code class="literal">Search</code> object:</p>
<div class="pre_wrapper lang-python">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-python">s.query = Q('bool', must=[Q('match', title='python'), Q('match', body='best')])</pre>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<div class="position-relative"><h5 class="title"><a id="_dotted_fields"></a>Dotted fields</h5><a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch-py/edit/8.19/docs/guide/dsl/search_dsl.asciidoc">edit</a></div>
</div></div></div>
<p>Sometimes you want to refer to a field within another field, either as a
multi-field (<code class="literal">title.keyword</code>) or in a structured <code class="literal">json</code> document like
<code class="literal">address.city</code>. To make it easier, the <code class="literal">Q</code> shortcut (as well as the
<code class="literal">query</code>, <code class="literal">filter</code>, and <code class="literal">exclude</code> methods on <code class="literal">Search</code> class) allows you
to use <code class="literal">_+</code> (double underscore) in place of a dot in a keyword
argument:</p>
<div class="pre_wrapper lang-python">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-python">s = Search()
s = s.filter('term', category__keyword='Python')
s = s.query('match', address__city='prague')</pre>
</div>
<p>Alternatively you can always fall back to python&#8217;s kwarg unpacking if
you prefer:</p>
<div class="pre_wrapper lang-python">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-python">s = Search()
s = s.filter('term', **{'category.keyword': 'Python'})
s = s.query('match', **{'address.city': 'prague'})</pre>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<div class="position-relative"><h5 class="title"><a id="_query_combination"></a>Query combination</h5><a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch-py/edit/8.19/docs/guide/dsl/search_dsl.asciidoc">edit</a></div>
</div></div></div>
<p>Query objects can be combined using logical operators:</p>
<div class="pre_wrapper lang-python">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-python">Q("match", title='python') | Q("match", title='django')
# {"bool": {"should": [...]}}

Q("match", title='python') &amp; Q("match", title='django')
# {"bool": {"must": [...]}}

~Q("match", title="python")
# {"bool": {"must_not": [...]}}</pre>
</div>
<p>When you call the <code class="literal">.query()</code> method multiple times, the <code class="literal">&amp;</code> operator
will be used internally:</p>
<div class="pre_wrapper lang-python">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-python">s = s.query().query()
print(s.to_dict())
# {"query": {"bool": {...}}}</pre>
</div>
<p>If you want to have precise control over the query form, use the <code class="literal">Q</code>
shortcut to directly construct the combined query:</p>
<div class="pre_wrapper lang-python">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-python">q = Q('bool',
    must=[Q('match', title='python')],
    should=[Q(...), Q(...)],
    minimum_should_match=1
)
s = Search().query(q)</pre>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<div class="position-relative"><h5 class="title"><a id="_filters"></a>Filters</h5><a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch-py/edit/8.19/docs/guide/dsl/search_dsl.asciidoc">edit</a></div>
</div></div></div>
<p>If you want to add a query in a
<a href="/guide/en/elasticsearch/reference/2.0/query-filter-context.html" class="ulink" target="_top">filter
context</a> you can use the <code class="literal">filter()</code> method to make things easier:</p>
<div class="pre_wrapper lang-python">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-python">s = Search()
s = s.filter('terms', tags=['search', 'python'])</pre>
</div>
<p>Behind the scenes this will produce a <code class="literal">Bool</code> query and place the
specified <code class="literal">terms</code> query into its <code class="literal">filter</code> branch, making it equivalent
to:</p>
<div class="pre_wrapper lang-python">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-python">s = Search()
s = s.query('bool', filter=[Q('terms', tags=['search', 'python'])])</pre>
</div>
<p>If you want to use the post_filter element for faceted navigation,
use the <code class="literal">.post_filter()</code> method.</p>
<p>You can also <code class="literal">exclude()</code> items from your query like this:</p>
<div class="pre_wrapper lang-python">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-python">s = Search()
s = s.exclude('terms', tags=['search', 'python'])</pre>
</div>
<p>which is shorthand for:
<code class="literal">s = s.query('bool', filter=[~Q('terms', tags=['search', 'python'])])</code></p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<div class="position-relative"><h5 class="title"><a id="_aggregations"></a>Aggregations</h5><a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch-py/edit/8.19/docs/guide/dsl/search_dsl.asciidoc">edit</a></div>
</div></div></div>
<p>To define an aggregation, you can use the <code class="literal">A</code> shortcut:</p>
<div class="pre_wrapper lang-python">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-python">from elasticsearch.dsl import A

A('terms', field='tags')
# {"terms": {"field": "tags"}}</pre>
</div>
<p>To nest aggregations, you can use the <code class="literal">.bucket()</code>, <code class="literal">.metric()</code> and
<code class="literal">.pipeline()</code> methods:</p>
<div class="pre_wrapper lang-python">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-python">a = A('terms', field='category')
# {'terms': {'field': 'category'}}

a.metric('clicks_per_category', 'sum', field='clicks')\
    .bucket('tags_per_category', 'terms', field='tags')
# {
#   'terms': {'field': 'category'},
#   'aggs': {
#     'clicks_per_category': {'sum': {'field': 'clicks'}},
#     'tags_per_category': {'terms': {'field': 'tags'}}
#   }
# }</pre>
</div>
<p>To add aggregations to the <code class="literal">Search</code> object, use the <code class="literal">.aggs</code> property,
which acts as a top-level aggregation:</p>
<div class="pre_wrapper lang-python">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-python">s = Search()
a = A('terms', field='category')
s.aggs.bucket('category_terms', a)
# {
#   'aggs': {
#     'category_terms': {
#       'terms': {
#         'field': 'category'
#       }
#     }
#   }
# }</pre>
</div>
<p>or</p>
<div class="pre_wrapper lang-python">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-python">s = Search()
s.aggs.bucket('articles_per_day', 'date_histogram', field='publish_date', interval='day')\
    .metric('clicks_per_day', 'sum', field='clicks')\
    .pipeline('moving_click_average', 'moving_avg', buckets_path='clicks_per_day')\
    .bucket('tags_per_day', 'terms', field='tags')

s.to_dict()
# {
#   "aggs": {
#     "articles_per_day": {
#       "date_histogram": { "interval": "day", "field": "publish_date" },
#       "aggs": {
#         "clicks_per_day": { "sum": { "field": "clicks" } },
#         "moving_click_average": { "moving_avg": { "buckets_path": "clicks_per_day" } },
#         "tags_per_day": { "terms": { "field": "tags" } }
#       }
#     }
#   }
# }</pre>
</div>
<p>You can access an existing bucket by its name:</p>
<div class="pre_wrapper lang-python">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-python">s = Search()

s.aggs.bucket('per_category', 'terms', field='category')
s.aggs['per_category'].metric('clicks_per_category', 'sum', field='clicks')
s.aggs['per_category'].bucket('tags_per_category', 'terms', field='tags')</pre>
</div>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p>When chaining multiple aggregations, there is a difference between what
<code class="literal">.bucket()</code> and <code class="literal">.metric()</code> methods return - <code class="literal">.bucket()</code> returns the
newly defined bucket while <code class="literal">.metric()</code> returns its parent bucket to
allow further chaining.</p>
</div>
</div>
<p>As opposed to other methods on the <code class="literal">Search</code> objects, defining
aggregations is done in-place (does not return a copy).</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<div class="position-relative"><h5 class="title"><a id="_k_nearest_neighbor_searches"></a>K-Nearest Neighbor Searches</h5><a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch-py/edit/8.19/docs/guide/dsl/search_dsl.asciidoc">edit</a></div>
</div></div></div>
<p>To issue a kNN search, use the <code class="literal">.knn()</code> method:</p>
<div class="pre_wrapper lang-python">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-python">s = Search()
vector = get_embedding("search text")

s = s.knn(
    field="embedding",
    k=5,
    num_candidates=10,
    query_vector=vector
)</pre>
</div>
<p>The <code class="literal">field</code>, <code class="literal">k</code> and <code class="literal">num_candidates</code> arguments can be given as
positional or keyword arguments and are required. In addition to these,
<code class="literal">query_vector</code> or <code class="literal">query_vector_builder</code> must be given as
well.</p>
<p>The <code class="literal">.knn()</code> method can be invoked multiple times to include multiple
kNN searches in the request.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<div class="position-relative"><h5 class="title"><a id="_sorting"></a>Sorting</h5><a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch-py/edit/8.19/docs/guide/dsl/search_dsl.asciidoc">edit</a></div>
</div></div></div>
<p>To specify sorting order, use the <code class="literal">.sort()</code> method:</p>
<div class="pre_wrapper lang-python">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-python">s = Search().sort(
    'category',
    '-title',
    {"lines" : {"order" : "asc", "mode" : "avg"}}
)</pre>
</div>
<p>It accepts positional arguments which can be either strings or
dictionaries. String value is a field name, optionally prefixed by the
<code class="literal">-</code> sign to specify a descending order.</p>
<p>To reset the sorting, just call the method with no arguments:</p>
<div class="pre_wrapper lang-python">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-python">s = s.sort()</pre>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<div class="position-relative"><h5 class="title"><a id="_pagination"></a>Pagination</h5><a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch-py/edit/8.19/docs/guide/dsl/search_dsl.asciidoc">edit</a></div>
</div></div></div>
<p>To specify the from/size parameters, use the Python slicing API:</p>
<div class="pre_wrapper lang-python">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-python">s = s[10:20]
# {"from": 10, "size": 10}

s = s[:20]
# {"size": 20}

s = s[10:]
# {"from": 10}

s = s[10:20][2:]
# {"from": 12, "size": 8}</pre>
</div>
<p>If you want to access all the documents matched by your query you can
use the <code class="literal">scan</code> method which uses the scan/scroll elasticsearch API:</p>
<div class="pre_wrapper lang-python">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-python">for hit in s.scan():
    print(hit.title)</pre>
</div>
<p>Note that in this case the results won&#8217;t be sorted.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<div class="position-relative"><h5 class="title"><a id="_highlighting"></a>Highlighting</h5><a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch-py/edit/8.19/docs/guide/dsl/search_dsl.asciidoc">edit</a></div>
</div></div></div>
<p>To set common attributes for highlighting use the
<code class="literal">highlight_options</code> method:</p>
<div class="pre_wrapper lang-python">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-python">s = s.highlight_options(order='score')</pre>
</div>
<p>Enabling highlighting for individual fields is done using the
<code class="literal">highlight</code> method:</p>
<div class="pre_wrapper lang-python">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-python">s = s.highlight('title')
# or, including parameters:
s = s.highlight('title', fragment_size=50)</pre>
</div>
<p>The fragments in the response will then be available on each <code class="literal">Result</code>
object as <code class="literal">.meta.highlight.FIELD</code> which will contain the list of
fragments:</p>
<div class="pre_wrapper lang-python">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-python">response = s.execute()
for hit in response:
    for fragment in hit.meta.highlight.title:
        print(fragment)</pre>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<div class="position-relative"><h5 class="title"><a id="_suggestions"></a>Suggestions</h5><a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch-py/edit/8.19/docs/guide/dsl/search_dsl.asciidoc">edit</a></div>
</div></div></div>
<p>To specify a suggest request on your <code class="literal">Search</code> object use the <code class="literal">suggest</code>
method:</p>
<div class="pre_wrapper lang-python">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-python"># check for correct spelling
s = s.suggest('my_suggestion', 'pyhton', term={'field': 'title'})</pre>
</div>
<p>The first argument is the name of the suggestions (name under which it
will be returned), second is the actual text you wish the suggester to
work on and the keyword arguments will be added to the suggest&#8217;s json
as-is which means that it should be one of <code class="literal">term</code>, <code class="literal">phrase</code> or
<code class="literal">completion</code> to indicate which type of suggester should be used.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<div class="position-relative"><h5 class="title"><a id="_collapsing"></a>Collapsing</h5><a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch-py/edit/8.19/docs/guide/dsl/search_dsl.asciidoc">edit</a></div>
</div></div></div>
<p>To collapse search results use the <code class="literal">collapse</code> method on your <code class="literal">Search</code>
object:</p>
<div class="pre_wrapper lang-python">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-python">s = Search().query("match", message="GET /search")
# collapse results by user_id
s = s.collapse("user_id")</pre>
</div>
<p>The top hits will only include one result per <code class="literal">user_id</code>. You can
also expand each collapsed top hit with the <code class="literal">inner_hits</code> parameter,
<code class="literal">max_concurrent_group_searches</code> being the number of
concurrent requests allowed to retrieve the inner hits per group:</p>
<div class="pre_wrapper lang-python">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-python">inner_hits = {"name": "recent_search", "size": 5, "sort": [{"@timestamp": "desc"}]}
s = s.collapse("user_id", inner_hits=inner_hits, max_concurrent_group_searches=4)</pre>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<div class="position-relative"><h5 class="title"><a id="_more_like_this_query"></a>More Like This Query</h5><a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch-py/edit/8.19/docs/guide/dsl/search_dsl.asciidoc">edit</a></div>
</div></div></div>
<p>To use Elasticsearch&#8217;s <code class="literal">more_like_this</code> functionality, you can use
the MoreLikeThis query type.</p>
<p>A simple example is below</p>
<div class="pre_wrapper lang-python">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-python">from elasticsearch.dsl.query import MoreLikeThis
from elasticsearch.dsl import Search

my_text = 'I want to find something similar'

s = Search()
# We're going to match based only on two fields, in this case text and title
s = s.query(MoreLikeThis(like=my_text, fields=['text', 'title']))
# You can also exclude fields from the result to make the response quicker in the normal way
s = s.source(exclude=["text"])
response = s.execute()

for hit in response:
    print(hit.title)</pre>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<div class="position-relative"><h5 class="title"><a id="_extra_properties_and_parameters"></a>Extra properties and parameters</h5><a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch-py/edit/8.19/docs/guide/dsl/search_dsl.asciidoc">edit</a></div>
</div></div></div>
<p>To set extra properties of the search request, use the <code class="literal">.extra()</code>
method. This can be used to define keys in the body that cannot be
defined via a specific API method like <code class="literal">explain</code> or <code class="literal">search_after</code>:</p>
<div class="pre_wrapper lang-python">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-python">s = s.extra(explain=True)</pre>
</div>
<p>To set query parameters, use the <code class="literal">.params()</code> method:</p>
<div class="pre_wrapper lang-python">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-python">s = s.params(routing="42")</pre>
</div>
<p>If you need to limit the fields being returned by elasticsearch, use the
<code class="literal">source()</code> method:</p>
<div class="pre_wrapper lang-python">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-python"># only return the selected fields
s = s.source(['title', 'body'])
# don't return any fields, just the metadata
s = s.source(False)
# explicitly include/exclude fields
s = s.source(includes=["title"], excludes=["user.*"])
# reset the field selection
s = s.source(None)</pre>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<div class="position-relative"><h5 class="title"><a id="_serialization_and_deserialization"></a>Serialization and Deserialization</h5><a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch-py/edit/8.19/docs/guide/dsl/search_dsl.asciidoc">edit</a></div>
</div></div></div>
<p>The search object can be serialized into a dictionary by using the
<code class="literal">.to_dict()</code> method.</p>
<p>You can also create a <code class="literal">Search</code> object from a <code class="literal">dict</code> using the
<code class="literal">from_dict</code> class method. This will create a new <code class="literal">Search</code> object and
populate it using the data from the dict:</p>
<div class="pre_wrapper lang-python">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-python">s = Search.from_dict({"query": {"match": {"title": "python"}}})</pre>
</div>
<p>If you wish to modify an existing <code class="literal">Search</code> object, overriding it&#8217;s
properties, instead use the <code class="literal">update_from_dict</code> method that
alters an instance <span class="strong strong"><strong>in-place</strong></span>:</p>
<div class="pre_wrapper lang-python">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-python">s = Search(index='i')
s.update_from_dict({"query": {"match": {"title": "python"}}, "size": 42})</pre>
</div>
</div>

</div>

<div class="section">
<div class="titlepage"><div><div>
<div class="position-relative"><h4 class="title"><a id="_response"></a>Response</h4><a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch-py/edit/8.19/docs/guide/dsl/search_dsl.asciidoc">edit</a></div>
</div></div></div>
<p>You can execute your search by calling the <code class="literal">.execute()</code> method that will
return a <code class="literal">Response</code> object. The <code class="literal">Response</code> object allows you access to
any key from the response dictionary via attribute access. It also
provides some convenient helpers:</p>
<div class="pre_wrapper lang-python">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-python">response = s.execute()

print(response.success())
# True

print(response.took)
# 12

print(response.hits.total.relation)
# eq
print(response.hits.total.value)
# 142

print(response.suggest.my_suggestions)</pre>
</div>
<p>If you want to inspect the contents of the <code class="literal">response</code> objects, just use
its <code class="literal">to_dict</code> method to get access to the raw data for pretty
printing.</p>
<div class="section">
<div class="titlepage"><div><div>
<div class="position-relative"><h5 class="title"><a id="_hits"></a>Hits</h5><a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch-py/edit/8.19/docs/guide/dsl/search_dsl.asciidoc">edit</a></div>
</div></div></div>
<p>To access to the hits returned by the search, access the <code class="literal">hits</code> property
or just iterate over the <code class="literal">Response</code> object:</p>
<div class="pre_wrapper lang-python">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-python">response = s.execute()
print('Total %d hits found.' % response.hits.total)
for h in response:
    print(h.title, h.body)</pre>
</div>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p>If you are only seeing partial results (e.g. 10000 or even 10 results),
consider using the option <code class="literal">s.extra(track_total_hits=True)</code> to
get a full hit count.</p>
</div>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<div class="position-relative"><h5 class="title"><a id="_result"></a>Result</h5><a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch-py/edit/8.19/docs/guide/dsl/search_dsl.asciidoc">edit</a></div>
</div></div></div>
<p>The individual hits is wrapped in a convenience class that allows
attribute access to the keys in the returned dictionary. All the
metadata for the results are accessible via <code class="literal">meta</code> (without the leading
<code class="literal">_</code>):</p>
<div class="pre_wrapper lang-python">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-python">response = s.execute()
h = response.hits[0]
print('/%s/%s/%s returned with score %f' % (
    h.meta.index, h.meta.doc_type, h.meta.id, h.meta.score))</pre>
</div>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p>If your document has a field called <code class="literal">meta</code> you have to access it using
the get item syntax: <code class="literal">hit['meta']</code>.</p>
</div>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<div class="position-relative"><h5 class="title"><a id="_aggregations_2"></a>Aggregations</h5><a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch-py/edit/8.19/docs/guide/dsl/search_dsl.asciidoc">edit</a></div>
</div></div></div>
<p>Aggregations are available through the <code class="literal">aggregations</code> property:</p>
<div class="pre_wrapper lang-python">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-python">for tag in response.aggregations.per_tag.buckets:
    print(tag.key, tag.max_lines.value)</pre>
</div>
</div>

</div>

<div class="section">
<div class="titlepage"><div><div>
<div class="position-relative"><h4 class="title"><a id="_multisearch"></a><code class="literal">MultiSearch</code></h4><a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch-py/edit/8.19/docs/guide/dsl/search_dsl.asciidoc">edit</a></div>
</div></div></div>
<p>If you need to execute multiple searches at the same time you can use
the <code class="literal">MultiSearch</code> class which will use the <code class="literal">_msearch</code> API:</p>
<div class="pre_wrapper lang-python">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-python">from elasticsearch.dsl import MultiSearch, Search

ms = MultiSearch(index='blogs')

ms = ms.add(Search().filter('term', tags='python'))
ms = ms.add(Search().filter('term', tags='elasticsearch'))

responses = ms.execute()

for response in responses:
    print("Results for query %r." % response._search.query)
    for hit in response:
        print(hit.title)</pre>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<div class="position-relative"><h4 class="title"><a id="_emptysearch"></a><code class="literal">EmptySearch</code></h4><a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch-py/edit/8.19/docs/guide/dsl/search_dsl.asciidoc">edit</a></div>
</div></div></div>
<p>The <code class="literal">EmptySearch</code> class can be used as a fully compatible version of
<code class="literal">Search</code> that will return no results, regardless of any queries
configured.</p>
</div>

</div>

<div class="section">
<div class="titlepage"><div><div>
<div class="position-relative"><h3 class="title"><a id="_persistence_2"></a>Persistence</h3><a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch-py/edit/8.19/docs/guide/dsl/persistence.asciidoc">edit</a></div>
</div></div></div>
<p>You can use the DSL module to define your mappings and a basic
persistent layer for your application.</p>
<p>For more comprehensive examples have a look at the
<a href="https://github.com/elastic/elasticsearch-py/tree/main/examples/dsl" class="ulink" target="_top">DSL examples</a>
directory in the repository.</p>
<div class="section">
<div class="titlepage"><div><div>
<div class="position-relative"><h4 class="title"><a id="doc_type"></a>Document</h4><a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch-py/edit/8.19/docs/guide/dsl/persistence.asciidoc">edit</a></div>
</div></div></div>
<p>If you want to create a model-like wrapper around your documents, use
the <code class="literal">Document</code> class. It can also be used to create all the necessary
mappings and settings in elasticsearch (see <code class="literal">life-cycle</code> for details).</p>
<div class="pre_wrapper lang-python">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-python">from datetime import datetime
from elasticsearch.dsl import Document, Date, Nested, Boolean, \
    analyzer, InnerDoc, Completion, Keyword, Text

html_strip = analyzer('html_strip',
    tokenizer="standard",
    filter=["standard", "lowercase", "stop", "snowball"],
    char_filter=["html_strip"]
)

class Comment(InnerDoc):
    author = Text(fields={'raw': Keyword()})
    content = Text(analyzer='snowball')
    created_at = Date()

    def age(self):
        return datetime.now() - self.created_at

class Post(Document):
    title = Text()
    title_suggest = Completion()
    created_at = Date()
    published = Boolean()
    category = Text(
        analyzer=html_strip,
        fields={'raw': Keyword()}
    )

    comments = Nested(Comment)

    class Index:
        name = 'blog'

    def add_comment(self, author, content):
        self.comments.append(
          Comment(author=author, content=content, created_at=datetime.now()))

    def save(self, ** kwargs):
        self.created_at = datetime.now()
        return super().save(** kwargs)</pre>
</div>
<div class="section">
<div class="titlepage"><div><div>
<div class="position-relative"><h5 class="title"><a id="_data_types"></a>Data types</h5><a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch-py/edit/8.19/docs/guide/dsl/persistence.asciidoc">edit</a></div>
</div></div></div>
<p>The <code class="literal">Document</code> instances use native python types like <code class="literal">str</code> and
<code class="literal">datetime</code>. In case of <code class="literal">Object</code> or <code class="literal">Nested</code> fields an instance of the
<code class="literal">InnerDoc</code> subclass is used, as in the <code class="literal">add_comment</code> method in the
above example where we are creating an instance of the <code class="literal">Comment</code> class.</p>
<p>There are some specific types that were created as part of this library
to make working with some field types easier, for example the <code class="literal">Range</code>
object used in any of the
<a href="/guide/en/elasticsearch/reference/current/range.html" class="ulink" target="_top">range
fields</a>:</p>
<div class="pre_wrapper lang-python">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-python">from elasticsearch.dsl import Document, DateRange, Keyword, Range

class RoomBooking(Document):
    room = Keyword()
    dates = DateRange()


rb = RoomBooking(
  room='Conference Room II',
  dates=Range(
    gte=datetime(2018, 11, 17, 9, 0, 0),
    lt=datetime(2018, 11, 17, 10, 0, 0)
  )
)

# Range supports the in operator correctly:
datetime(2018, 11, 17, 9, 30, 0) in rb.dates # True

# you can also get the limits and whether they are inclusive or exclusive:
rb.dates.lower # datetime(2018, 11, 17, 9, 0, 0), True
rb.dates.upper # datetime(2018, 11, 17, 10, 0, 0), False

# empty range is unbounded
Range().lower # None, False</pre>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<div class="position-relative"><h5 class="title"><a id="_python_type_hints"></a>Python Type Hints</h5><a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch-py/edit/8.19/docs/guide/dsl/persistence.asciidoc">edit</a></div>
</div></div></div>
<p>Document fields can be defined using standard Python type hints if
desired. Here are some simple examples:</p>
<div class="pre_wrapper lang-python">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-python">from typing import Optional

class Post(Document):
    title: str                      # same as title = Text(required=True)
    created_at: Optional[datetime]  # same as created_at = Date(required=False)
    published: bool                 # same as published = Boolean(required=True)</pre>
</div>
<p>It is important to note that when using <code class="literal">Field</code> subclasses such as
<code class="literal">Text</code>, <code class="literal">Date</code> and <code class="literal">Boolean</code>, they must be given in the right-side of an
assignment, as shown in examples above. Using these classes as type
hints will result in errors.</p>
<p>Python types are mapped to their corresponding field type according to
the following table:</p>
<div class="table">
<p class="title"><strong>Table 1. Python type to DSL field mappings</strong></p>
<div class="table-contents">
<table border="1" cellpadding="4px" summary="Python type to DSL field mappings">
<colgroup>
<col class="col_1"/>
<col class="col_2"/>
</colgroup>
<thead>
<tr>
<th align="left" valign="top">Python type</th>
<th align="left" valign="top">DSL field</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" valign="top"><p><code class="literal">str</code></p></td>
<td align="left" valign="top"><p><code class="literal">Text(required=True)</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p><code class="literal">bool</code></p></td>
<td align="left" valign="top"><p><code class="literal">Boolean(required=True)</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p><code class="literal">int</code></p></td>
<td align="left" valign="top"><p><code class="literal">Integer(required=True)</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p><code class="literal">float</code></p></td>
<td align="left" valign="top"><p><code class="literal">Float(required=True)</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p><code class="literal">bytes</code></p></td>
<td align="left" valign="top"><p><code class="literal">Binary(required=True)</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p><code class="literal">datetime</code></p></td>
<td align="left" valign="top"><p><code class="literal">Date(required=True)</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p><code class="literal">date</code></p></td>
<td align="left" valign="top"><p><code class="literal">Date(format="yyyy-MM-dd", required=True)</code></p></td>
</tr>
</tbody>
</table>
</div>
</div>
<p>To type a field as optional, the standard <code class="literal">Optional</code> modifier from the
Python <code class="literal">typing</code> package can be used. When using Python 3.10 or newer,
"pipe" syntax can also be used, by adding <code class="literal">| None</code> to a type. The
<code class="literal">List</code> modifier can be added to a field to convert it to an array,
similar to using the <code class="literal">multi=True</code> argument on the field object.</p>
<div class="pre_wrapper lang-python">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-python">from typing import Optional, List

class MyDoc(Document):
    pub_date: Optional[datetime]  # same as pub_date = Date()
    middle_name: str | None       # same as middle_name = Text()
    authors: List[str]            # same as authors = Text(multi=True, required=True)
    comments: Optional[List[str]] # same as comments = Text(multi=True)</pre>
</div>
<p>A field can also be given a type hint of an <code class="literal">InnerDoc</code> subclass, in
which case it becomes an <code class="literal">Object</code> field of that class. When the
<code class="literal">InnerDoc</code> subclass is wrapped with <code class="literal">List</code>, a <code class="literal">Nested</code> field is created
instead.</p>
<div class="pre_wrapper lang-python">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-python">from typing import List

class Address(InnerDoc):
    ...

class Comment(InnerDoc):
    ...

class Post(Document):
    address: Address         # same as address = Object(Address, required=True)
    comments: List[Comment]  # same as comments = Nested(Comment, required=True)</pre>
</div>
<p>Unfortunately it is impossible to have Python type hints that uniquely
identify every possible Elasticsearch field type. To choose a field type
that is different than the ones in the table above, the field instance
can be added explicitly as a right-side assignment in the field
declaration. The next example creates a field that is typed as
<code class="literal">Optional[str]</code>, but is mapped to <code class="literal">Keyword</code> instead of <code class="literal">Text</code>:</p>
<div class="pre_wrapper lang-python">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-python">class MyDocument(Document):
    category: Optional[str] = Keyword()</pre>
</div>
<p>This form can also be used when additional options need to be given to
initialize the field, such as when using custom analyzer settings or
changing the <code class="literal">required</code> default:</p>
<div class="pre_wrapper lang-python">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-python">class Comment(InnerDoc):
    content: str = Text(analyzer='snowball', required=True)</pre>
</div>
<p>When using type hints as above, subclasses of <code class="literal">Document</code> and <code class="literal">InnerDoc</code>
inherit some of the behaviors associated with Python dataclasses, as
defined by <a href="https://peps.python.org/pep-0681/" class="ulink" target="_top">PEP 681</a> and the
<a href="https://typing.readthedocs.io/en/latest/spec/dataclasses.html#dataclass-transform" class="ulink" target="_top">dataclass_transform
decorator</a>. To add per-field dataclass options such as <code class="literal">default</code> or
<code class="literal">default_factory</code>, the <code class="literal">mapped_field()</code> wrapper can be used on
the right side of a typed field declaration:</p>
<div class="pre_wrapper lang-python">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-python">class MyDocument(Document):
    title: str = mapped_field(default="no title")
    created_at: datetime = mapped_field(default_factory=datetime.now)
    published: bool = mapped_field(default=False)
    category: str = mapped_field(Keyword(required=True), default="general")</pre>
</div>
<p>When using the <code class="literal">mapped_field()</code> wrapper function, an explicit field
type instance can be passed as a first positional argument, as the
<code class="literal">category</code> field does in the example above.</p>
<p>Static type checkers such as <a href="https://mypy-lang.org/" class="ulink" target="_top">mypy</a> and
<a href="https://github.com/microsoft/pyright" class="ulink" target="_top">pyright</a> can use the type hints and
the dataclass-specific options added to the <code class="literal">mapped_field()</code>
function to improve type inference and provide better real-time
suggestions in IDEs.</p>
<p>One situation in which type checkers can&#8217;t infer the correct type is
when using fields as class attributes. Consider the following example:</p>
<div class="pre_wrapper lang-python">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-python">class MyDocument(Document):
    title: str

doc = MyDocument()
# doc.title is typed as "str" (correct)
# MyDocument.title is also typed as "str" (incorrect)</pre>
</div>
<p>To help type checkers correctly identify class attributes as such, the
<code class="literal">M</code> generic must be used as a wrapper to the type hint, as shown in the
next examples:</p>
<div class="pre_wrapper lang-python">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-python">from elasticsearch.dsl import M

class MyDocument(Document):
    title: M[str]
    created_at: M[datetime] = mapped_field(default_factory=datetime.now)

doc = MyDocument()
# doc.title is typed as "str"
# doc.created_at is typed as "datetime"
# MyDocument.title is typed as "InstrumentedField"
# MyDocument.created_at is typed as "InstrumentedField"</pre>
</div>
<p>Note that the <code class="literal">M</code> type hint does not provide any runtime behavior and
its use is not required, but it can be useful to eliminate spurious type
errors in IDEs or type checking builds.</p>
<p>The <code class="literal">InstrumentedField</code> objects returned when fields are accessed as
class attributes are proxies for the field instances that can be used
anywhere a field needs to be referenced, such as when specifying sort
options in a <code class="literal">Search</code> object:</p>
<div class="pre_wrapper lang-python">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-python"># sort by creation date descending, and title ascending
s = MyDocument.search().sort(-MyDocument.created_at, MyDocument.title)</pre>
</div>
<p>When specifying sorting order, the <code class="literal">{plus}</code> and <code class="literal">-</code> unary operators can
be used on the class field attributes to indicate ascending and
descending order.</p>
<p>Finally, the <code class="literal">ClassVar</code> annotation can be used to define a regular class
attribute that should not be mapped to the Elasticsearch index:</p>
<div class="pre_wrapper lang-python">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-python">from typing import ClassVar

class MyDoc(Document):
  title: M[str] created_at: M[datetime] =
  mapped_field(default_factory=datetime.now) my_var:
  ClassVar[str] # regular class variable, ignored by Elasticsearch</pre>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<div class="position-relative"><h5 class="title"><a id="_note_on_dates"></a>Note on dates</h5><a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch-py/edit/8.19/docs/guide/dsl/persistence.asciidoc">edit</a></div>
</div></div></div>
<p>The DSL module will always respect the timezone information (or
lack thereof) on the <code class="literal">datetime</code> objects passed in or stored in
Elasticsearch. Elasticsearch itself interprets all datetimes with no
timezone information as <code class="literal">UTC</code>. If you wish to reflect this in your
python code, you can specify <code class="literal">default_timezone</code> when instantiating a
<code class="literal">Date</code> field:</p>
<div class="pre_wrapper lang-python">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-python">class Post(Document):
    created_at = Date(default_timezone='UTC')</pre>
</div>
<p>In that case any <code class="literal">datetime</code> object passed in (or parsed from
elasticsearch) will be treated as if it were in <code class="literal">UTC</code> timezone.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<div class="position-relative"><h5 class="title"><a id="life-cycle"></a>Document life cycle</h5><a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch-py/edit/8.19/docs/guide/dsl/persistence.asciidoc">edit</a></div>
</div></div></div>
<p>Before you first use the <code class="literal">Post</code> document type, you need to create the
mappings in Elasticsearch. For that you can either use the <code class="literal">index</code>
object or create the mappings directly by calling the <code class="literal">init</code> class
method:</p>
<div class="pre_wrapper lang-python">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-python"># create the mappings in Elasticsearch
Post.init()</pre>
</div>
<p>This code will typically be run in the setup for your application during
a code deploy, similar to running database migrations.</p>
<p>To create a new <code class="literal">Post</code> document just instantiate the class and pass in
any fields you wish to set, you can then use standard attribute setting
to change/add more fields. Note that you are not limited to the fields
defined explicitly:</p>
<div class="pre_wrapper lang-python">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-python"># instantiate the document
first = Post(title='My First Blog Post, yay!', published=True)
# assign some field values, can be values or lists of values
first.category = ['everything', 'nothing']
# every document has an id in meta
first.meta.id = 47


# save the document into the cluster
first.save()</pre>
</div>
<p>All the metadata fields (<code class="literal">id</code>, <code class="literal">routing</code>, <code class="literal">index</code> etc) can be accessed
(and set) via a <code class="literal">meta</code> attribute or directly using the underscored
variant:</p>
<div class="pre_wrapper lang-python">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-python">post = Post(meta={'id': 42})

# prints 42
print(post.meta.id)

# override default index
post.meta.index = 'my-blog'</pre>
</div>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p>Having all metadata accessible through <code class="literal">meta</code> means that this name is
reserved and you shouldn&#8217;t have a field called <code class="literal">meta</code> on your document.
If you, however, need it you can still access the data using the get
item (as opposed to attribute) syntax: <code class="literal">post['meta']</code>.</p>
</div>
</div>
<p>To retrieve an existing document use the <code class="literal">get</code> class method:</p>
<div class="pre_wrapper lang-python">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-python"># retrieve the document
first = Post.get(id=42)
# now we can call methods, change fields, ...
first.add_comment('me', 'This is nice!')
# and save the changes into the cluster again
first.save()</pre>
</div>
<p>The
<a href="/guide/en/elasticsearch/reference/current/docs-update.html" class="ulink" target="_top">Update
API</a> can also be used via the <code class="literal">update</code> method. By default any keyword
arguments, beyond the parameters of the API, will be considered fields
with new values. Those fields will be updated on the local copy of the
document and then sent over as partial document to be updated:</p>
<div class="pre_wrapper lang-python">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-python"># retrieve the document
first = Post.get(id=42)
# you can update just individual fields which will call the update API
# and also update the document in place
first.update(published=True, published_by='me')</pre>
</div>
<p>In case you wish to use a <code class="literal">painless</code> script to perform the update you
can pass in the script string as <code class="literal">script</code> or the <code class="literal">id</code> of a
<a href="/guide/en/elasticsearch/reference/current/modules-scripting-using.html#script-stored-scripts" class="ulink" target="_top">stored script</a>
via <code class="literal">script_id</code>. All additional keyword arguments to the
<code class="literal">update</code> method will then be passed in as parameters of the script. The
document will not be updated in place.</p>
<div class="pre_wrapper lang-python">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-python"># retrieve the document
first = Post.get(id=42)
# we execute a script in elasticsearch with additional kwargs being passed
# as params into the script
first.update(script='ctx._source.category.add(params.new_category)',
             new_category='testing')</pre>
</div>
<p>If the document is not found in elasticsearch an exception
(<code class="literal">elasticsearch.NotFoundError</code>) will be raised. If you wish to return
<code class="literal">None</code> instead just pass in <code class="literal">ignore=404</code> to suppress the exception:</p>
<div class="pre_wrapper lang-python">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-python">p = Post.get(id='not-in-es', ignore=404)
p is None</pre>
</div>
<p>When you wish to retrieve multiple documents at the same time by their
<code class="literal">id</code> you can use the <code class="literal">mget</code> method:</p>
<div class="pre_wrapper lang-python">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-python">posts = Post.mget([42, 47, 256])</pre>
</div>
<p><code class="literal">mget</code> will, by default, raise a <code class="literal">NotFoundError</code> if any of the documents
wasn&#8217;t found and <code class="literal">RequestError</code> if any of the document had resulted in
error. You can control this behavior by setting parameters:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
<code class="literal">raise_on_error</code>:
If <code class="literal">True</code> (default) then any error will cause an exception to be
raised. Otherwise all documents containing errors will be treated as
missing.
</li>
<li class="listitem">
<code class="literal">missing</code>:
Can have three possible values: <code class="literal">'none'</code> (default), <code class="literal">'raise'</code> and
<code class="literal">'skip'</code>. If a document is missing or errored it will either be
replaced with <code class="literal">None</code>, an exception will be raised or the document will
be skipped in the output list entirely.
</li>
</ul>
</div>
<p>The index associated with the <code class="literal">Document</code> is accessible via the
<code class="literal">_index</code> class property which gives you access to the <code class="literal">index</code> class.</p>
<p>The <code class="literal">_index</code> attribute is also home to the <code class="literal">load_mappings</code>
method which will update the mapping on the <code class="literal">Index</code> from elasticsearch.
This is very useful if you use dynamic mappings and want the class to be
aware of those fields (for example if you wish the <code class="literal">Date</code> fields to be
properly (de)serialized):</p>
<div class="pre_wrapper lang-python">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-python">Post._index.load_mappings()</pre>
</div>
<p>To delete a document just call its <code class="literal">delete</code> method:</p>
<div class="pre_wrapper lang-python">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-python">first = Post.get(id=42)
first.delete()</pre>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<div class="position-relative"><h5 class="title"><a id="_analysis"></a>Analysis</h5><a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch-py/edit/8.19/docs/guide/dsl/persistence.asciidoc">edit</a></div>
</div></div></div>
<p>To specify <code class="literal">analyzer</code> values for <code class="literal">Text</code> fields you can just use the name
of the analyzer (as a string) and either rely on the analyzer being
defined (like built-in analyzers) or define the analyzer yourself
manually.</p>
<p>Alternatively you can create your own analyzer and have the persistence
layer handle its creation, from our example earlier:</p>
<div class="pre_wrapper lang-python">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-python">from elasticsearch.dsl import analyzer, tokenizer

my_analyzer = analyzer('my_analyzer',
    tokenizer=tokenizer('trigram', 'nGram', min_gram=3, max_gram=3),
    filter=['lowercase']
)</pre>
</div>
<p>Each analysis object needs to have a name (<code class="literal">my_analyzer</code> and
<code class="literal">trigram</code> in our example) and tokenizers, token filters and char filters
also need to specify type (<code class="literal">nGram</code> in our example).</p>
<p>Once you have an instance of a custom <code class="literal">analyzer</code> you can also call the
<a href="/guide/en/elasticsearch/reference/current/indices-analyze.html" class="ulink" target="_top">analyze
API</a> on it by using the <code class="literal">simulate</code> method:</p>
<div class="pre_wrapper lang-python">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-python">response = my_analyzer.simulate('Hello World!')

# ['hel', 'ell', 'llo', 'lo ', 'o w', ' wo', 'wor', 'orl', 'rld', 'ld!']
tokens = [t.token for t in response.tokens]</pre>
</div>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p>When creating a mapping which relies on a custom analyzer the index must
either not exist or be closed. To create multiple <code class="literal">Document</code>-defined
mappings you can use the <code class="literal">index</code> object.</p>
</div>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<div class="position-relative"><h5 class="title"><a id="_search_2"></a>Search</h5><a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch-py/edit/8.19/docs/guide/dsl/persistence.asciidoc">edit</a></div>
</div></div></div>
<p>To search for this document type, use the <code class="literal">search</code> class method:</p>
<div class="pre_wrapper lang-python">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-python"># by calling .search we get back a standard Search object
s = Post.search()
# the search is already limited to the index and doc_type of our document
s = s.filter('term', published=True).query('match', title='first')


results = s.execute()

# when you execute the search the results are wrapped in your document class (Post)
for post in results:
    print(post.meta.score, post.title)</pre>
</div>
<p>Alternatively you can just take a <code class="literal">Search</code> object and restrict it to
return our document type, wrapped in correct class:</p>
<div class="pre_wrapper lang-python">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-python">s = Search()
s = s.doc_type(Post)</pre>
</div>
<p>You can also combine document classes with standard doc types (just
strings), which will be treated as before. You can also pass in multiple
<code class="literal">Document</code> subclasses and each document in the response will be wrapped
in it&#8217;s class.</p>
<p>If you want to run suggestions, just use the <code class="literal">suggest</code> method on the
<code class="literal">Search</code> object:</p>
<div class="pre_wrapper lang-python">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-python">s = Post.search()
s = s.suggest('title_suggestions', 'pyth', completion={'field': 'title_suggest'})

response = s.execute()

for result in response.suggest.title_suggestions:
    print('Suggestions for %s:' % result.text)
    for option in result.options:
        print('  %s (%r)' % (option.text, option.payload))</pre>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<div class="position-relative"><h5 class="title"><a id="_class_meta_options"></a><code class="literal">class Meta</code> options</h5><a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch-py/edit/8.19/docs/guide/dsl/persistence.asciidoc">edit</a></div>
</div></div></div>
<p>In the <code class="literal">Meta</code> class inside your document definition you can define
various metadata for your document:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
<code class="literal">mapping</code>:
optional instance of <code class="literal">Mapping</code> class to use as base for the mappings
created from the fields on the document class itself.
</li>
</ul>
</div>
<p>Any attributes on the <code class="literal">Meta</code> class that are instance of <code class="literal">MetaField</code> will
be used to control the mapping of the meta fields (<code class="literal">_all</code>, <code class="literal">dynamic</code>
etc). Just name the parameter (without the leading underscore) as the
field you wish to map and pass any parameters to the <code class="literal">MetaField</code> class:</p>
<div class="pre_wrapper lang-python">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-python">class Post(Document):
    title = Text()

    class Meta:
        all = MetaField(enabled=False)
        dynamic = MetaField('strict')</pre>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<div class="position-relative"><h5 class="title"><a id="_class_index_options"></a><code class="literal">class Index</code> options</h5><a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch-py/edit/8.19/docs/guide/dsl/persistence.asciidoc">edit</a></div>
</div></div></div>
<p>This section of the <code class="literal">Document</code> definition can contain any information
about the index, its name, settings and other attributes:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
<code class="literal">name</code>:
name of the index to use, if it contains a wildcard (<code class="literal">*</code>) then it
cannot be used for any write operations and an <code class="literal">index</code> kwarg will have
to be passed explicitly when calling methods like <code class="literal">.save()</code>.
</li>
<li class="listitem">
<code class="literal">using</code>:
default connection alias to use, defaults to <code class="literal">'default'</code>
</li>
<li class="listitem">
<code class="literal">settings</code>:
dictionary containing any settings for the <code class="literal">Index</code> object like
<code class="literal">number_of_shards</code>.
</li>
<li class="listitem">
<code class="literal">analyzers</code>:
additional list of analyzers that should be defined on an index (see
<code class="literal">analysis</code> for details).
</li>
<li class="listitem">
<code class="literal">aliases</code>:
dictionary with any aliases definitions
</li>
</ul>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<div class="position-relative"><h5 class="title"><a id="_document_inheritance"></a>Document Inheritance</h5><a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch-py/edit/8.19/docs/guide/dsl/persistence.asciidoc">edit</a></div>
</div></div></div>
<p>You can use standard Python inheritance to extend models, this can be
useful in a few scenarios. For example if you want to have a
<code class="literal">BaseDocument</code> defining some common fields that several different
<code class="literal">Document</code> classes should share:</p>
<div class="pre_wrapper lang-python">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-python">class User(InnerDoc):
    username = Text(fields={'keyword': Keyword()})
    email = Text()

class BaseDocument(Document):
    created_by = Object(User)
    created_date = Date()
    last_updated = Date()

    def save(**kwargs):
        if not self.created_date:
            self.created_date = datetime.now()
        self.last_updated = datetime.now()
        return super(BaseDocument, self).save(**kwargs)

class BlogPost(BaseDocument):
    class Index:
        name = 'blog'</pre>
</div>
<p>Another use case would be using the
<a href="/guide/en/elasticsearch/reference/current/parent-join.html" class="ulink" target="_top">join
type</a> to have multiple different entities in a single index. You can see
an
<a href="https://github.com/elastic/elasticsearch-py/blob/master/examples/dsl/parent_child.py" class="ulink" target="_top">example</a>
of this approach. Note that in this case, if the subclasses don&#8217;t define
their own <span class="title-ref">Index</span> classes, the mappings are merged and
shared between all the subclasses.</p>
</div>

</div>

<div class="section">
<div class="titlepage"><div><div>
<div class="position-relative"><h4 class="title"><a id="_index"></a>Index</h4><a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch-py/edit/8.19/docs/guide/dsl/persistence.asciidoc">edit</a></div>
</div></div></div>
<p>In typical scenario using <code class="literal">class Index</code> on a <code class="literal">Document</code> class is
sufficient to perform any action. In a few cases though it can be useful
to manipulate an <code class="literal">Index</code> object directly.</p>
<p><code class="literal">Index</code> is a class responsible for holding all the metadata related to
an index in elasticsearch - mappings and settings. It is most useful
when defining your mappings since it allows for easy creation of
multiple mappings at the same time. This is especially useful when
setting up your elasticsearch objects in a migration:</p>
<div class="pre_wrapper lang-python">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-python">from elasticsearch.dsl import Index, Document, Text, analyzer

blogs = Index('blogs')

# define custom settings
blogs.settings(
    number_of_shards=1,
    number_of_replicas=0
)

# define aliases
blogs.aliases(
    old_blogs={}
)

# register a document with the index
blogs.document(Post)

# can also be used as class decorator when defining the Document
@blogs.document
class Post(Document):
    title = Text()

# You can attach custom analyzers to the index

html_strip = analyzer('html_strip',
    tokenizer="standard",
    filter=["standard", "lowercase", "stop", "snowball"],
    char_filter=["html_strip"]
)

blogs.analyzer(html_strip)

# delete the index, ignore if it doesn't exist
blogs.delete(ignore=404)

# create the index in elasticsearch
blogs.create()</pre>
</div>
<p>You can also set up a template for your indices and use the <code class="literal">clone</code>
method to create specific copies:</p>
<div class="pre_wrapper lang-python">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-python">blogs = Index('blogs', using='production')
blogs.settings(number_of_shards=2)
blogs.document(Post)

# create a copy of the index with different name
company_blogs = blogs.clone('company-blogs')

# create a different copy on different cluster
dev_blogs = blogs.clone('blogs', using='dev')
# and change its settings
dev_blogs.setting(number_of_shards=1)</pre>
</div>
<div class="section">
<div class="titlepage"><div><div>
<div class="position-relative"><h5 class="title"><a id="index-template"></a>IndexTemplate</h5><a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch-py/edit/8.19/docs/guide/dsl/persistence.asciidoc">edit</a></div>
</div></div></div>
<p>The DSL module also exposes an option to manage
<a href="/guide/en/elasticsearch/reference/current/indices-templates.html" class="ulink" target="_top">index
templates</a> in elasticsearch using the <code class="literal">IndexTemplate</code> class which has
very similar API to <code class="literal">Index</code>.</p>
<p>Once an index template is saved in elasticsearch it&#8217;s contents will be
automatically applied to new indices (existing indices are completely
unaffected by templates) that match the template pattern (any index
starting with <code class="literal">blogs-</code> in our example), even if the index is created
automatically upon indexing a document into that index.</p>
<p>Potential workflow for a set of time based indices governed by a single
template:</p>
<div class="pre_wrapper lang-python">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-python">from datetime import datetime

from elasticsearch.dsl import Document, Date, Text


class Log(Document):
    content = Text()
    timestamp = Date()

    class Index:
        name = "logs-*"
        settings = {
          "number_of_shards": 2
        }

    def save(self, **kwargs):
        # assign now if no timestamp given
        if not self.timestamp:
            self.timestamp = datetime.now()

        # override the index to go to the proper timeslot
        kwargs['index'] = self.timestamp.strftime('logs-%Y%m%d')
        return super().save(**kwargs)

# once, as part of application setup, during deploy/migrations:
logs = Log._index.as_template('logs', order=0)
logs.save()

# to perform search across all logs:
search = Log.search()</pre>
</div>
</div>

</div>

</div>

<div class="section">
<div class="titlepage"><div><div>
<div class="position-relative"><h3 class="title"><a id="faceted_search"></a>Faceted Search</h3><a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch-py/edit/8.19/docs/guide/dsl/faceted_search.asciidoc">edit</a></div>
</div></div></div>
<p>The library comes with a simple abstraction aimed at helping you develop
faceted navigation for your data.</p>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p>This API is experimental and will be subject to change. Any feedback is
welcome.</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div>
<div class="position-relative"><h4 class="title"><a id="_configuration_2"></a>Configuration</h4><a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch-py/edit/8.19/docs/guide/dsl/faceted_search.asciidoc">edit</a></div>
</div></div></div>
<p>You can provide several configuration options (as class attributes) when
declaring a <code class="literal">FacetedSearch</code> subclass:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
<code class="literal">index</code>:
the name of the index (as string) to search through, defaults to
<code class="literal">'_all'</code>.
</li>
<li class="listitem">
<code class="literal">doc_types</code>:
list of <code class="literal">Document</code> subclasses or strings to be used, defaults to
<code class="literal">['_all']</code>.
</li>
<li class="listitem">
<code class="literal">fields</code>:
list of fields on the document type to search through. The list will
be passes to <code class="literal">MultiMatch</code> query so can contain boost values
(<code class="literal">'title^5'</code>), defaults to <code class="literal">['*']</code>.
</li>
<li class="listitem">
<code class="literal">facets</code>:
dictionary of facets to display/filter on. The key is the name
displayed and values should be instances of any <code class="literal">Facet</code> subclass, for
example: <code class="literal">{'tags': TermsFacet(field='tags')}</code>
</li>
</ul>
</div>
<div class="section">
<div class="titlepage"><div><div>
<div class="position-relative"><h5 class="title"><a id="_facets"></a>Facets</h5><a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch-py/edit/8.19/docs/guide/dsl/faceted_search.asciidoc">edit</a></div>
</div></div></div>
<p>There are several different facets available:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
<code class="literal">TermsFacet</code>:
provides an option to split documents into groups based on a value of
a field, for example <code class="literal">TermsFacet(field='category')</code>
</li>
<li class="listitem">
<code class="literal">DateHistogramFacet</code>:
split documents into time intervals, example:
<code class="literal">DateHistogramFacet(field="published_date", calendar_interval="day")</code>
</li>
<li class="listitem">
<code class="literal">HistogramFacet</code>:
similar to <code class="literal">DateHistogramFacet</code> but for numerical values:
<code class="literal">HistogramFacet(field="rating", interval=2)</code>
</li>
<li class="listitem">
<code class="literal">RangeFacet</code>:
allows you to define your own ranges for a numerical fields:
<code class="literal">RangeFacet(field="comment_count", ranges=[("few", (None, 2)), ("lots", (2, None))])</code>
</li>
<li class="listitem">
<code class="literal">NestedFacet</code>:
is just a simple facet that wraps another to provide access to nested
documents:
<code class="literal">NestedFacet('variants', TermsFacet(field='variants.color'))</code>
</li>
</ul>
</div>
<p>By default facet results will only calculate document count, if you wish
for a different metric you can pass in any single value metric
aggregation as the <code class="literal">metric</code> kwarg
(<code class="literal">TermsFacet(field='tags', metric=A('max', field=timestamp))</code>). When
specifying <code class="literal">metric</code> the results will be, by default, sorted in
descending order by that metric. To change it to ascending specify
<code class="literal">metric_sort="asc"</code> and to just sort by document count use
<code class="literal">metric_sort=False</code>.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<div class="position-relative"><h5 class="title"><a id="_advanced"></a>Advanced</h5><a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch-py/edit/8.19/docs/guide/dsl/faceted_search.asciidoc">edit</a></div>
</div></div></div>
<p>If you require any custom behavior or modifications simply override one
or more of the methods responsible for the class' functions:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
<code class="literal">search(self)</code>:
is responsible for constructing the <code class="literal">Search</code> object used. Override
this if you want to customize the search object (for example by adding
a global filter for published articles only).
</li>
<li class="listitem">
<code class="literal">query(self, search)</code>:
adds the query position of the search (if search input specified), by
default using <code class="literal">MultiField</code> query. Override this if you want to modify
the query type used.
</li>
<li class="listitem">
<code class="literal">highlight(self, search)</code>:
defines the highlighting on the <code class="literal">Search</code> object and returns a new one.
Default behavior is to highlight on all fields specified for search.
</li>
</ul>
</div>
</div>

</div>

<div class="section">
<div class="titlepage"><div><div>
<div class="position-relative"><h4 class="title"><a id="_usage"></a>Usage</h4><a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch-py/edit/8.19/docs/guide/dsl/faceted_search.asciidoc">edit</a></div>
</div></div></div>
<p>The custom subclass can be instantiated empty to provide an empty search
(matching everything) or with <code class="literal">query</code>, <code class="literal">filters</code> and <code class="literal">sort</code>.</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
<code class="literal">query</code>:
is used to pass in the text of the query to be performed. If <code class="literal">None</code> is
passed in (default) a <code class="literal">MatchAll</code> query will be used. For example
<code class="literal">'python web'</code>
</li>
<li class="listitem">
<code class="literal">filters</code>:
is a dictionary containing all the facet filters that you wish to
apply. Use the name of the facet (from <code class="literal">.facets</code> attribute) as the key
and one of the possible values as value. For example
<code class="literal">{'tags': 'python'}</code>.
</li>
<li class="listitem">
<code class="literal">sort</code>:
is a tuple or list of fields on which the results should be sorted.
The format of the individual fields are to be the same as those passed
to <code class="literal">~elasticsearch.dsl.Search.sort</code>.
</li>
</ul>
</div>
<div class="section">
<div class="titlepage"><div><div>
<div class="position-relative"><h5 class="title"><a id="_response_2"></a>Response</h5><a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch-py/edit/8.19/docs/guide/dsl/faceted_search.asciidoc">edit</a></div>
</div></div></div>
<p>the response returned from the <code class="literal">FacetedSearch</code> object (by calling
<code class="literal">.execute()</code>) is a subclass of the standard <code class="literal">Response</code> class that adds a
property called <code class="literal">facets</code> which contains a dictionary with lists of
buckets -each represented by a tuple of key, document count and a flag
indicating whether this value has been filtered on.</p>
</div>

</div>

<div class="section">
<div class="titlepage"><div><div>
<div class="position-relative"><h4 class="title"><a id="_example"></a>Example</h4><a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch-py/edit/8.19/docs/guide/dsl/faceted_search.asciidoc">edit</a></div>
</div></div></div>
<div class="pre_wrapper lang-python">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-python">from datetime import date

from elasticsearch.dsl import FacetedSearch, TermsFacet, DateHistogramFacet

class BlogSearch(FacetedSearch):
    doc_types = [Article, ]
    # fields that should be searched
    fields = ['tags', 'title', 'body']

    facets = {
        # use bucket aggregations to define facets
        'tags': TermsFacet(field='tags'),
        'publishing_frequency': DateHistogramFacet(field='published_from', interval='month')
    }

    def search(self):
        # override methods to add custom pieces
        s = super().search()
        return s.filter('range', publish_from={'lte': 'now/h'})

bs = BlogSearch('python web', {'publishing_frequency': date(2015, 6)})
response = bs.execute()

# access hits and other attributes as usual
total = response.hits.total
print('total hits', total.relation, total.value)
for hit in response:
    print(hit.meta.score, hit.title)

for (tag, count, selected) in response.facets.tags:
    print(tag, ' (SELECTED):' if selected else ':', count)

for (month, count, selected) in response.facets.publishing_frequency:
    print(month.strftime('%B %Y'), ' (SELECTED):' if selected else ':', count)</pre>
</div>
</div>

</div>

<div class="section">
<div class="titlepage"><div><div>
<div class="position-relative"><h3 class="title"><a id="update_by_query"></a>Update By Query</h3><a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch-py/edit/8.19/docs/guide/dsl/update_by_query.asciidoc">edit</a></div>
</div></div></div>
<div class="section">
<div class="titlepage"><div><div>
<div class="position-relative"><h4 class="title"><a id="_the_update_by_query_object"></a>The <code class="literal">Update By Query</code> object</h4><a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch-py/edit/8.19/docs/guide/dsl/update_by_query.asciidoc">edit</a></div>
</div></div></div>
<p>The <code class="literal">Update By Query</code> object enables the use of the
<a href="/guide/en/elasticsearch/reference/current/docs-update-by-query.html" class="ulink" target="_top">_update_by_query</a>
endpoint to perform an update on documents that match a search query.</p>
<p>The object is implemented as a modification of the <code class="literal">Search</code> object,
containing a subset of its query methods, as well as a script method,
which is used to make updates.</p>
<p>The <code class="literal">Update By Query</code> object implements the following <code class="literal">Search</code> query
types:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
queries
</li>
<li class="listitem">
filters
</li>
<li class="listitem">
excludes
</li>
</ul>
</div>
<p>For more information on queries, see the <code class="literal">search_dsl</code> chapter.</p>
<p>Like the <code class="literal">Search</code> object, the API is designed to be chainable. This
means that the <code class="literal">Update By Query</code> object is immutable: all changes to the
object will result in a shallow copy being created which contains the
changes. This means you can safely pass the <code class="literal">Update By Query</code> object to
foreign code without fear of it modifying your objects as long as it
sticks to the <code class="literal">Update By Query</code> object APIs.</p>
<p>You can define your client in a number of ways, but the preferred method
is to use a global configuration. For more information on defining a
client, see the <code class="literal">configuration</code> chapter.</p>
<p>Once your client is defined, you can instantiate a copy of the
<code class="literal">Update By Query</code> object as seen below:</p>
<div class="pre_wrapper lang-python">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-python">from elasticsearch.dsl import UpdateByQuery

ubq = UpdateByQuery().using(client)
# or
ubq = UpdateByQuery(using=client)</pre>
</div>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p>All methods return a <em>copy</em> of the object, making it safe to pass to
outside code.</p>
</div>
</div>
<p>The API is chainable, allowing you to combine multiple method calls in
one statement:</p>
<div class="pre_wrapper lang-python">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-python">ubq = UpdateByQuery().using(client).query("match", title="python")</pre>
</div>
<p>To send the request to Elasticsearch:</p>
<div class="pre_wrapper lang-python">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-python">response = ubq.execute()</pre>
</div>
<p>It should be noted, that there are limits to the chaining using the
script method: calling script multiple times will overwrite the previous
value. That is, only a single script can be sent with a call. An attempt
to use two scripts will result in only the second script being stored.</p>
<p>Given the below example:</p>
<div class="pre_wrapper lang-python">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-python">ubq = UpdateByQuery() \
    .using(client) \
    .script(source="ctx._source.likes++") \
    .script(source="ctx._source.likes+=2")</pre>
</div>
<p>This means that the stored script by this client will be
<code class="literal">'source': 'ctx._source.likes{plus}=2'</code> and the previous call will
not be stored.</p>
<p>For debugging purposes you can serialize the <code class="literal">Update By Query</code> object to
a <code class="literal">dict</code> explicitly:</p>
<div class="pre_wrapper lang-python">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-python">print(ubq.to_dict())</pre>
</div>
<p>Also, to use variables in script see below example:</p>
<div class="pre_wrapper lang-python">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-python">ubq.script(
  source="ctx._source.messages.removeIf(x -&gt; x.somefield == params.some_var)",
  params={
    'some_var': 'some_string_val'
  }
)</pre>
</div>
<div class="section">
<div class="titlepage"><div><div>
<div class="position-relative"><h5 class="title"><a id="_serialization_and_deserialization_2"></a>Serialization and Deserialization</h5><a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch-py/edit/8.19/docs/guide/dsl/update_by_query.asciidoc">edit</a></div>
</div></div></div>
<p>The search object can be serialized into a dictionary by using the
<code class="literal">.to_dict()</code> method.</p>
<p>You can also create a <code class="literal">Update By Query</code> object from a <code class="literal">dict</code> using the
<code class="literal">from_dict</code> class method. This will create a new <code class="literal">Update By Query</code>
object and populate it using the data from the dict:</p>
<div class="pre_wrapper lang-python">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-python">ubq = UpdateByQuery.from_dict({"query": {"match": {"title": "python"}}})</pre>
</div>
<p>If you wish to modify an existing <code class="literal">Update By Query</code> object, overriding
it&#8217;s properties, instead use the <code class="literal">update_from_dict</code> method that
alters an instance <span class="strong strong"><strong>in-place</strong></span>:</p>
<div class="pre_wrapper lang-python">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-python">ubq = UpdateByQuery(index='i')
ubq.update_from_dict({"query": {"match": {"title": "python"}}, "size": 42})</pre>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<div class="position-relative"><h5 class="title"><a id="_extra_properties_and_parameters_2"></a>Extra properties and parameters</h5><a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch-py/edit/8.19/docs/guide/dsl/update_by_query.asciidoc">edit</a></div>
</div></div></div>
<p>To set extra properties of the search request, use the <code class="literal">.extra()</code>
method. This can be used to define keys in the body that cannot be
defined via a specific API method like <code class="literal">explain</code>:</p>
<div class="pre_wrapper lang-python">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-python">ubq = ubq.extra(explain=True)</pre>
</div>
<p>To set query parameters, use the <code class="literal">.params()</code> method:</p>
<div class="pre_wrapper lang-python">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-python">ubq = ubq.params(routing="42")</pre>
</div>
</div>

</div>

<div class="section">
<div class="titlepage"><div><div>
<div class="position-relative"><h4 class="title"><a id="_response_3"></a>Response</h4><a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch-py/edit/8.19/docs/guide/dsl/update_by_query.asciidoc">edit</a></div>
</div></div></div>
<p>You can execute your search by calling the <code class="literal">.execute()</code> method that will
return a <code class="literal">Response</code> object. The <code class="literal">Response</code> object allows you access to
any key from the response dictionary via attribute access. It also
provides some convenient helpers:</p>
<div class="pre_wrapper lang-python">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-python">response = ubq.execute()

print(response.success())
# True

print(response.took)
# 12</pre>
</div>
<p>If you want to inspect the contents of the <code class="literal">response</code> objects, just use
its <code class="literal">to_dict</code> method to get access to the raw data for pretty
printing.</p>
</div>

</div>

<div class="section">
<div class="titlepage"><div><div>
<div class="position-relative"><h3 class="title"><a id="asyncio"></a>Using asyncio with Elasticsearch Python DSL</h3><a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch-py/edit/8.19/docs/guide/dsl/asyncio.asciidoc">edit</a></div>
</div></div></div>
<p>The DSL module supports async/await with
<a href="https://docs.python.org/3/library/asyncio.html" class="ulink" target="_top">asyncio</a>. To ensure that
you have all the required dependencies, install the <code class="literal">[async]</code>
extra:</p>
<div class="pre_wrapper lang-bash">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-bash">$ python -m pip install "elasticsearch[async]"</pre>
</div>
<div class="section">
<div class="titlepage"><div><div>
<div class="position-relative"><h4 class="title"><a id="_connections"></a>Connections</h4><a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch-py/edit/8.19/docs/guide/dsl/asyncio.asciidoc">edit</a></div>
</div></div></div>
<p>Use the <code class="literal">async_connections</code> module to manage your asynchronous
connections.</p>
<div class="pre_wrapper lang-python">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-python">from elasticsearch.dsl import async_connections

async_connections.create_connection(hosts=['localhost'], timeout=20)</pre>
</div>
<p>All the options available in the <code class="literal">connections</code> module can be used with
<code class="literal">async_connections</code>.</p>
<div class="section">
<div class="titlepage"><div><div>
<div class="position-relative"><h5 class="title"><a id="_how_to_avoid_unclosed_client_session_connector_warnings_on_exit"></a>How to avoid <em>Unclosed client session / connector</em> warnings on exit</h5><a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch-py/edit/8.19/docs/guide/dsl/asyncio.asciidoc">edit</a></div>
</div></div></div>
<p>These warnings come from the <code class="literal">aiohttp</code> package, which is used internally
by the <code class="literal">AsyncElasticsearch</code> client. They appear often when the
application exits and are caused by HTTP connections that are open when
they are garbage collected. To avoid these warnings, make sure that you
close your connections.</p>
<div class="pre_wrapper lang-python">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-python">es = async_connections.get_connection()
await es.close()</pre>
</div>
</div>

</div>

<div class="section">
<div class="titlepage"><div><div>
<div class="position-relative"><h4 class="title"><a id="_search_dsl"></a>Search DSL</h4><a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch-py/edit/8.19/docs/guide/dsl/asyncio.asciidoc">edit</a></div>
</div></div></div>
<p>Use the <code class="literal">AsyncSearch</code> class to perform asynchronous searches.</p>
<div class="pre_wrapper lang-python">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-python">from elasticsearch.dsl import AsyncSearch

s = AsyncSearch().query("match", title="python")
async for hit in s:
    print(hit.title)</pre>
</div>
<p>Instead of using the <code class="literal">AsyncSearch</code> object as an asynchronous iterator,
you can explicitly call the <code class="literal">execute()</code> method to get a <code class="literal">Response</code>
object.</p>
<div class="pre_wrapper lang-python">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-python">s = AsyncSearch().query("match", title="python")
response = await s.execute()
for hit in response:
    print(hit.title)</pre>
</div>
<p>An <code class="literal">AsyncMultiSearch</code> is available as well.</p>
<div class="pre_wrapper lang-python">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-python">from elasticsearch.dsl import AsyncMultiSearch

ms = AsyncMultiSearch(index='blogs')

ms = ms.add(AsyncSearch().filter('term', tags='python'))
ms = ms.add(AsyncSearch().filter('term', tags='elasticsearch'))

responses = await ms.execute()

for response in responses:
    print("Results for query %r." % response.search.query)
    for hit in response:
        print(hit.title)</pre>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<div class="position-relative"><h4 class="title"><a id="_asynchronous_documents_indexes_and_more"></a>Asynchronous Documents, Indexes, and more</h4><a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch-py/edit/8.19/docs/guide/dsl/asyncio.asciidoc">edit</a></div>
</div></div></div>
<p>The <code class="literal">Document</code>, <code class="literal">Index</code>, <code class="literal">IndexTemplate</code>, <code class="literal">Mapping</code>, <code class="literal">UpdateByQuery</code> and
<code class="literal">FacetedSearch</code> classes all have asynchronous versions that use the same
name with an <code class="literal">Async</code> prefix. These classes expose the same interfaces as
the synchronous versions, but any methods that perform I/O are defined
as coroutines.</p>
<p>Auxiliary classes that do not perform I/O do not have asynchronous
versions. The same classes can be used in synchronous and asynchronous
applications.</p>
<p>When using a custom analyzer in an asynchronous
application, use the <code class="literal">async_simulate()</code> method to invoke the Analyze
API on it.</p>
<p>Consult the <code class="literal">api</code> section for details about each specific method.</p>
</div>

</div>

</div>
</div>
</div><div class="navfooter">
<span class="prev">
<a href="_tutorials.html">« Tutorials</a>
</span>
<span class="next">
<a href="_examples.html">Examples »</a>
</span>
</div>
</body>
</html>
