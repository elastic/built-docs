<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Closing Thoughts | Elasticsearch: The Definitive Guide [1.x] | Elastic</title>
<meta class="elastic" name="content" content="Closing Thoughts | Elasticsearch: The Definitive Guide [1.x]">

<link rel="home" href="index.html" title="Elasticsearch: The Definitive Guide [1.x]"/>
<link rel="up" href="aggregations.html" title="Aggregations"/>
<link rel="prev" href="_preventing_combinatorial_explosions.html" title="Preventing Combinatorial Explosions"/>
<link rel="next" href="geoloc.html" title="Geolocation"/>
<meta class="elastic" name="product_version" content="1.x"/>
<meta class="elastic" name="product_name" content="Elasticsearch"/>
<meta class="elastic" name="website_area" content="documentation"/>
<meta name="DC.type" content="Learn/Docs/Legacy/Elasticsearch/Definitive Guide/1.x"/>
<meta name="DC.subject" content="Elasticsearch"/>
<meta name="DC.identifier" content="1.x"/>
<meta name="robots" content="noindex,nofollow"/>
</head>
<body><div class="page_header">
<p>
  <strong>WARNING</strong>: The 1.x versions of Elasticsearch have passed their
  <a href="https://www.elastic.co/support/eol">EOL dates</a>. If you are running
  a 1.x version, we strongly advise you to upgrade.
</p>
<p>
  This documentation is no longer maintained and may be removed. For the latest
  information, see the <a
  href="https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html">current
  Elasticsearch documentation</a>.
</p>
</div>
<div id="content">
<div class="breadcrumbs">
<span class="breadcrumb-link"><a href="/guide/">Elastic Docs</a></span>
<span class="chevron-right">›</span><span class="breadcrumb-link"><a href="index.html">Elasticsearch: The Definitive Guide [1.x]</a></span>
<span class="chevron-right">›</span><span class="breadcrumb-link"><a href="aggregations.html">Aggregations</a></span>
</div>
<div class="navheader">
<span class="prev">
<a href="_preventing_combinatorial_explosions.html">« Preventing Combinatorial Explosions</a>
</span>
<span class="next">
<a href="geoloc.html">Geolocation »</a>
</span>
</div>
<div class="chapter">
<div class="titlepage"><div><div>
<h2 class="title"><a id="_closing_thoughts"></a>Closing Thoughts<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch-definitive-guide/edit/1.x/300_Aggregations/125_Conclusion.asciidoc">edit</a></h2>
</div></div></div>
<p>This section covered a lot of ground, and a lot of deeply technical issues.
Aggregations bring a power and flexibility to Elasticsearch that is hard to
overstate. The ability to nest buckets and metrics, to quickly approximate
cardinality and percentiles, to find statistical anomalies in your data, all
while operating on near-real-time data and in parallel to full-text search&#8212;&#8203;these are game-changers to many organizations.</p>
<p>It is a feature that, once you start using it, you&#8217;ll find dozens
of other candidate uses.  Real-time reporting and analytics is central to many
 organizations (be it over business intelligence or server logs).</p>
<p>But with great power comes great responsibility, and for Elasticsearch that often
means proper memory stewardship. Memory is often the limiting factor in
Elasticsearch deployments, particularly those that heavily utilize aggregations.
Because aggregation data is loaded to fielddata&#8212;&#8203;and this is an in-memory data
structure&#8212;&#8203;managing efficient memory usage is important.</p>
<p>The management of this memory can take several forms, depending on your
particular use-case:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
At a data level, by making sure you analyze (or <code class="literal">not_analyze</code>) your data appropriately
so that it is memory-friendly
</li>
<li class="listitem">
During indexing, by configuring heavy fields to use disk-based doc values instead
of in-memory fielddata
</li>
<li class="listitem">
At search time, by utilizing approximate aggregations and data filtering
</li>
<li class="listitem">
At a node level, by setting hard memory and dynamic circuit-breaker limits
</li>
<li class="listitem">
At an operations level, by monitoring memory usage and controlling slow garbage-collection cycles, potentially by adding more nodes to the cluster
</li>
</ul>
</div>
<p>Most deployments will use one or more of the preceding methods.  The exact combination
is highly dependent on your particular environment.  Some organizations need
blisteringly fast responses and opt to simply add more nodes.  Other organizations
are limited by budget and choose doc values and approximate aggregations.</p>
<p>Whatever the path you take, it is important to assess the available options and
create both a short- and long-term plan.  Decide how your memory situation exists
today and what (if anything) needs to be done.  Then decide what will happen in
six months or one year as your data grows. What methods will you use to continue
scaling?</p>
<p>It is better to plan out these life cycles of your cluster ahead of time, rather
than panicking at 3 a.m. because your cluster is at 90% heap utilization.</p>
</div>
<div class="navfooter">
<span class="prev">
<a href="_preventing_combinatorial_explosions.html">« Preventing Combinatorial Explosions</a>
</span>
<span class="next">
<a href="geoloc.html">Geolocation »</a>
</span>
</div>
</div>
</body>
</html>
