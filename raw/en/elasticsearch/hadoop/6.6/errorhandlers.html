<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="description" content="Reference documentation of elasticsearch-hadoop">
<title>Error Handlers | Elasticsearch for Apache Hadoop [6.6] | Elastic</title>
<link rel="home" href="index.html" title="Elasticsearch for Apache Hadoop [6.6]"/>
<link rel="up" href="reference.html" title="Elasticsearch for Apache Hadoop"/>
<link rel="prev" href="mapping.html" title="Mapping and Types"/>
<link rel="next" href="metrics.html" title="Hadoop Metrics"/>
<meta name="DC.type" content="Learn/Docs/Elasticsearch/Apache Hadoop/6.6"/>
<meta name="DC.subject" content="Elasticsearch"/>
<meta name="DC.identifier" content="6.6"/>
<meta name="robots" content="noindex,nofollow"/>
</head>
<body><div class="page_header">
<strong>IMPORTANT</strong>: No additional bug fixes or documentation updates
will be released for this version. For the latest information, see the
<a href="../current/index.html">current release documentation</a>.
</div>
<div id="content">
<div class="breadcrumbs">
<span class="breadcrumb-link"><a href="index.html">Elasticsearch for Apache Hadoop [6.6]</a></span>
»
<span class="breadcrumb-link"><a href="reference.html">Elasticsearch for Apache Hadoop</a></span>
»
<span class="breadcrumb-node">Error Handlers</span>
</div>
<div class="navheader">
<span class="prev">
<a href="mapping.html">« Mapping and Types</a>
</span>
<span class="next">
<a href="metrics.html">Hadoop Metrics »</a>
</span>
</div>
<div class="chapter">
<div class="titlepage"><div><div>
<h2 class="title"><a id="errorhandlers"></a>Error Handlers<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch-hadoop/edit/6.6/docs/src/reference/asciidoc/core/errorhandlers.adoc">edit</a></h2>
</div></div></div>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p>Added in 6.4.</p>
</div>
</div>
<p>Elasticsearch for Apache Hadoop is designed to be a mostly hands off integration. Most of the features are managed through conventions and
configurations and no substantial amount of code is required to get up and running with the connector. When it comes to
exceptions, substantial effort has been put into handling the most common and expected errors from Elasticsearch.
In the case where errors are unexpected or indicative of a real problem, the connector adopts a "fail-fast" approach. We
realize that this approach is not the best for all users, especially those concerned with uptime of their jobs.</p>
<p>In these situations, users can handle unexpected errors by specifying the actions
to take when encountering them. To this end, we have provided a set of APIs and extensions that users can
implement in order to tailor the connector&#8217;s behavior toward encountering failures in the most common locations to their
needs.</p>
<h3><a id="errorhandlers-mechanics"></a>Error Handler Mechanics<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch-hadoop/edit/6.6/docs/src/reference/asciidoc/core/errorhandlers.adoc">edit</a></h3>
<p>Each type of failure that can be handled in elasticsearch-hadoop has its own error handler API tailored to operation being performed.
An error handler is simply a function that is called when an error occurs, and informs elasticsearch-hadoop how to proceed.
Multiple error handlers may be specified for each type of failure. When a failure occurs, each error handler will be
executed in the order that they are specified in the configuration.</p>
<p>An error handler is given information about the performed operation and any details about the error that was
encountered. The handler may then acknowledge and consume the failure telling elasticsearch-hadoop to ignore the error.
Alternatively, the handler may mark the error to be rethrown, potentially ending the job. Error handlers are also given
the option to modify the operation&#8217;s parameters and retry it. Finally, the handler may also "pass" the failure on to the
next handler in the list if it does not know how to handle it.</p>
<p>If every handler in the provided list of handlers chooses to "pass", it is marked as an unhandled
error and the exceptions will be rethrown, potentially ending the job. The connector ships with a few default error
handlers that take care of most use cases, but if you find that you need a more specific error handling strategy, you
can always write your own.</p>
<p>In the following sections, we will detail the different types of error handlers, where they are called, how to configure
them, and how to write your own if you need to.</p>
<div class="section">
<div class="titlepage"><div><div>
<h2 class="title"><a id="errorhandlers-bulk"></a>Bulk Write Error Handlers<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch-hadoop/edit/6.6/docs/src/reference/asciidoc/core/errorhandlers.adoc">edit</a></h2>
</div></div></div>
<p>When writing data, the connector batches up documents into a bulk request before sending them to Elasticsearch. In the response,
Elasticsearch returns a status for each document sent, which may include rejections or failures. A common error encountered
here is a <em>rejection</em> which means that the shard that the document was meant to be written to was too busy to accept
the write. Other failures here might include documents that are refused because they do not conform to the current
index mapping, or conflict with the current version of the document.</p>
<p>Elasticsearch for Apache Hadoop provides an API to handle document level errors from bulk responses. Error handlers for bulk writes are given:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
The raw JSON bulk entry that was tried
</li>
<li class="listitem">
Error message
</li>
<li class="listitem">
HTTP status code for the document
</li>
<li class="listitem">
Number of times that the current document has been sent to Elasticsearch
</li>
</ul>
</div>
<p>There are a few default error handlers provided by the connector:</p>
<h4><a id="errorhandlers-bulk-http"></a>HTTP Retry Handler<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch-hadoop/edit/6.6/docs/src/reference/asciidoc/core/errorhandlers.adoc">edit</a></h4>
<p>Always configured as the first error handler for bulk writes.</p>
<p>This handler checks the failures for common HTTP codes that can be retried. These codes are usually indicators that the
shard the document would be written to is too busy to accept the write, and the document was rejected to shed load.
This handler is always configured to be run first for bulk failures. All handlers that are configured by the user are
placed in order after this one.</p>
<p>While the handler&#8217;s position in the list of error handlers cannot be modified, its behavior can be modified by adjusting
the following configurations:</p>
<div class="variablelist">
<dl class="variablelist">
<dt>
<span class="term">
<code class="literal">es.batch.write.retry.policy</code> (default: simple)
</span>
</dt>
<dd>
Defines the policy for determining which http codes are able to be retried. The default value <code class="literal">simple</code> allows for 429
(Too Many Requests) and 503 (Unavailable) to be retried. Setting the value to <code class="literal">none</code> will allow no status codes to be
retried.
</dd>
<dt>
<span class="term">
<code class="literal">es.batch.write.retry.count</code> (default 3)
</span>
</dt>
<dd>
Number of retries for a given batch in case Elasticsearch is overloaded and data is rejected. Note that only the rejected data
is retried. If there is still data rejected after the retries have been performed, the Hadoop job is cancelled (and
fails). A negative value indicates infinite retries; be careful in setting this value as it can have unwanted side
effects.
</dd>
<dt>
<span class="term">
<code class="literal">es.batch.write.retry.wait</code> (default 10s)
</span>
</dt>
<dd>
Time to wait between batch write retries that are caused by bulk rejections.
</dd>
</dl>
</div>
<h4><a id="errorhandlers-bulk-log"></a>Drop and Log Error Handler<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch-hadoop/edit/6.6/docs/src/reference/asciidoc/core/errorhandlers.adoc">edit</a></h4>
<p>Default Handler Name: <code class="literal">log</code></p>
<p>When this handler is invoked it logs a message containing the JSON bulk entry that failed, the error message, and any previous
handler messages. After logging this message, the handler signals that the error has been acknowledged, thus
consuming/ignoring it.</p>
<p>Available configurations for this handler:</p>
<div class="variablelist">
<dl class="variablelist">
<dt>
<span class="term">
<code class="literal">es.write.rest.error.handler.log.logger.name</code> (required)
</span>
</dt>
<dd>
The string name to use when creating the logger instance to log the errors. This setting is required if this handler is used.
</dd>
<dt>
<span class="term">
<code class="literal">es.write.rest.error.handler.log.logger.class</code> (alternative to logger.name)
</span>
</dt>
<dd>
The class name to use when creating the logger instance to log the errors. This setting can be used instead of the
required setting <code class="literal">es.write.rest.error.handler.log.logger.name</code>.
</dd>
<dt>
<span class="term">
<code class="literal">es.write.rest.error.handler.log.logger.level</code> (default: WARN)
</span>
</dt>
<dd>
The logger level to use when logging the error message. Available options are <code class="literal">FATAL</code>, <code class="literal">ERROR</code>, <code class="literal">WARN</code>, <code class="literal">INFO</code>, <code class="literal">DEBUG</code>, and <code class="literal">TRACE</code>.
</dd>
</dl>
</div>
<h4><a id="errorhandlers-bulk-fail"></a>Abort on Failure Error Handler<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch-hadoop/edit/6.6/docs/src/reference/asciidoc/core/errorhandlers.adoc">edit</a></h4>
<p>Default Handler Name: <code class="literal">fail</code></p>
<p>When this handler is called it rethrows the error given to it and aborts. This handler is always loaded and automatically
placed at the end of the list of error handlers.</p>
<p>There are no configurations for this handler.</p>
<h4><a id="errorhandlers-bulk-es"></a>Elasticsearch Error Handler<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch-hadoop/edit/6.6/docs/src/reference/asciidoc/core/errorhandlers.adoc">edit</a></h4>
<p>Default Handler Name: <code class="literal">es</code></p>
<p>When this handler is invoked it converts the error given into a JSON document and inserts it into an Elasticsearch index.
When this indexing operation is complete, the handler can be configured to signal that the error is handled (default),
or pass the error along to the next handler in the chain. The ES handler serializes error information using its own
mapping of the Elastic Common Schema. This data can accept additional user provided metadata that can assist users in
searching and reporting on failures (see labels and tags settings below).</p>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p>Error handlers are built to execute on a per record/error basis. The Elasticsearch Error Handler does not bulk
insert error information currently. Each error is inserted one at a time in order to ensure each record/error is handled.
This handler may not provide a very high throughput in cases where there are a large number of error events to handle. You
should try to design your jobs so that error handling is a relatively uncommon occurrence.</p>
</div>
</div>
<p>Available configurations for this handler:</p>
<div class="variablelist">
<dl class="variablelist">
<dt>
<span class="term">
<code class="literal">es.write.rest.error.handler.es.client.nodes</code> (default: "localhost" or currently configured nodes)
</span>
</dt>
<dd>
The comma separated string of node addresses to write errors to. It is recommended that this be a different cluster than
the one being written to (in order to avoid write contention).
</dd>
<dt>
<span class="term">
<code class="literal">es.write.rest.error.handler.es.client.port</code> (default: 9200 or currently configured port)
</span>
</dt>
<dd>
The http port to use when connecting to the Elasticsearch nodes.
</dd>
<dt>
<span class="term">
<code class="literal">es.write.rest.error.handler.es.client.resource</code> (required)
</span>
</dt>
<dd>
The index to write error information into. It is highly recommended that this index be just for error information.
Does not support index patterns.
</dd>
<dt>
<span class="term">
<code class="literal">es.write.rest.error.handler.es.client.inherit</code> (default: true)
</span>
</dt>
<dd>
Determines if the settings to create the client used for sending error information should inherit the same client settings
from the currently running job. By default, all client settings in the job configuration are inherited by this client.
</dd>
<dt>
<span class="term">
<code class="literal">es.write.rest.error.handler.es.client.conf.&lt;CONFIGURATION&gt;</code>
</span>
</dt>
<dd>
This configuration prefix is used to set client configuration values in the handler&#8217;s underlying ES client. This accepts
most of the settings documented in <a class="xref" href="configuration.html" title="Configuration"><em>Configuration</em></a>.
</dd>
<dt>
<span class="term">
<code class="literal">es.write.rest.error.handler.es.label.&lt;LABEL&gt;</code> (optional)
</span>
</dt>
<dd>
A user defined label field that is added to each error event created by this handler. This field will be indexed into
the Elasticsearch index provided for this handler. Text data only.
</dd>
<dt>
<span class="term">
<code class="literal">es.write.rest.error.handler.es.tags</code> (optional)
</span>
</dt>
<dd>
The comma separated string of tags to add to each error event created by this handler. This field will be indexed into
the Elasticsearch index provided for this handler. Text data only.
</dd>
<dt>
<span class="term">
<code class="literal">es.write.rest.error.handler.es.return.default</code> (default: HANDLED)
</span>
</dt>
<dd>
The handler result to be returned to the error handling framework when an error is successfully written to Elasticsearch.
Available values are <code class="literal">HANDLED</code>, <code class="literal">PASS</code>, and <code class="literal">ABORT</code>. Default result is <code class="literal">HANDLED</code>.
</dd>
<dt>
<span class="term">
<code class="literal">es.write.rest.error.handler.es.return.default.reason</code> (optional)
</span>
</dt>
<dd>
In the case that the default return value is <code class="literal">PASS</code>, this optional text setting allows a user to specify the reason for
the handler to pass the data along to the next handler in the chain.
</dd>
<dt>
<span class="term">
<code class="literal">es.write.rest.error.handler.es.return.error</code> (default: ABORT)
</span>
</dt>
<dd>
The handler result to be returned to the error handling framework when an error cannot be written to Elasticsearch.
Available values are <code class="literal">HANDLED</code>, <code class="literal">PASS</code>, and <code class="literal">ABORT</code>. Default result is <code class="literal">ABORT</code>.
</dd>
<dt>
<span class="term">
<code class="literal">es.write.rest.error.handler.es.return.error.reason</code> (optional)
</span>
</dt>
<dd>
In the case that the error return value is <code class="literal">PASS</code>, this optional text setting allows a user to specify the reason for the
handler to pass the data along to the next handler in the chain.
</dd>
</dl>
</div>
<h3><a id="errorhandlers-bulk-use"></a>Using Bulk Error Handlers<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch-hadoop/edit/6.6/docs/src/reference/asciidoc/core/errorhandlers.adoc">edit</a></h3>
<p>To configure bulk error handlers, you must specify the handlers in order with the following properties.</p>
<div class="variablelist">
<dl class="variablelist">
<dt>
<span class="term">
Setting <code class="literal">es.write.rest.error.handlers</code>
</span>
</dt>
<dd>
Lists the names of the error handlers to use for bulk write error handling, and the order that they should be called on.
Each default handler can be referenced by their handler name as the connector knows how to load them. Any handlers
provided from users or third party code will need to have their handler names defined with the <code class="literal">es.write.rest.error.handler.</code>
prefix.
</dd>
</dl>
</div>
<p>For bulk write failures, the HTTP Retry built-in handler is always placed as the first error handler. Additionally, the Abort on
Failure built-in handler is always placed as the last error handler to catch any unhandled errors. These two error handlers alone
form the default bulk write error handling behavior for elasticsearch-hadoop, which matches the behavior from previous versions.</p>
<div class="olist orderedlist">
<ol class="orderedlist">
<li class="listitem">
HTTP Retry Built-In Handler: Retries benign bulk rejections and failures from Elasticsearch and passes any other error down the line
</li>
<li class="listitem">
Any configured user handlers will go here.
</li>
<li class="listitem">
Abort on Failure Built-In Handler: Rethrows the any errors it encounters
</li>
</ol>
</div>
<p>This behavior is modified by inserting handlers into the chain by using the handlers property. Let&#8217;s say that we want
to log ALL errors and ignore them.</p>
<div class="pre_wrapper lang-ini">
<pre class="programlisting prettyprint lang-ini">es.write.rest.error.handlers = log <a id="CO100-1"></a><i class="conum" data-value="1"></i></pre>
</div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO100-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>Specifying the default Drop and Log handler</p>
</td>
</tr>
</table>
</div>
<p>With the above configuration, the handler list now looks like the following:</p>
<div class="olist orderedlist">
<ol class="orderedlist">
<li class="listitem">
HTTP Retry Handler
</li>
<li class="listitem">
Drop and Log Handler
</li>
<li class="listitem">
Abort on Failure Handler
</li>
</ol>
</div>
<p>As described above, the built-in <code class="literal">log</code> error handler has a required setting: What to use for the logger name. The logger
used will respect whatever logging configuration you have in place, and thus needs a name for the logger to use:</p>
<div class="pre_wrapper lang-ini">
<pre class="programlisting prettyprint lang-ini">es.write.rest.error.handlers = log <a id="CO101-1"></a><i class="conum" data-value="1"></i>
es.write.rest.error.handler.log.logger.name = BulkErrors <a id="CO101-2"></a><i class="conum" data-value="2"></i></pre>
</div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO101-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>Specifying the default Drop and Log built-in handler</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO101-2"><i class="conum" data-value="2"></i></a></p>
</td>
<td align="left" valign="top">
<p>The Drop and Log built-in handler will log all errors to the <code class="literal">BulkErrors</code> logger</p>
</td>
</tr>
</table>
</div>
<p>At this point, the Abort on Failure built-in handler is effectively ignored since the Drop and Log built-in handler will
always mark an error as consumed. This practice can prove to be hazardous, as potentially important errors may simply be
ignored. In many cases, it is preferable for users to write their own error handler to handle expected exceptions.</p>
<h4><a id="errorhandlers-bulk-user-handlers"></a>Writing Your Own Bulk Error Handlers<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch-hadoop/edit/6.6/docs/src/reference/asciidoc/core/errorhandlers.adoc">edit</a></h4>
<p>Let&#8217;s say that you are streaming sensitive transaction data to Elasticsearch. In this scenario, your data is carefully versioned
and you take advantage of Elasticsearch&#8217;s version system to keep from overwriting newer data with older data. Perhaps your data
is distributed in a way that allows newer data to sneak in to Elasticsearch before some older bits of data. No worries, the
version system will reject the older data and preserve the integrity of the data in Elasticsearch. The problem here is that your
streaming job has failed because conflict errors were returned and the connector was unsure if you were expecting that.</p>
<p>Let&#8217;s write an error handler for this situation:</p>
<div class="pre_wrapper lang-java">
<pre class="programlisting prettyprint lang-java">package org.myproject.myhandlers;

import org.elasticsearch.hadoop.handler.HandlerResult;
import org.elasticsearch.hadoop.rest.bulk.handler.BulkWriteErrorHandler;
import org.elasticsearch.hadoop.rest.bulk.handler.BulkWriteFailure;
import org.elasticsearch.hadoop.rest.bulk.handler.DelayableErrorCollector;

public class IgnoreConflictsHandler extends BulkWriteErrorHandler { <a id="CO102-1"></a><i class="conum" data-value="1"></i>

    private static final Logger LOGGER = ...; <a id="CO102-2"></a><i class="conum" data-value="2"></i>

    @Override
    public HandlerResult onError(BulkWriteFailure entry, DelayableErrorCollector&lt;byte[]&gt; collector) <a id="CO102-3"></a><i class="conum" data-value="3"></i>
    throws Exception
    {
        if (entry.getResponseCode() == 409) { <a id="CO102-4"></a><i class="conum" data-value="4"></i>
            LOGGER.warn("Encountered conflict response. Ignoring old data.");
            return HandlerResult.HANDLED; <a id="CO102-5"></a><i class="conum" data-value="5"></i>
        }
        return collector.pass("Not a conflict response code."); <a id="CO102-6"></a><i class="conum" data-value="6"></i>
    }
}</pre>
</div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO102-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>We create a class and extend the BulkWriteErrorHandler base class</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO102-2"><i class="conum" data-value="2"></i></a></p>
</td>
<td align="left" valign="top">
<p>Create a logger using preferred logging solution</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO102-3"><i class="conum" data-value="3"></i></a></p>
</td>
<td align="left" valign="top">
<p>Override the <code class="literal">onError</code> method which will be invoked with the error details</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO102-4"><i class="conum" data-value="4"></i></a></p>
</td>
<td align="left" valign="top">
<p>Check the response code from the error to see if it is 409 (Confict)</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO102-5"><i class="conum" data-value="5"></i></a></p>
</td>
<td align="left" valign="top">
<p>If it is a conflict, log the error and return <code class="literal">HandlerResult.HANDLED</code> to signal that the error is acknowledged</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO102-6"><i class="conum" data-value="6"></i></a></p>
</td>
<td align="left" valign="top">
<p>If the error is not a conflict we pass it along to the next error handler with the reason we couldn&#8217;t handle it</p>
</td>
</tr>
</table>
</div>
<p>Before we can place this handler in the list of bulk write error handlers, we must register the handler class with a
name in the settings using <code class="literal">es.write.rest.error.handler.[HANDLER-NAME]</code>:</p>
<div class="variablelist">
<dl class="variablelist">
<dt>
<span class="term">
Setting <code class="literal">es.write.rest.error.handler.[HANDLER-NAME]</code>
</span>
</dt>
<dd>
Create a new handler named HANDLER-NAME. The value of this property must be the binary name of the class to
instantiate for this handler.
</dd>
</dl>
</div>
<p>In this case, lets register a handler name for our ignore conflicts handler:</p>
<div class="pre_wrapper lang-ini">
<pre class="programlisting prettyprint lang-ini">es.write.rest.error.handler.ignoreConflict = org.myproject.myhandlers.IgnoreConflictsHandler</pre>
</div>
<p>Now that we have a name for the handler, we can use it in the handler list:</p>
<div class="pre_wrapper lang-ini">
<pre class="programlisting prettyprint lang-ini">es.write.rest.error.handlers = ignoreConflict
es.write.rest.error.handler.ignoreConflict = org.myproject.myhandlers.IgnoreConflictsHandler</pre>
</div>
<p>Now, your ignore conflict error handler will be invoked whenever a bulk failure occurs, and will instruct the connector
that it is ok with ignoring conflict response codes from Elasticsearch.</p>
<h4><a id="errorhandlers-bulk-advanced"></a>Advanced Concepts<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch-hadoop/edit/6.6/docs/src/reference/asciidoc/core/errorhandlers.adoc">edit</a></h4>
<p>What if instead of logging data and dropping it, what if you wanted to persist it somewhere for safe keeping? What if
we wanted to pass properties into our handlers to parameterize their behavior? Lets create a handler that stores error
information in a local file for later analysis.</p>
<div class="pre_wrapper lang-java">
<pre class="programlisting prettyprint lang-java">package org.myproject.myhandlers;

import ...

import org.elasticsearch.hadoop.handler.HandlerResult;
import org.elasticsearch.hadoop.rest.bulk.handler.BulkWriteErrorHandler;
import org.elasticsearch.hadoop.rest.bulk.handler.BulkWriteFailure;
import org.elasticsearch.hadoop.rest.bulk.handler.DelayableErrorCollector;

public class OutputToFileHandler extends BulkWriteErrorHandler { <a id="CO103-1"></a><i class="conum" data-value="1"></i>

    private OutputStream outputStream;   <a id="CO103-2"></a><i class="conum" data-value="2"></i>
    private BufferedWriter writer;

    @Override
    public void init(Properties properties) {   <a id="CO103-3"></a><i class="conum" data-value="3"></i>
        try {
            outputStream = new FileOutputStream(properties.getProperty("filename"));   <a id="CO103-4"></a><i class="conum" data-value="4"></i>
            writer = new BufferedWriter(new OutputStreamWriter(outputStream));
        } catch (FileNotFoundException e) {
            throw new RuntimeException("Could not open file", e);
        }
    }

    @Override
    public HandlerResult onError(BulkWriteFailure entry, DelayableErrorCollector&lt;byte[]&gt; collector)   <a id="CO103-5"></a><i class="conum" data-value="5"></i>
    throws Exception
    {
        writer.write("Code: " + entry.getResponseCode());
        writer.newLine();
        writer.write("Error: " + entry.getException().getMessage());
        writer.newLine();
        for (String message : entry.previousHandlerMessages()) {
            writer.write("Previous Handler: " + message);           <a id="CO103-6"></a><i class="conum" data-value="6"></i>
            writer.newLine();
        }
        writer.write("Attempts: " + entry.getNumberOfAttempts());
        writer.newLine();
        writer.write("Entry: ");
        writer.newLine();
        IOUtils.copy(entry.getEntryContents(), writer);
        writer.newLine();

        return HandlerResult.HANDLED; <a id="CO103-7"></a><i class="conum" data-value="7"></i>
    }

    @Override
    public void close() {   <a id="CO103-8"></a><i class="conum" data-value="8"></i>
        try {
            writer.close();
            outputStream.close();
        } catch (IOException e) {
            throw new RuntimeException("Closing file failed", e);
        }
    }
}</pre>
</div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO103-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>Extend the BulkWriteErrorHandler base class</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO103-2"><i class="conum" data-value="2"></i></a></p>
</td>
<td align="left" valign="top">
<p>Some local state for writing data out to a file</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO103-3"><i class="conum" data-value="3"></i></a></p>
</td>
<td align="left" valign="top">
<p>We override the <code class="literal">init</code> method. Any properties for this handler are passed in here.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO103-4"><i class="conum" data-value="4"></i></a></p>
</td>
<td align="left" valign="top">
<p>We are extracting the file to write to from the properties. We&#8217;ll see how to set this property below.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO103-5"><i class="conum" data-value="5"></i></a></p>
</td>
<td align="left" valign="top">
<p>Overriding the <code class="literal">onError</code> method to define our behavior.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO103-6"><i class="conum" data-value="6"></i></a></p>
</td>
<td align="left" valign="top">
<p>Write out the error information. This highlights all the available data provided by the <code class="literal">BulkWriteFailure</code> object.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO103-7"><i class="conum" data-value="7"></i></a></p>
</td>
<td align="left" valign="top">
<p>Return the <code class="literal">HANDLED</code> result to signal that the error is handled.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO103-8"><i class="conum" data-value="8"></i></a></p>
</td>
<td align="left" valign="top">
<p>Finally, close out any internally allocated resources.</p>
</td>
</tr>
</table>
</div>
<p>Added to this handler are the <code class="literal">init</code> and <code class="literal">close</code> methods. The <code class="literal">init</code> method is called when the handler is first created
at the start of the task and the <code class="literal">close</code> method is called when the task concludes. The <code class="literal">init</code> method accepts a properties
parameter, which contains any handler specific properties set by using <code class="literal">es.write.rest.error.handler.[HANDLER-NAME].[PROPERTY-NAME]</code>.</p>
<div class="variablelist">
<dl class="variablelist">
<dt>
<span class="term">
Setting <code class="literal">es.write.rest.error.handler.[HANDLER-NAME].[PROPERTY-NAME]</code>
</span>
</dt>
<dd>
Used to pass properties into handlers. HANDLER-NAME is the handler to be configured, and PROPERTY-NAME is the property
to set for the handler.
</dd>
</dl>
</div>
<p>In our use case, we will configure the our file logging error handler like so:</p>
<div class="pre_wrapper lang-ini">
<pre class="programlisting prettyprint lang-ini">es.write.rest.error.handler.writeFile = org.myproject.myhandlers.OutputToFileHandler   <a id="CO104-1"></a><i class="conum" data-value="1"></i>
es.write.rest.error.handler.writeFile.filename = /path/to/some/output/file   <a id="CO104-2"></a><i class="conum" data-value="2"></i></pre>
</div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO104-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>We register our new handler with the name <code class="literal">writeFile</code></p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO104-2"><i class="conum" data-value="2"></i></a></p>
</td>
<td align="left" valign="top">
<p>Now we set a property named <code class="literal">filename</code> for the <code class="literal">writeFile</code> handler. In the <code class="literal">init</code> method of the handler, this can be picked up by using <code class="literal">filename</code> as the property key.</p>
</td>
</tr>
</table>
</div>
<p>Now to bring it all together with the previous example (ignoring conflicts):</p>
<div class="pre_wrapper lang-ini">
<pre class="programlisting prettyprint lang-ini">es.write.rest.error.handlers = ignoreConflict,writeFile

es.write.rest.error.handler.ignoreConflict = org.myproject.myhandlers.IgnoreConflictsHandler

es.write.rest.error.handler.writeFile = org.myproject.myhandlers.OutputToFileHandler
es.write.rest.error.handler.writeFile.filename = /path/to/some/output/file</pre>
</div>
<p>You now have a chain of handlers that retries bulk rejections by default (HTTP Retry built-in handler), then ignores
any errors that are conflicts (our own ignore conflicts handler), then ignores any other errors by writing them out to
a file (our own output to file handler).</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h2 class="title"><a id="errorhandlers-serialization"></a>Serialization Error Handlers<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch-hadoop/edit/6.6/docs/src/reference/asciidoc/core/errorhandlers.adoc">edit</a></h2>
</div></div></div>
<p>Before sending data to Elasticsearch, elasticsearch-hadoop must serialize each document into a JSON bulk entry. It is during this
process that the bulk operation is determined, document metadata is extracted, and integration specific data structures
are converted into JSON documents. During this process, inconsistencies with record structure can cause exceptions to be
thrown during the serialization process. These errors often lead to failed tasks and halted processing.</p>
<p>Elasticsearch for Apache Hadoop provides an API to handle serialization errors at the record level. Error handlers for serialization are given:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
The integration specific data structure that was unable to be serialized
</li>
<li class="listitem">
Exception encountered during serialization
</li>
</ul>
</div>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p>Serialization Error Handlers are not yet available for Hive. Elasticsearch for Apache Hadoop uses Hive&#8217;s SerDe constructs to convert data into
bulk entries before being sent to the output format. SerDe objects do not have a cleanup method that is called when the
object ends its lifecycle. Because of this, we do not support serialization error handlers in Hive as they cannot be
closed at the end of the job execution.</p>
</div>
</div>
<p>There are a few default error handlers provided by the connector:</p>
<h4><a id="errorhandlers-serialization-log"></a>Drop and Log Error Handler<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch-hadoop/edit/6.6/docs/src/reference/asciidoc/core/errorhandlers.adoc">edit</a></h4>
<p>Default Handler Name: <code class="literal">log</code></p>
<p>When this handler is invoked it logs a message containing the data structure&#8217;s toString() contents that failed, the
error message, and any previous handler messages. After logging this message, the handler signals that the error has
been acknowledged, thus consuming/ignoring it.</p>
<p>Available configurations for this handler:</p>
<div class="variablelist">
<dl class="variablelist">
<dt>
<span class="term">
<code class="literal">es.write.data.error.handler.log.logger.name</code> (required)
</span>
</dt>
<dd>
The string name to use when creating the logger instance to log the errors. This setting is required if this handler is used.
</dd>
<dt>
<span class="term">
<code class="literal">es.write.data.error.handler.log.logger.class</code> (alternative to logger.name)
</span>
</dt>
<dd>
The class name to use when creating the logger instance to log the errors. This setting can be used instead of the
required setting <code class="literal">es.write.data.error.handler.log.logger.name</code>.
</dd>
<dt>
<span class="term">
<code class="literal">es.write.data.error.handler.log.logger.level</code> (default: WARN)
</span>
</dt>
<dd>
The logger level to use when logging the error message. Available options are <code class="literal">FATAL</code>, <code class="literal">ERROR</code>, <code class="literal">WARN</code>, <code class="literal">INFO</code>, <code class="literal">DEBUG</code>, and <code class="literal">TRACE</code>.
</dd>
</dl>
</div>
<h4><a id="errorhandlers-serialization-fail"></a>Abort on Failure Error Handler<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch-hadoop/edit/6.6/docs/src/reference/asciidoc/core/errorhandlers.adoc">edit</a></h4>
<p>Default Handler Name: <code class="literal">fail</code></p>
<p>When this handler is called it rethrows the error given to it and aborts. This handler is always loaded and automatically
placed at the end of the list of error handlers.</p>
<p>There are no configurations for this handler.</p>
<h4><a id="errorhandlers-serialization-es"></a>Elasticsearch Error Handler<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch-hadoop/edit/6.6/docs/src/reference/asciidoc/core/errorhandlers.adoc">edit</a></h4>
<p>Default Handler Name: <code class="literal">es</code></p>
<p>When this handler is invoked it converts the error given into a JSON document and inserts it into an Elasticsearch index.
When this indexing operation is complete, the handler can be configured to signal that the error is handled (default),
or pass the error along to the next handler in the chain. The ES handler serializes error information using its own
mapping of the Elastic Common Schema. This data can accept additional user provided metadata that can assist users in
searching and reporting on failures (see labels and tags settings below).</p>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p>Error handlers are built to execute on a per record/error basis. The Elasticsearch Error Handler does not bulk
insert error information currently. Each error is inserted one at a time in order to ensure each record/error is handled.
This handler may not provide a very high throughput in cases where there are a large number of error events to handle. You
should try to design your jobs so that error handling is a relatively uncommon occurrence.</p>
</div>
</div>
<p>Available configurations for this handler:</p>
<div class="variablelist">
<dl class="variablelist">
<dt>
<span class="term">
<code class="literal">es.write.rest.error.handler.es.client.nodes</code> (default: "localhost" or currently configured nodes)
</span>
</dt>
<dd>
The comma separated string of node addresses to write errors to. It is recommended that this be a different cluster than
the one being written to (in order to avoid write contention).
</dd>
<dt>
<span class="term">
<code class="literal">es.write.rest.error.handler.es.client.port</code> (default: 9200 or currently configured port)
</span>
</dt>
<dd>
The http port to use when connecting to the Elasticsearch nodes.
</dd>
<dt>
<span class="term">
<code class="literal">es.write.rest.error.handler.es.client.resource</code> (required)
</span>
</dt>
<dd>
The index to write error information into. It is highly recommended that this index be just for error information.
Does not support index patterns.
</dd>
<dt>
<span class="term">
<code class="literal">es.write.rest.error.handler.es.client.inherit</code> (default: true)
</span>
</dt>
<dd>
Determines if the settings to create the client used for sending error information should inherit the same client settings
from the currently running job. By default, all client settings in the job configuration are inherited by this client.
</dd>
<dt>
<span class="term">
<code class="literal">es.write.rest.error.handler.es.client.conf.&lt;CONFIGURATION&gt;</code>
</span>
</dt>
<dd>
This configuration prefix is used to set client configuration values in the handler&#8217;s underlying ES client. This accepts
most of the settings documented in <a class="xref" href="configuration.html" title="Configuration"><em>Configuration</em></a>.
</dd>
<dt>
<span class="term">
<code class="literal">es.write.rest.error.handler.es.label.&lt;LABEL&gt;</code> (optional)
</span>
</dt>
<dd>
A user defined label field that is added to each error event created by this handler. This field will be indexed into
the Elasticsearch index provided for this handler. Text data only.
</dd>
<dt>
<span class="term">
<code class="literal">es.write.rest.error.handler.es.tags</code> (optional)
</span>
</dt>
<dd>
The comma separated string of tags to add to each error event created by this handler. This field will be indexed into
the Elasticsearch index provided for this handler. Text data only.
</dd>
<dt>
<span class="term">
<code class="literal">es.write.rest.error.handler.es.return.default</code> (default: HANDLED)
</span>
</dt>
<dd>
The handler result to be returned to the error handling framework when an error is successfully written to Elasticsearch.
Available values are <code class="literal">HANDLED</code>, <code class="literal">PASS</code>, and <code class="literal">ABORT</code>. Default result is <code class="literal">HANDLED</code>.
</dd>
<dt>
<span class="term">
<code class="literal">es.write.rest.error.handler.es.return.default.reason</code> (optional)
</span>
</dt>
<dd>
In the case that the default return value is <code class="literal">PASS</code>, this optional text setting allows a user to specify the reason for
the handler to pass the data along to the next handler in the chain.
</dd>
<dt>
<span class="term">
<code class="literal">es.write.rest.error.handler.es.return.error</code> (default: ABORT)
</span>
</dt>
<dd>
The handler result to be returned to the error handling framework when an error cannot be written to Elasticsearch.
Available values are <code class="literal">HANDLED</code>, <code class="literal">PASS</code>, and <code class="literal">ABORT</code>. Default result is <code class="literal">ABORT</code>.
</dd>
<dt>
<span class="term">
<code class="literal">es.write.rest.error.handler.es.return.error.reason</code> (optional)
</span>
</dt>
<dd>
In the case that the error return value is <code class="literal">PASS</code>, this optional text setting allows a user to specify the reason for the
handler to pass the data along to the next handler in the chain.
</dd>
</dl>
</div>
<h3><a id="errorhandlers-serialization-use"></a>Using Serialization Error Handlers<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch-hadoop/edit/6.6/docs/src/reference/asciidoc/core/errorhandlers.adoc">edit</a></h3>
<p>To configure serialization error handlers, you must specify the handlers in order with the following properties.</p>
<div class="variablelist">
<dl class="variablelist">
<dt>
<span class="term">
Setting <code class="literal">es.write.data.error.handlers</code>
</span>
</dt>
<dd>
Lists the names of the error handlers to use for serialization error handling, and the order that they should be called on.
Each default handler can be referenced by their handler name as the connector knows how to load them. Any handlers
provided from users or third party code will need to have their handler names defined with the <code class="literal">es.write.data.error.handler.</code>
prefix.
</dd>
</dl>
</div>
<p>For serialization failures, the Abort on Failure built-in handler is always placed as the last error handler to catch
any unhandled errors. This error handler forms the default serialization error handling behavior for elasticsearch-hadoop, which
matches the behavior from previous versions.</p>
<div class="olist orderedlist">
<ol class="orderedlist">
<li class="listitem">
Any configured user handlers will go here.
</li>
<li class="listitem">
Abort on Failure Built-In Handler: Rethrows the any errors it encounters
</li>
</ol>
</div>
<p>This behavior is modified by inserting handlers into the chain by using the handlers property. Let&#8217;s say that we want
to log ALL errors and ignore them.</p>
<div class="pre_wrapper lang-ini">
<pre class="programlisting prettyprint lang-ini">es.write.data.error.handlers = log <a id="CO105-1"></a><i class="conum" data-value="1"></i></pre>
</div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO105-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>Specifying the default Drop and Log handler</p>
</td>
</tr>
</table>
</div>
<p>With the above configuration, the handler list now looks like the following:</p>
<div class="olist orderedlist">
<ol class="orderedlist">
<li class="listitem">
Drop and Log Handler
</li>
<li class="listitem">
Abort on Failure Handler
</li>
</ol>
</div>
<p>As described above, the built-in <code class="literal">log</code> error handler has a required setting: What to use for the logger name. The logger
used will respect whatever logging configuration you have in place, and thus needs a name for the logger to use:</p>
<div class="pre_wrapper lang-ini">
<pre class="programlisting prettyprint lang-ini">es.write.data.error.handlers = log <a id="CO106-1"></a><i class="conum" data-value="1"></i>
es.write.data.error.handler.log.logger.name = SerializationErrors <a id="CO106-2"></a><i class="conum" data-value="2"></i></pre>
</div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO106-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>Specifying the default Drop and Log built-in handler</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO106-2"><i class="conum" data-value="2"></i></a></p>
</td>
<td align="left" valign="top">
<p>The Drop and Log built-in handler will log all errors to the <code class="literal">SerializationErrors</code> logger</p>
</td>
</tr>
</table>
</div>
<p>At this point, the Abort on Failure built-in handler is effectively ignored since the Drop and Log built-in handler will
always mark an error as consumed. This practice can prove to be hazardous, as potentially important errors may simply be
ignored. In many cases, it is preferable for users to write their own error handler to handle expected exceptions.</p>
<h4><a id="errorhandlers-serialization-user-handlers"></a>Writing Your Own Serialization Handlers<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch-hadoop/edit/6.6/docs/src/reference/asciidoc/core/errorhandlers.adoc">edit</a></h4>
<p>Let&#8217;s say that you are streaming some unstructured data to Elasticsearch. In this scenario, your data is not fully sanitized and
may contain field values that cannot be translated to JSON by the connector. You may not want to have your streaming job
fail on this data, as you are potentially expecting it to contain errors. In this situation, you may want to log the
data in a more comprehensive manner than to rely on the logging solution&#8217;s toString() method for your data.</p>
<p>Let&#8217;s write an error handler for this situation:</p>
<div class="pre_wrapper lang-java">
<pre class="programlisting prettyprint lang-java">package org.myproject.myhandlers;

import org.elasticsearch.hadoop.handler.HandlerResult;
import org.elasticsearch.hadoop.handler.ErrorCollector;
import org.elasticsearch.hadoop.serialization.handler.write.SerializationErrorHandler;
import org.elasticsearch.hadoop.serialization.handler.write.SerializationFailure;

public class CustomLogOnError extends SerializationErrorHandler {      <a id="CO107-1"></a><i class="conum" data-value="1"></i>

    private Log logger = ???; <a id="CO107-2"></a><i class="conum" data-value="2"></i>

    @Override
    public HandlerResult onError(SerializationFailure entry, ErrorCollector&lt;Object&gt; collector) throws Exception {  <a id="CO107-3"></a><i class="conum" data-value="3"></i>
        MyRecord record = (MyRecord) entry.getRecord();                             <a id="CO107-4"></a><i class="conum" data-value="4"></i>
        logger.error("Could not serialize record. " +
                "Record data : " + record.getSpecificField() + ", " + record.getOtherField(), entry.getException()); <a id="CO107-5"></a><i class="conum" data-value="5"></i>
        return HandlerResult.HANDLED;                                               <a id="CO107-6"></a><i class="conum" data-value="6"></i>
    }
}</pre>
</div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO107-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>We create a class and extend the SerializationErrorHandler base class</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO107-2"><i class="conum" data-value="2"></i></a></p>
</td>
<td align="left" valign="top">
<p>Create a logger using preferred logging solution</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO107-3"><i class="conum" data-value="3"></i></a></p>
</td>
<td align="left" valign="top">
<p>Override the <code class="literal">onError</code> method which will be invoked with the error details</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO107-4"><i class="conum" data-value="4"></i></a></p>
</td>
<td align="left" valign="top">
<p>Retrieve the record that failed to be serialized. Cast it to the record type you are expecting from your job</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO107-5"><i class="conum" data-value="5"></i></a></p>
</td>
<td align="left" valign="top">
<p>Log the specific information from the data you are interested in</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO107-6"><i class="conum" data-value="6"></i></a></p>
</td>
<td align="left" valign="top">
<p>Finally after logging the error, return <code class="literal">HandlerResult.HANDLED</code> to signal that the error is acknowledged</p>
</td>
</tr>
</table>
</div>
<p>Before we can place this handler in the list of serialization error handlers, we must register the handler class with a
name in the settings using <code class="literal">es.write.data.error.handler.[HANDLER-NAME]</code>:</p>
<div class="variablelist">
<dl class="variablelist">
<dt>
<span class="term">
Setting <code class="literal">es.write.data.error.handler.[HANDLER-NAME]</code>
</span>
</dt>
<dd>
Create a new handler named HANDLER-NAME. The value of this property must be the binary name of the class to
instantiate for this handler.
</dd>
</dl>
</div>
<p>In this case, lets register a handler name for our ignore conflicts handler:</p>
<div class="pre_wrapper lang-ini">
<pre class="programlisting prettyprint lang-ini">es.write.data.error.handler.customLog = org.myproject.myhandlers.CustomLogOnError</pre>
</div>
<p>Now that we have a name for the handler, we can use it in the handler list:</p>
<div class="pre_wrapper lang-ini">
<pre class="programlisting prettyprint lang-ini">es.write.data.error.handlers = customLog
es.write.data.error.handler.customLog = org.myproject.myhandlers.CustomLogOnError</pre>
</div>
<p>Now, your custom logging error handler will be invoked whenever a serialization failure occurs, and will instruct the
connector that it is ok with ignoring those failures to continue processing.</p>
<h4><a id="errorhandlers-serialization-advanced"></a>Advanced Concepts<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch-hadoop/edit/6.6/docs/src/reference/asciidoc/core/errorhandlers.adoc">edit</a></h4>
<p>Instead of logging data and dropping it, what if you wanted to persist it somewhere for safe keeping? What if
we wanted to pass properties into our handlers to parameterize their behavior? Lets create a handler that stores error
information in a local file for later analysis.</p>
<div class="pre_wrapper lang-java">
<pre class="programlisting prettyprint lang-java">package org.myproject.myhandlers;

import ...

import org.elasticsearch.hadoop.handler.HandlerResult;
import org.elasticsearch.hadoop.handler.ErrorCollector;
import org.elasticsearch.hadoop.serialization.handler.write.SerializationErrorHandler;
import org.elasticsearch.hadoop.serialization.handler.write.SerializationFailure;

public class OutputToFileHandler extends SerializationErrorHandler { <a id="CO108-1"></a><i class="conum" data-value="1"></i>

    private OutputStream outputStream;   <a id="CO108-2"></a><i class="conum" data-value="2"></i>
    private BufferedWriter writer;

    @Override
    public void init(Properties properties) {   <a id="CO108-3"></a><i class="conum" data-value="3"></i>
        try {
            outputStream = new FileOutputStream(properties.getProperty("filename"));   <a id="CO108-4"></a><i class="conum" data-value="4"></i>
            writer = new BufferedWriter(new OutputStreamWriter(outputStream));
        } catch (FileNotFoundException e) {
            throw new RuntimeException("Could not open file", e);
        }
    }

    @Override
    public HandlerResult onError(SerializationFailure entry, ErrorCollector&lt;Object&gt; collector)   <a id="CO108-5"></a><i class="conum" data-value="5"></i>
    throws Exception
    {
        writer.write("Record: " + entry.getRecord().toString());
        writer.newLine();
        writer.write("Error: " + entry.getException().getMessage());
        writer.newLine();
        for (String message : entry.previousHandlerMessages()) {
            writer.write("Previous Handler: " + message);           <a id="CO108-6"></a><i class="conum" data-value="6"></i>
            writer.newLine();
        }

        return HandlerResult.PASS; <a id="CO108-7"></a><i class="conum" data-value="7"></i>
    }

    @Override
    public void close() {   <a id="CO108-8"></a><i class="conum" data-value="8"></i>
        try {
            writer.close();
            outputStream.close();
        } catch (IOException e) {
            throw new RuntimeException("Closing file failed", e);
        }
    }
}</pre>
</div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO108-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>Extend the SerializationErrorHandler base class</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO108-2"><i class="conum" data-value="2"></i></a></p>
</td>
<td align="left" valign="top">
<p>Some local state for writing data out to a file</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO108-3"><i class="conum" data-value="3"></i></a></p>
</td>
<td align="left" valign="top">
<p>We override the <code class="literal">init</code> method. Any properties for this handler are passed in here.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO108-4"><i class="conum" data-value="4"></i></a></p>
</td>
<td align="left" valign="top">
<p>We are extracting the file to write to from the properties. We&#8217;ll see how to set this property below.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO108-5"><i class="conum" data-value="5"></i></a></p>
</td>
<td align="left" valign="top">
<p>Overriding the <code class="literal">onError</code> method to define our behavior.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO108-6"><i class="conum" data-value="6"></i></a></p>
</td>
<td align="left" valign="top">
<p>Write out the error information. This highlights all the available data provided by the <code class="literal">SerializationFailure</code> object.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO108-7"><i class="conum" data-value="7"></i></a></p>
</td>
<td align="left" valign="top">
<p>Return the <code class="literal">PASS</code> result to signal that the error should be handed off to the next error handler in the chain.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO108-8"><i class="conum" data-value="8"></i></a></p>
</td>
<td align="left" valign="top">
<p>Finally, close out any internally allocated resources.</p>
</td>
</tr>
</table>
</div>
<p>Added to this handler are the <code class="literal">init</code> and <code class="literal">close</code> methods. The <code class="literal">init</code> method is called when the handler is first created
at the start of the task and the <code class="literal">close</code> method is called when the task concludes. The <code class="literal">init</code> method accepts a properties
parameter, which contains any handler specific properties set by using <code class="literal">es.write.data.error.handler.[HANDLER-NAME].[PROPERTY-NAME]</code>.</p>
<div class="variablelist">
<dl class="variablelist">
<dt>
<span class="term">
Setting <code class="literal">es.write.data.error.handler.[HANDLER-NAME].[PROPERTY-NAME]</code>
</span>
</dt>
<dd>
Used to pass properties into handlers. HANDLER-NAME is the handler to be configured, and PROPERTY-NAME is the property
to set for the handler.
</dd>
</dl>
</div>
<p>In our use case, we will configure the our file logging error handler like so:</p>
<div class="pre_wrapper lang-ini">
<pre class="programlisting prettyprint lang-ini">es.write.data.error.handler.writeFile = org.myproject.myhandlers.OutputToFileHandler   <a id="CO109-1"></a><i class="conum" data-value="1"></i>
es.write.data.error.handler.writeFile.filename = /path/to/some/output/file <a id="CO109-2"></a><i class="conum" data-value="2"></i></pre>
</div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO109-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>We register our new handler with the name <code class="literal">writeFile</code></p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO109-2"><i class="conum" data-value="2"></i></a></p>
</td>
<td align="left" valign="top">
<p>Now we set a property named <code class="literal">filename</code> for the <code class="literal">writeFile</code> handler. In the <code class="literal">init</code> method of the handler, this can be picked up by using <code class="literal">filename</code> as the property key.</p>
</td>
</tr>
</table>
</div>
<p>Now to bring it all together:</p>
<div class="pre_wrapper lang-ini">
<pre class="programlisting prettyprint lang-ini">es.write.data.error.handlers = writeFile,customLog

es.write.data.error.handler.customLog = org.myproject.myhandlers.CustomLogOnError

es.write.data.error.handler.writeFile = org.myproject.myhandlers.OutputToFileHandler
es.write.data.error.handler.writeFile.filename = /path/to/some/output/file</pre>
</div>
<p>You now have a chain of handlers that writes all relevant data about the failure to a file (our writeFile handler), then
logs the errors using a custom log line and ignores the error to continue processing (our customLog handler).</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h2 class="title"><a id="errorhandlers-read-json"></a>Deserialization Error Handlers<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch-hadoop/edit/6.6/docs/src/reference/asciidoc/core/errorhandlers.adoc">edit</a></h2>
</div></div></div>
<p>When reading data, the connector executes scroll requests against the configured indices and reads their contents. For
each hit in a scroll search result, the connector attempts to deserialize it into an integration specific record type.
When using MapReduce, this data type is either a MapWritable or Text (for raw JSON data). For an integration like
Spark SQL which uses data schemas, the resulting data type is a Row object.</p>
<p>Elasticsearch stores documents in lucene indices. These documents can sometimes have loose definitions, or have
structures that cannot be parsed into a schema-based data type, for one reason or another. Sometimes a field may be
in a format that cannot be read correctly.</p>
<p>Elasticsearch for Apache Hadoop provides an API to handle document level deserialization errors from scroll responses. Error handlers for scroll reads are given:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
The raw JSON search result that was tried
</li>
<li class="listitem">
Exception encountered
</li>
</ul>
</div>
<p>Note: Deserialization Error Handlers only allow handling of errors that occur when parsing documents from scroll
responses. It may be possible that a search result can be successfully read, but is still malformed, thus causing an
exception when it is used in a completely different part of the framework. This Error Handler is called from the top of
the most reasonable place to handle exceptions in the scroll reading process, but this does not encapsulate all logic
for each integration.</p>
<p>There are a few default error handlers provided by the connector:</p>
<h4><a id="errorhandlers-read-json-log"></a>Drop and Log Error Handler<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch-hadoop/edit/6.6/docs/src/reference/asciidoc/core/errorhandlers.adoc">edit</a></h4>
<p>Default Handler Name: <code class="literal">log</code></p>
<p>When this handler is invoked it logs a message containing the JSON search hit that failed, the error message, and any previous
handler messages. After logging this message, the handler signals that the error has been acknowledged, thus
consuming/ignoring it.</p>
<p>Available configurations for this handler:</p>
<div class="variablelist">
<dl class="variablelist">
<dt>
<span class="term">
<code class="literal">es.read.data.error.handler.log.logger.name</code> (required)
</span>
</dt>
<dd>
The string name to use when creating the logger instance to log the errors. This setting is required if this handler is used.
</dd>
<dt>
<span class="term">
<code class="literal">es.read.data.error.handler.log.logger.class</code> (alternative to logger.name)
</span>
</dt>
<dd>
The class name to use when creating the logger instance to log the errors. This setting can be used instead of the
required setting <code class="literal">es.read.data.error.handler.log.logger.name</code>.
</dd>
<dt>
<span class="term">
<code class="literal">es.read.data.error.handler.log.logger.level</code> (default: WARN)
</span>
</dt>
<dd>
The logger level to use when logging the error message. Available options are <code class="literal">FATAL</code>, <code class="literal">ERROR</code>, <code class="literal">WARN</code>, <code class="literal">INFO</code>, <code class="literal">DEBUG</code>, and <code class="literal">TRACE</code>.
</dd>
</dl>
</div>
<h4><a id="errorhandlers-read-json-fail"></a>Abort on Failure Error Handler<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch-hadoop/edit/6.6/docs/src/reference/asciidoc/core/errorhandlers.adoc">edit</a></h4>
<p>Default Handler Name: <code class="literal">fail</code></p>
<p>When this handler is called it rethrows the error given to it and aborts. This handler is always loaded and automatically
placed at the end of the list of error handlers.</p>
<p>There are no configurations for this handler.</p>
<h4><a id="errorhandlers-read-json-es"></a>Elasticsearch Error Handler<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch-hadoop/edit/6.6/docs/src/reference/asciidoc/core/errorhandlers.adoc">edit</a></h4>
<p>Default Handler Name: <code class="literal">es</code></p>
<p>When this handler is invoked it converts the error given into a JSON document and inserts it into an Elasticsearch index.
When this indexing operation is complete, the handler can be configured to signal that the error is handled (default),
or pass the error along to the next handler in the chain. The ES handler serializes error information using its own
mapping of the Elastic Common Schema. This data can accept additional user provided metadata that can assist users in
searching and reporting on failures (see labels and tags settings below).</p>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p>Error handlers are built to execute on a per record/error basis. The Elasticsearch Error Handler does not bulk
insert error information currently. Each error is inserted one at a time in order to ensure each record/error is handled.
This handler may not provide a very high throughput in cases where there are a large number of error events to handle. You
should try to design your jobs so that error handling is a relatively uncommon occurrence.</p>
</div>
</div>
<p>Available configurations for this handler:</p>
<div class="variablelist">
<dl class="variablelist">
<dt>
<span class="term">
<code class="literal">es.write.rest.error.handler.es.client.nodes</code> (default: "localhost" or currently configured nodes)
</span>
</dt>
<dd>
The comma separated string of node addresses to write errors to. It is recommended that this be a different cluster than
the one being written to (in order to avoid write contention).
</dd>
<dt>
<span class="term">
<code class="literal">es.write.rest.error.handler.es.client.port</code> (default: 9200 or currently configured port)
</span>
</dt>
<dd>
The http port to use when connecting to the Elasticsearch nodes.
</dd>
<dt>
<span class="term">
<code class="literal">es.write.rest.error.handler.es.client.resource</code> (required)
</span>
</dt>
<dd>
The index to write error information into. It is highly recommended that this index be just for error information.
Does not support index patterns.
</dd>
<dt>
<span class="term">
<code class="literal">es.write.rest.error.handler.es.client.inherit</code> (default: true)
</span>
</dt>
<dd>
Determines if the settings to create the client used for sending error information should inherit the same client settings
from the currently running job. By default, all client settings in the job configuration are inherited by this client.
</dd>
<dt>
<span class="term">
<code class="literal">es.write.rest.error.handler.es.client.conf.&lt;CONFIGURATION&gt;</code>
</span>
</dt>
<dd>
This configuration prefix is used to set client configuration values in the handler&#8217;s underlying ES client. This accepts
most of the settings documented in <a class="xref" href="configuration.html" title="Configuration"><em>Configuration</em></a>.
</dd>
<dt>
<span class="term">
<code class="literal">es.write.rest.error.handler.es.label.&lt;LABEL&gt;</code> (optional)
</span>
</dt>
<dd>
A user defined label field that is added to each error event created by this handler. This field will be indexed into
the Elasticsearch index provided for this handler. Text data only.
</dd>
<dt>
<span class="term">
<code class="literal">es.write.rest.error.handler.es.tags</code> (optional)
</span>
</dt>
<dd>
The comma separated string of tags to add to each error event created by this handler. This field will be indexed into
the Elasticsearch index provided for this handler. Text data only.
</dd>
<dt>
<span class="term">
<code class="literal">es.write.rest.error.handler.es.return.default</code> (default: HANDLED)
</span>
</dt>
<dd>
The handler result to be returned to the error handling framework when an error is successfully written to Elasticsearch.
Available values are <code class="literal">HANDLED</code>, <code class="literal">PASS</code>, and <code class="literal">ABORT</code>. Default result is <code class="literal">HANDLED</code>.
</dd>
<dt>
<span class="term">
<code class="literal">es.write.rest.error.handler.es.return.default.reason</code> (optional)
</span>
</dt>
<dd>
In the case that the default return value is <code class="literal">PASS</code>, this optional text setting allows a user to specify the reason for
the handler to pass the data along to the next handler in the chain.
</dd>
<dt>
<span class="term">
<code class="literal">es.write.rest.error.handler.es.return.error</code> (default: ABORT)
</span>
</dt>
<dd>
The handler result to be returned to the error handling framework when an error cannot be written to Elasticsearch.
Available values are <code class="literal">HANDLED</code>, <code class="literal">PASS</code>, and <code class="literal">ABORT</code>. Default result is <code class="literal">ABORT</code>.
</dd>
<dt>
<span class="term">
<code class="literal">es.write.rest.error.handler.es.return.error.reason</code> (optional)
</span>
</dt>
<dd>
In the case that the error return value is <code class="literal">PASS</code>, this optional text setting allows a user to specify the reason for the
handler to pass the data along to the next handler in the chain.
</dd>
</dl>
</div>
<h3><a id="errorhandlers-read-json-use"></a>Using Deserialization Error Handlers<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch-hadoop/edit/6.6/docs/src/reference/asciidoc/core/errorhandlers.adoc">edit</a></h3>
<p>To configure deserialization error handlers, you must specify the handlers in order with the following properties.</p>
<div class="variablelist">
<dl class="variablelist">
<dt>
<span class="term">
Setting <code class="literal">es.read.data.error.handlers</code>
</span>
</dt>
<dd>
Lists the names of the error handlers to use for deserialization error handling, and the order that they should be called on.
Each default handler can be referenced by their handler name as the connector knows how to load them. Any handlers
provided from users or third party code will need to have their handler names defined with the <code class="literal">es.read.data.error.handler.</code>
prefix.
</dd>
</dl>
</div>
<p>For deserialization failures, the Abort on Failure built-in handler is always placed as the last error handler to catch
any unhandled errors. This error handler alone forms the default deserialization error handling behavior for elasticsearch-hadoop, which
matches the behavior from previous versions.</p>
<div class="olist orderedlist">
<ol class="orderedlist">
<li class="listitem">
Any configured user handlers will go here.
</li>
<li class="listitem">
Abort on Failure Built-In Handler: Rethrows the any errors it encounters
</li>
</ol>
</div>
<p>This behavior is modified by inserting handlers into the chain by using the handlers property. Let&#8217;s say that we want
to log ALL errors and ignore them.</p>
<div class="pre_wrapper lang-ini">
<pre class="programlisting prettyprint lang-ini">es.read.data.error.handlers = log <a id="CO110-1"></a><i class="conum" data-value="1"></i></pre>
</div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO110-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>Specifying the default Drop and Log handler</p>
</td>
</tr>
</table>
</div>
<p>With the above configuration, the handler list now looks like the following:</p>
<div class="olist orderedlist">
<ol class="orderedlist">
<li class="listitem">
Drop and Log Handler
</li>
<li class="listitem">
Abort on Failure Handler
</li>
</ol>
</div>
<p>As described above, the built-in <code class="literal">log</code> error handler has a required setting: What to use for the logger name. The logger
used will respect whatever logging configuration you have in place, and thus needs a name for the logger to use:</p>
<div class="pre_wrapper lang-ini">
<pre class="programlisting prettyprint lang-ini">es.read.data.error.handlers = log <a id="CO111-1"></a><i class="conum" data-value="1"></i>
es.read.data.error.handler.log.logger.name = DeserializationErrors <a id="CO111-2"></a><i class="conum" data-value="2"></i></pre>
</div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO111-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>Specifying the default Drop and Log built-in handler</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO111-2"><i class="conum" data-value="2"></i></a></p>
</td>
<td align="left" valign="top">
<p>The Drop and Log built-in handler will log all errors to the <code class="literal">DeserializationErrors</code> logger</p>
</td>
</tr>
</table>
</div>
<p>At this point, the Abort on Failure built-in handler is effectively ignored since the Drop and Log built-in handler will
always mark an error as consumed. This practice can prove to be hazardous, as potentially important errors may simply be
ignored. In many cases, it is preferable for users to write their own error handler to handle expected exceptions.</p>
<h4><a id="errorhandlers-read-json-user-handlers"></a>Writing Your Own Deserialization Error Handlers<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch-hadoop/edit/6.6/docs/src/reference/asciidoc/core/errorhandlers.adoc">edit</a></h4>
<p>Let&#8217;s say that you are reading a large index of log data from Elasticsearch. In this scenario, your log data is highly
unstructured, and not all of its contents are critical to your process. Due to the volume of data being read, your job
takes a long time to complete. In this case, you might want to replace records that cannot be read with a dummy record
to mark the failure, and not interrupt your processing. The offending data should be logged and dropped.</p>
<p>Let&#8217;s write an error handler for this situation:</p>
<div class="pre_wrapper lang-java">
<pre class="programlisting prettyprint lang-java">package org.myproject.myhandlers;

import org.elasticsearch.hadoop.handler.HandlerResult;
import org.elasticsearch.hadoop.handler.ErrorCollector;
import org.elasticsearch.hadoop.serialization.handler.read.DeserializationErrorHandler;
import org.elasticsearch.hadoop.serialization.handler.read.DeserializationFailure;

public class ReturnDummyHandler extends DeserializationErrorHandler { <a id="CO112-1"></a><i class="conum" data-value="1"></i>

    private static final Logger LOGGER = ...; <a id="CO112-2"></a><i class="conum" data-value="2"></i>
    private static final String DUMMY_RECORD = "..."; <a id="CO112-3"></a><i class="conum" data-value="3"></i>

    @Override
    public HandlerResult onError(DeserializationFailure entry, ErrorCollector&lt;byte[]&gt; collector) <a id="CO112-4"></a><i class="conum" data-value="4"></i>
    throws Exception
    {
        BufferedReader reader = new BufferedReader(new InputStreamReader(entry.getHitContents()));
        StringBuilder hitContent = new StringBuilder();
        for (String line = reader.readLine(); line != null; line = reader.readLine()) {           <a id="CO112-5"></a><i class="conum" data-value="5"></i>
            hitContent.append(line);
        }
        LOGGER.warn("Encountered malformed record during read. Replacing with dummy record. " +   <a id="CO112-6"></a><i class="conum" data-value="6"></i>
                            "Malformed Data: " + hitContent, entry.getException());
        return collector.retry(DUMMY_RECORD.getBytes());                                         <a id="CO112-7"></a><i class="conum" data-value="7"></i>
    }
}</pre>
</div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO112-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>We create a class and extend the DeserializationErrorHandler base class</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO112-2"><i class="conum" data-value="2"></i></a></p>
</td>
<td align="left" valign="top">
<p>Create a logger using preferred logging solution</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO112-3"><i class="conum" data-value="3"></i></a></p>
</td>
<td align="left" valign="top">
<p>We create a String to use for our dummy record that should be deserialized instead</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO112-4"><i class="conum" data-value="4"></i></a></p>
</td>
<td align="left" valign="top">
<p>Override the <code class="literal">onError</code> method which will be invoked with the error details</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO112-5"><i class="conum" data-value="5"></i></a></p>
</td>
<td align="left" valign="top">
<p>We read the contents of the failed search hit as a String</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO112-6"><i class="conum" data-value="6"></i></a></p>
</td>
<td align="left" valign="top">
<p>We log the contents of the failed document, as well as the exception that details the cause of the failure</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO112-7"><i class="conum" data-value="7"></i></a></p>
</td>
<td align="left" valign="top">
<p>Finally, we return the dummy data contents to be deserialized.</p>
</td>
</tr>
</table>
</div>
<p>Before we can place this handler in the list of deserialization error handlers, we must register the handler class with a
name in the settings using <code class="literal">es.read.data.error.handler.[HANDLER-NAME]</code>:</p>
<div class="variablelist">
<dl class="variablelist">
<dt>
<span class="term">
Setting <code class="literal">es.read.data.error.handler.[HANDLER-NAME]</code>
</span>
</dt>
<dd>
Create a new handler named HANDLER-NAME. The value of this property must be the binary name of the class to
instantiate for this handler.
</dd>
</dl>
</div>
<p>In this case, lets register a handler name for our dummy record handler:</p>
<div class="pre_wrapper lang-ini">
<pre class="programlisting prettyprint lang-ini">es.read.data.error.handler.returnDummy = org.myproject.myhandlers.ReturnDummyHandler</pre>
</div>
<p>Now that we have a name for the handler, we can use it in the handler list:</p>
<div class="pre_wrapper lang-ini">
<pre class="programlisting prettyprint lang-ini">es.read.data.error.handlers = returnDummy
es.read.data.error.handler.returnDummy = org.myproject.myhandlers.ReturnDummyHandler</pre>
</div>
<p>Now, your dummy data error handler will be invoked whenever a deserialization failure occurs, and will instruct the
connector to use your provided dummy record instead of the malformed data.</p>
<h4><a id="errorhandlers-read-json-advanced"></a>Advanced Concepts<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch-hadoop/edit/6.6/docs/src/reference/asciidoc/core/errorhandlers.adoc">edit</a></h4>
<p>What if instead of logging data and dropping it, what if you wanted to persist it somewhere for safe keeping? What if
we wanted to pass properties into our handlers to parameterize their behavior? Lets create a handler that stores error
information in a local file for later analysis.</p>
<div class="pre_wrapper lang-java">
<pre class="programlisting prettyprint lang-java">package org.myproject.myhandlers;

import ...

import org.elasticsearch.hadoop.handler.HandlerResult;
import org.elasticsearch.hadoop.handler.ErrorCollector;
import org.elasticsearch.hadoop.serialization.handler.read.DeserializationErrorHandler;
import org.elasticsearch.hadoop.serialization.handler.read.DeserializationFailure;

public class ReturnDummyAndLogToFileHandler extends DeserializationErrorHandler { <a id="CO113-1"></a><i class="conum" data-value="1"></i>

    private static final String DUMMY_RECORD = "...";

    private OutputStream outputStream;   <a id="CO113-2"></a><i class="conum" data-value="2"></i>
    private BufferedWriter writer;

    @Override
    public void init(Properties properties) {   <a id="CO113-3"></a><i class="conum" data-value="3"></i>
        try {
            outputStream = new FileOutputStream(properties.getProperty("filename"));   <a id="CO113-4"></a><i class="conum" data-value="4"></i>
            writer = new BufferedWriter(new OutputStreamWriter(outputStream));
        } catch (FileNotFoundException e) {
            throw new RuntimeException("Could not open file", e);
        }
    }

    @Override
    public HandlerResult onError(DeserializationFailure entry, ErrorCollector&lt;byte[]&gt; collector)   <a id="CO113-5"></a><i class="conum" data-value="5"></i>
    throws Exception
    {
        BufferedReader reader = new BufferedReader(new InputStreamReader(entry.getHitContents()));
        StringBuilder hitContent = new StringBuilder();
        for (String line = reader.readLine(); line != null; line = reader.readLine()) {           <a id="CO113-6"></a><i class="conum" data-value="6"></i>
            hitContent.append(line);
        }

        writer.write("Error: " + entry.getException().getMessage());
        writer.newLine();
        for (String message : entry.previousHandlerMessages()) {
            writer.write("Previous Handler: " + message);           <a id="CO113-7"></a><i class="conum" data-value="7"></i>
            writer.newLine();
        }
        writer.write("Entry: ");
        writer.newLine();
        writer.write(hitContent.toString());
        writer.newLine();

        return collector.retry(DUMMY_RECORD.getBytes());            <a id="CO113-8"></a><i class="conum" data-value="8"></i>
    }

    @Override
    public void close() {   <a id="CO113-9"></a><i class="conum" data-value="9"></i>
        try {
            writer.close();
            outputStream.close();
        } catch (IOException e) {
            throw new RuntimeException("Closing file failed", e);
        }
    }
}</pre>
</div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO113-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>Extend the DeserializationErrorHandler base class</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO113-2"><i class="conum" data-value="2"></i></a></p>
</td>
<td align="left" valign="top">
<p>Some local state for writing data out to a file</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO113-3"><i class="conum" data-value="3"></i></a></p>
</td>
<td align="left" valign="top">
<p>We override the <code class="literal">init</code> method. Any properties for this handler are passed in here</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO113-4"><i class="conum" data-value="4"></i></a></p>
</td>
<td align="left" valign="top">
<p>We are extracting the file to write to from the properties. We&#8217;ll see how to set this property below</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO113-5"><i class="conum" data-value="5"></i></a></p>
</td>
<td align="left" valign="top">
<p>Overriding the <code class="literal">onError</code> method to define our behavior</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO113-6"><i class="conum" data-value="6"></i></a></p>
</td>
<td align="left" valign="top">
<p>Read the contents of the failed search hit</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO113-7"><i class="conum" data-value="7"></i></a></p>
</td>
<td align="left" valign="top">
<p>Write out the error information. This highlights all the available data provided by the <code class="literal">DeserializationFailure</code> object</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO113-8"><i class="conum" data-value="8"></i></a></p>
</td>
<td align="left" valign="top">
<p>Perform a retry operation, using our dummy record</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO113-9"><i class="conum" data-value="9"></i></a></p>
</td>
<td align="left" valign="top">
<p>Finally, close out any internally allocated resources</p>
</td>
</tr>
</table>
</div>
<p>Added to this handler are the <code class="literal">init</code> and <code class="literal">close</code> methods. The <code class="literal">init</code> method is called when the scroll query is first
created at the start of the task and the <code class="literal">close</code> method is called when the scroll query is closed when the task
concludes. The <code class="literal">init</code> method accepts a properties parameter, which contains any handler specific properties set by
using <code class="literal">es.read.data.error.handler.[HANDLER-NAME].[PROPERTY-NAME]</code>.</p>
<div class="variablelist">
<dl class="variablelist">
<dt>
<span class="term">
Setting <code class="literal">es.read.data.error.handler.[HANDLER-NAME].[PROPERTY-NAME]</code>
</span>
</dt>
<dd>
Used to pass properties into handlers. HANDLER-NAME is the handler to be configured, and PROPERTY-NAME is the property
to set for the handler.
</dd>
</dl>
</div>
<p>In our use case, we will configure the our file logging error handler like so:</p>
<div class="pre_wrapper lang-ini">
<pre class="programlisting prettyprint lang-ini">es.read.data.error.handler.writeFile = org.myproject.myhandlers.ReturnDummyAndLogToFileHandler   <a id="CO114-1"></a><i class="conum" data-value="1"></i>
es.read.data.error.handler.writeFile.filename = /path/to/some/output/file   <a id="CO114-2"></a><i class="conum" data-value="2"></i></pre>
</div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO114-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>We register our new handler with the name <code class="literal">writeFile</code></p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO114-2"><i class="conum" data-value="2"></i></a></p>
</td>
<td align="left" valign="top">
<p>Now we set a property named <code class="literal">filename</code> for the <code class="literal">writeFile</code> handler. In the <code class="literal">init</code> method of the handler, this can be picked up by using <code class="literal">filename</code> as the property key.</p>
</td>
</tr>
</table>
</div>
<p>Now to bring it all together with the previous example:</p>
<div class="pre_wrapper lang-ini">
<pre class="programlisting prettyprint lang-ini">es.read.data.error.handlers = writeFile
es.read.data.error.handler.writeFile = org.myproject.myhandlers.ReturnDummyAndLogToFileHandler
es.read.data.error.handler.writeFile.filename = /path/to/some/output/file</pre>
</div>
<p>You now have a handler that retries replaces malformed data with dummy records, then logs those malformed records along
with their error information by writing them out to a custom file.</p>
</div>

</div>
<div class="navfooter">
<span class="prev">
<a href="mapping.html">« Mapping and Types</a>
</span>
<span class="next">
<a href="metrics.html">Hadoop Metrics »</a>
</span>
</div>
</div>
</body>
</html>
