<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Cardinality Aggregation | Elasticsearch Reference [1.5] | Elastic</title>
<link rel="home" href="index.html" title="Elasticsearch Reference [1.5]"/>
<link rel="up" href="search-aggregations.html" title="Aggregations"/>
<link rel="prev" href="search-aggregations-metrics-percentile-rank-aggregation.html" title="Percentile Ranks Aggregation"/>
<link rel="next" href="search-aggregations-metrics-geobounds-aggregation.html" title="Geo Bounds Aggregation"/>
<meta name="DC.type" content="Learn/Docs/Elasticsearch/Reference/1.5"/>
<meta name="DC.subject" content="Elasticsearch"/>
<meta name="DC.identifier" content="1.5"/>
<meta name="robots" content="noindex,nofollow"/>
</head>
<body><div class="page_header">
<p>
  <strong>WARNING</strong>: Version 1.5 of Elasticsearch has passed its 
  <a href="https://www.elastic.co/support/eol">EOL date</a>. 
</p>  
<p>
  This documentation is no longer being maintained and may be removed. 
  If you are running this version, we strongly advise you to upgrade. 
  For the latest information, see the 
  <a href="../current/index.html">current release documentation</a>. 
</p>
</div>
<div id="content">
<div class="breadcrumbs">
<span class="breadcrumb-link"><a href="index.html">Elasticsearch Reference [1.5]</a></span>
»
<span class="breadcrumb-link"><a href="search.html">Search APIs</a></span>
»
<span class="breadcrumb-link"><a href="search-aggregations.html">Aggregations</a></span>
»
<span class="breadcrumb-node">Cardinality Aggregation</span>
</div>
<div class="navheader">
<span class="prev">
<a href="search-aggregations-metrics-percentile-rank-aggregation.html">« Percentile Ranks Aggregation</a>
</span>
<span class="next">
<a href="search-aggregations-metrics-geobounds-aggregation.html">Geo Bounds Aggregation »</a>
</span>
</div>
<div class="section">
<div class="titlepage"><div><div>
<h2 class="title"><a id="search-aggregations-metrics-cardinality-aggregation"></a>Cardinality Aggregation<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch/edit/1.5/docs/reference/search/aggregations/metrics/cardinality-aggregation.asciidoc">edit</a></h2>
</div></div></div>
<p>A <code class="literal">single-value</code> metrics aggregation that calculates an approximate count of
distinct values. Values can be extracted either from specific fields in the
document or generated by a script.</p>
<div class="warning admon">
<div class="icon"></div>
<div class="admon_content">
<p>This functionality is experimental and may be changed or removed completely in a future release. Elastic will take a best effort approach to fix any issues, but experimental features are not subject to the support SLA of official GA features.</p>
</div>
</div>
<p>Assume you are indexing books and would like to count the unique authors that
match a query:</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">{
    "aggs" : {
        "author_count" : {
            "cardinality" : {
                "field" : "author"
            }
        }
    }
}</pre>
</div>
<p>This aggregation also supports the <code class="literal">precision_threshold</code> and <code class="literal">rehash</code> options:</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">{
    "aggs" : {
        "author_count" : {
            "cardinality" : {
                "field" : "author_hash",
                "precision_threshold": 100, <a id="CO22-1"></a><i class="conum" data-value="1"></i>
                "rehash": false <a id="CO22-2"></a><i class="conum" data-value="2"></i>
            }
        }
    }
}</pre>
</div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO22-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>The <code class="literal">precision_threshold</code> options allows to trade memory for accuracy, and
defines a unique count below which counts are expected to be close to
accurate. Above this value, counts might become a bit more fuzzy. The maximum
supported value is 40000, thresholds above this number will have the same
effect as a threshold of 40000.
Default value depends on the number of parent aggregations that multiple
create buckets (such as terms or histograms).</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO22-2"><i class="conum" data-value="2"></i></a></p>
</td>
<td align="left" valign="top">
<p>If you computed a hash on client-side, stored it into your documents and want
Elasticsearch to use them to compute counts using this hash function without
rehashing values, it is possible to specify <code class="literal">rehash: false</code>. Default value is
<code class="literal">true</code>. Please note that the hash must be indexed as a long when <code class="literal">rehash</code> is
false.</p>
</td>
</tr>
</table>
</div>
<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_counts_are_approximate"></a>Counts are approximate<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch/edit/1.5/docs/reference/search/aggregations/metrics/cardinality-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>Computing exact counts requires loading values into a hash set and returning its
size. This doesn&#8217;t scale when working on high-cardinality sets and/or large
values as the required memory usage and the need to communicate those
per-shard sets between nodes would utilize too many resources of the cluster.</p>
<p>This <code class="literal">cardinality</code> aggregation is based on the
<a href="http://static.googleusercontent.com/media/research.google.com/fr//pubs/archive/40671.pdf" class="ulink" target="_top">HyperLogLog++</a>
algorithm, which counts based on the hashes of the values with some interesting
properties:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
configurable precision, which decides on how to trade memory for accuracy,
</li>
<li class="listitem">
excellent accuracy on low-cardinality sets,
</li>
<li class="listitem">
fixed memory usage: no matter if there are tens or billions of unique values,
memory usage only depends on the configured precision.
</li>
</ul>
</div>
<p>For a precision threshold of <code class="literal">c</code>, the implementation that we are using requires
about <code class="literal">c * 8</code> bytes.</p>
<p>The following chart shows how the error varies before and after the threshold:</p>
<p><span class="image"><img src="images/cardinality_error.png" alt="cardinality error"></span></p>
<p>For all 3 thresholds, counts have been accurate up to the configured threshold
(although not guaranteed, this is likely to be the case). Please also note that
even with a threshold as low as 100, the error remains under 5%, even when
counting millions of items.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_pre_computed_hashes"></a>Pre-computed hashes<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch/edit/1.5/docs/reference/search/aggregations/metrics/cardinality-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>If you don&#8217;t want Elasticsearch to re-compute hashes on every run of this
aggregation, it is possible to use pre-computed hashes, either by computing a
hash on client-side, indexing it and specifying <code class="literal">rehash: false</code>, or by using
the special <code class="literal">murmur3</code> field mapper, typically in the context of a <code class="literal">multi-field</code>
in the mapping:</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">{
    "author": {
        "type": "string",
        "fields": {
            "hash": {
                "type": "murmur3"
            }
        }
    }
}</pre>
</div>
<p>With such a mapping, Elasticsearch is going to compute hashes of the <code class="literal">author</code>
field at indexing time and store them in the <code class="literal">author.hash</code> field. This
way, unique counts can be computed using the cardinality aggregation by only
loading the hashes into memory, not the values of the <code class="literal">author</code> field, and
without computing hashes on the fly:</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">{
    "aggs" : {
        "author_count" : {
            "cardinality" : {
                "field" : "author.hash"
            }
        }
    }
}</pre>
</div>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p><code class="literal">rehash</code> is automatically set to <code class="literal">false</code> when computing unique counts on
a <code class="literal">murmur3</code> field.</p>
</div>
</div>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p>Pre-computing hashes is usually only useful on very large and/or
high-cardinality fields as it saves CPU and memory. However, on numeric
fields, hashing is very fast and storing the original values requires as much
or less memory than storing the hashes. This is also true on low-cardinality
string fields, especially given that those have an optimization in order to
make sure that hashes are computed at most once per unique value per segment.</p>
</div>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_script_10"></a>Script<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch/edit/1.5/docs/reference/search/aggregations/metrics/cardinality-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>The <code class="literal">cardinality</code> metric supports scripting, with a noticeable performance hit
however since hashes need to be computed on the fly.</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">{
    "aggs" : {
        "author_count" : {
            "cardinality" : {
                "script": "doc['author.first_name'].value + ' ' + doc['author.last_name'].value"
            }
        }
    }
}</pre>
</div>
<div class="tip admon">
<div class="icon"></div>
<div class="admon_content">
<p>The <code class="literal">script</code> parameter expects an inline script. Use <code class="literal">script_id</code> for indexed scripts and <code class="literal">script_file</code> for scripts in the <code class="literal">config/scripts/</code> directory.</p>
</div>
</div>
</div>

</div>
<div class="navfooter">
<span class="prev">
<a href="search-aggregations-metrics-percentile-rank-aggregation.html">« Percentile Ranks Aggregation</a>
</span>
<span class="next">
<a href="search-aggregations-metrics-geobounds-aggregation.html">Geo Bounds Aggregation »</a>
</span>
</div>
</div>
</body>
</html>
