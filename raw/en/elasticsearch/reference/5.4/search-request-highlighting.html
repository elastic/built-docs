<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Highlighting | Elasticsearch Reference [5.4] | Elastic</title>
<link rel="home" href="index.html" title="Elasticsearch Reference [5.4]"/>
<link rel="up" href="search-request-body.html" title="Request Body Search"/>
<link rel="prev" href="search-request-post-filter.html" title="Post filter"/>
<link rel="next" href="search-request-rescore.html" title="Rescoring"/>
<meta name="DC.type" content="Learn/Docs/Elasticsearch/Reference/5.4"/>
<meta name="DC.subject" content="Elasticsearch"/>
<meta name="DC.identifier" content="5.4"/>
<meta name="robots" content="noindex,nofollow"/>
</head>
<body><div class="page_header">
<p>
  <strong>WARNING</strong>: Version 5.4 of Elasticsearch has passed its 
  <a href="https://www.elastic.co/support/eol">EOL date</a>. 
</p>  
<p>
  This documentation is no longer being maintained and may be removed. 
  If you are running this version, we strongly advise you to upgrade. 
  For the latest information, see the 
  <a href="../current/index.html">current release documentation</a>. 
</p>
</div>
<div id="content">
<div class="breadcrumbs">
<span class="breadcrumb-link"><a href="index.html">Elasticsearch Reference [5.4]</a></span>
»
<span class="breadcrumb-link"><a href="search.html">Search APIs</a></span>
»
<span class="breadcrumb-link"><a href="search-request-body.html">Request Body Search</a></span>
»
<span class="breadcrumb-node">Highlighting</span>
</div>
<div class="navheader">
<span class="prev">
<a href="search-request-post-filter.html">« Post filter</a>
</span>
<span class="next">
<a href="search-request-rescore.html">Rescoring »</a>
</span>
</div>
<div class="section">
<div class="titlepage"><div><div>
<h2 class="title"><a id="search-request-highlighting"></a>Highlighting<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch/edit/5.4/docs/reference/search/request/highlighting.asciidoc">edit</a></h2>
</div></div></div>
<p>Allows to highlight search results on one or more fields. The
implementation uses either the lucene <code class="literal">plain</code> highlighter, the
fast vector highlighter (<code class="literal">fvh</code>) or <code class="literal">postings</code> highlighter.
The following is an example of the search request body:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
    "query" : {
        "match": { "content": "kimchy" }
    },
    "highlight" : {
        "fields" : {
            "content" : {}
        }
    }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/240.console"></div>
<p>In the above case, the <code class="literal">content</code> field will be highlighted for each
search hit (there will be another element in each search hit, called
<code class="literal">highlight</code>, which includes the highlighted fields and the highlighted
fragments).</p>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p>In order to perform highlighting, the actual content of the field is
required. If the field in question is stored (has <code class="literal">store</code> set to <code class="literal">true</code>
in the mapping) it will be used, otherwise, the actual <code class="literal">_source</code> will
be loaded and the relevant field will be extracted from it.</p>
<p>The <code class="literal">_all</code> field cannot be extracted from <code class="literal">_source</code>, so it can only
be used for highlighting if it mapped to have <code class="literal">store</code> set to <code class="literal">true</code>.</p>
</div>
</div>
<p>The field name supports wildcard notation. For example, using <code class="literal">comment_*</code>
will cause all <a class="xref" href="text.html" title="Text datatype">text</a> and <a class="xref" href="keyword.html" title="Keyword datatype">keyword</a> fields (and <a class="xref" href="string.html" title="String datatype">string</a>
from versions before 5.0) that match the expression to be highlighted.
Note that all other fields will not be highlighted. If you use a custom mapper and want to
highlight on a field anyway, you have to provide the field name explicitly.</p>
<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="plain-highlighter"></a>Plain highlighter<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch/edit/5.4/docs/reference/search/request/highlighting.asciidoc">edit</a></h3>
</div></div></div>
<p>The default choice of highlighter is of type <code class="literal">plain</code> and uses the Lucene highlighter.
It tries hard to reflect the query matching logic in terms of understanding word importance and any word positioning criteria in phrase queries.</p>
<div class="warning admon">
<div class="icon"></div>
<div class="admon_content">
<p>If you want to highlight a lot of fields in a lot of documents with complex queries this highlighter will not be fast.
In its efforts to accurately reflect query logic it creates a tiny in-memory index and re-runs the original query criteria through
Lucene&#8217;s query execution planner to get access to low-level match information on the current document.
This is repeated for every field and every document that needs highlighting. If this presents a performance issue in your system consider using an alternative highlighter.</p>
</div>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="postings-highlighter"></a>Postings highlighter<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch/edit/5.4/docs/reference/search/request/highlighting.asciidoc">edit</a></h3>
</div></div></div>
<p>If <code class="literal">index_options</code> is set to <code class="literal">offsets</code> in the mapping the postings highlighter
will be used instead of the plain highlighter. The postings highlighter:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
Is faster since it doesn&#8217;t require to reanalyze the text to be highlighted:
the larger the documents the better the performance gain should be
</li>
<li class="listitem">
Requires less disk space than term_vectors, needed for the fast vector
highlighter
</li>
<li class="listitem">
Breaks the text into sentences and highlights them. Plays really well with
natural languages, not as well with fields containing for instance html markup
</li>
<li class="listitem">
Treats the document as the whole corpus, and scores individual sentences as
if they were documents in this corpus, using the  BM25 algorithm
</li>
</ul>
</div>
<p>Here is an example of setting the <code class="literal">content</code> field in the index mapping to allow for
highlighting using the postings highlighter on it:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">PUT /example
{
  "mappings": {
    "doc" : {
      "properties": {
        "comment" : {
          "type": "text",
          "index_options" : "offsets"
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/241.console"></div>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p>Note that the postings highlighter is meant to perform simple query terms
highlighting, regardless of their positions. That means that when used for
instance in combination with a phrase query, it will highlight all the terms
that the query is composed of, regardless of whether they are actually part of
a query match, effectively ignoring their positions.</p>
</div>
</div>
<div class="warning admon">
<div class="icon"></div>
<div class="admon_content">
<p>The postings highlighter doesn&#8217;t support highlighting some complex queries,
like a <code class="literal">match</code> query with <code class="literal">type</code> set to <code class="literal">match_phrase_prefix</code>. No highlighted
snippets will be returned in that case.</p>
</div>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="fast-vector-highlighter"></a>Fast vector highlighter<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch/edit/5.4/docs/reference/search/request/highlighting.asciidoc">edit</a></h3>
</div></div></div>
<p>If <code class="literal">term_vector</code> information is provided by setting <code class="literal">term_vector</code> to
<code class="literal">with_positions_offsets</code> in the mapping then the fast vector highlighter
will be used instead of the plain highlighter.  The fast vector highlighter:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
Is faster especially for large fields (&gt; <code class="literal">1MB</code>)
</li>
<li class="listitem">
Can be customized with <code class="literal">boundary_scanner</code> (see <a class="xref" href="search-request-highlighting.html#boundary-scanners" title="Boundary Scanners">below</a>)
</li>
<li class="listitem">
Requires setting <code class="literal">term_vector</code> to <code class="literal">with_positions_offsets</code> which
increases the size of the index
</li>
<li class="listitem">
Can combine matches from multiple fields into one result.  See
<code class="literal">matched_fields</code>
</li>
<li class="listitem">
Can assign different weights to matches at different positions allowing
for things like phrase matches being sorted above term matches when
highlighting a Boosting Query that boosts phrase matches over term matches
</li>
</ul>
</div>
<p>Here is an example of setting the <code class="literal">content</code> field to allow for
highlighting using the fast vector highlighter on it (this will cause
the index to be bigger):</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">PUT /example
{
  "mappings": {
    "doc" : {
      "properties": {
        "comment" : {
          "type": "text",
          "term_vector" : "with_positions_offsets"
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/242.console"></div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_unified_highlighter"></a>Unified Highlighter<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch/edit/5.4/docs/reference/search/request/highlighting.asciidoc">edit</a></h3>
</div></div></div>
<div class="warning admon">
<div class="icon"></div>
<div class="admon_content">
<p>This functionality is experimental and may be changed or removed completely in a future release. Elastic will take a best effort approach to fix any issues, but experimental features are not subject to the support SLA of official GA features.</p>
</div>
</div>
<p>The <code class="literal">unified</code> highlighter can extract offsets from either postings, term vectors, or via re-analyzing text.
Under the hood it uses Lucene UnifiedHighlighter which picks its strategy depending on the field and the query to highlight.
Independently of the strategy this highlighter breaks the text into sentences and scores individual sentences as
if they were documents in this corpus, using the BM25 algorithm.
It supports accurate phrase and multi-term (fuzzy, prefix, regex) highlighting and can be used with the following options:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
<code class="literal">force_source</code>
</li>
<li class="listitem">
<code class="literal">encoder</code>
</li>
<li class="listitem">
<code class="literal">highlight_query</code>
</li>
<li class="listitem">
<code class="literal">pre_tags and `post_tags</code>
</li>
<li class="listitem">
<code class="literal">require_field_match</code>
</li>
<li class="listitem">
<code class="literal">boundary_scanner</code> (<code class="literal">sentence</code> (<span class="strong strong"><strong>default</strong></span>)  or <code class="literal">word</code>)
</li>
<li class="listitem">
<code class="literal">max_fragment_length</code> (only for <code class="literal">sentence</code> scanner)
</li>
<li class="listitem">
<code class="literal">no_match_size</code>
</li>
</ul>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_force_highlighter_type"></a>Force highlighter type<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch/edit/5.4/docs/reference/search/request/highlighting.asciidoc">edit</a></h3>
</div></div></div>
<p>The <code class="literal">type</code> field allows to force a specific highlighter type. This is useful
for instance when needing to use the plain highlighter on a field that has
<code class="literal">term_vectors</code> enabled. The allowed values are: <code class="literal">plain</code>, <code class="literal">postings</code> and <code class="literal">fvh</code>.
The following is an example that forces the use of the plain highlighter:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
    "query" : {
        "match": { "user": "kimchy" }
    },
    "highlight" : {
        "fields" : {
            "content" : {"type" : "plain"}
        }
    }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/243.console"></div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_force_highlighting_on_source"></a>Force highlighting on source<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch/edit/5.4/docs/reference/search/request/highlighting.asciidoc">edit</a></h3>
</div></div></div>
<p>Forces the highlighting to highlight fields based on the source even if fields are
stored separately. Defaults to <code class="literal">false</code>.</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
    "query" : {
        "match": { "user": "kimchy" }
    },
    "highlight" : {
        "fields" : {
            "content" : {"force_source" : true}
        }
    }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/244.console"></div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="tags"></a>Highlighting Tags<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch/edit/5.4/docs/reference/search/request/highlighting.asciidoc">edit</a></h3>
</div></div></div>
<p>By default, the highlighting will wrap highlighted text in <code class="literal">&lt;em&gt;</code> and
<code class="literal">&lt;/em&gt;</code>. This can be controlled by setting <code class="literal">pre_tags</code> and <code class="literal">post_tags</code>,
for example:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
    "query" : {
        "match": { "user": "kimchy" }
    },
    "highlight" : {
        "pre_tags" : ["&lt;tag1&gt;"],
        "post_tags" : ["&lt;/tag1&gt;"],
        "fields" : {
            "_all" : {}
        }
    }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/245.console"></div>
<p>Using the fast vector highlighter there can be more tags, and the "importance"
is ordered.</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
    "query" : {
        "match": { "user": "kimchy" }
    },
    "highlight" : {
        "pre_tags" : ["&lt;tag1&gt;", "&lt;tag2&gt;"],
        "post_tags" : ["&lt;/tag1&gt;", "&lt;/tag2&gt;"],
        "fields" : {
            "_all" : {}
        }
    }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/246.console"></div>
<p>There are also built in "tag" schemas, with currently a single schema
called <code class="literal">styled</code> with the following <code class="literal">pre_tags</code>:</p>
<div class="pre_wrapper lang-html">
<pre class="programlisting prettyprint lang-html">&lt;em class="hlt1"&gt;, &lt;em class="hlt2"&gt;, &lt;em class="hlt3"&gt;,
&lt;em class="hlt4"&gt;, &lt;em class="hlt5"&gt;, &lt;em class="hlt6"&gt;,
&lt;em class="hlt7"&gt;, &lt;em class="hlt8"&gt;, &lt;em class="hlt9"&gt;,
&lt;em class="hlt10"&gt;</pre>
</div>
<p>and <code class="literal">&lt;/em&gt;</code> as <code class="literal">post_tags</code>. If you think of more nice to have built in tag
schemas, just send an email to the mailing list or open an issue. Here
is an example of switching tag schemas:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
    "query" : {
        "match": { "user": "kimchy" }
    },
    "highlight" : {
        "tags_schema" : "styled",
        "fields" : {
            "content" : {}
        }
    }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/247.console"></div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_encoder"></a>Encoder<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch/edit/5.4/docs/reference/search/request/highlighting.asciidoc">edit</a></h3>
</div></div></div>
<p>An <code class="literal">encoder</code> parameter can be used to define how highlighted text will
be encoded. It can be either <code class="literal">default</code> (no encoding) or <code class="literal">html</code> (will
escape html, if you use html highlighting tags).</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_highlighted_fragments"></a>Highlighted Fragments<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch/edit/5.4/docs/reference/search/request/highlighting.asciidoc">edit</a></h3>
</div></div></div>
<p>Each field highlighted can control the size of the highlighted fragment
in characters (defaults to <code class="literal">100</code>), and the maximum number of fragments
to return (defaults to <code class="literal">5</code>).
For example:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
    "query" : {
        "match": { "user": "kimchy" }
    },
    "highlight" : {
        "fields" : {
            "content" : {"fragment_size" : 150, "number_of_fragments" : 3}
        }
    }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/248.console"></div>
<p>The <code class="literal">fragment_size</code> is ignored when using the postings highlighter, as it
outputs sentences regardless of their length.</p>
<p>On top of this it is possible to specify that highlighted fragments need
to be sorted by score:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
    "query" : {
        "match": { "user": "kimchy" }
    },
    "highlight" : {
        "order" : "score",
        "fields" : {
            "content" : {"fragment_size" : 150, "number_of_fragments" : 3}
        }
    }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/249.console"></div>
<p>If the <code class="literal">number_of_fragments</code> value is set to <code class="literal">0</code> then no fragments are
produced, instead the whole content of the field is returned, and of
course it is highlighted. This can be very handy if short texts (like
document title or address) need to be highlighted but no fragmentation
is required. Note that <code class="literal">fragment_size</code> is ignored in this case.</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
    "query" : {
        "match": { "user": "kimchy" }
    },
    "highlight" : {
        "fields" : {
            "_all" : {},
            "bio.title" : {"number_of_fragments" : 0}
        }
    }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/250.console"></div>
<p>When using <code class="literal">fvh</code> one can use <code class="literal">fragment_offset</code>
parameter to control the margin to start highlighting from.</p>
<p>In the case where there is no matching fragment to highlight, the default is
to not return anything. Instead, we can return a snippet of text from the
beginning of the field by setting <code class="literal">no_match_size</code> (default <code class="literal">0</code>) to the length
of the text that you want returned. The actual length may be shorter or longer than
specified as it tries to break on a word boundary. When using the postings
highlighter it is not possible to control the actual size of the snippet,
therefore the first sentence gets returned whenever <code class="literal">no_match_size</code> is
greater than <code class="literal">0</code>.</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
    "query" : {
        "match": { "user": "kimchy" }
    },
    "highlight" : {
        "fields" : {
            "content" : {
                "fragment_size" : 150,
                "number_of_fragments" : 3,
                "no_match_size": 150
            }
        }
    }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/251.console"></div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_fragmenter"></a>Fragmenter<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch/edit/5.4/docs/reference/search/request/highlighting.asciidoc">edit</a></h3>
</div></div></div>
<p>Fragmenter can control how text should be broken up in highlight snippets.
However, this option is applicable only for the Plain Highlighter.
There are two options:</p>
<div class="informaltable">
<table border="0" cellpadding="4px">
<colgroup>
<col/>
<col/>
</colgroup>
<tbody valign="top">
<tr>
<td valign="top">
<p>
<code class="literal">simple</code>
</p>
</td>
<td valign="top">
<p>
Breaks up text into same sized fragments.
</p>
</td>
</tr>
<tr>
<td valign="top">
<p>
<code class="literal">span</code>
</p>
</td>
<td valign="top">
<p>
Same as the simple fragmenter, but tries not to break up text between highlighted terms (this is applicable when using phrase like queries). This is the default.
</p>
</td>
</tr>
</tbody>
</table>
</div>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET twitter/tweet/_search
{
    "query" : {
        "match_phrase": { "message": "number 1" }
    },
    "highlight" : {
        "fields" : {
            "message" : {
                "fragment_size" : 15,
                "number_of_fragments" : 3,
                "fragmenter": "simple"
            }
        }
    }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/252.console"></div>
<p>Response:</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">{
    ...
    "hits": {
        "total": 1,
        "max_score": 1.4818809,
        "hits": [
            {
                "_index": "twitter",
                "_type": "tweet",
                "_id": "1",
                "_score": 1.4818809,
                "_source": {
                    "user": "test",
                    "message": "some message with the number 1",
                    "date": "2009-11-15T14:12:12",
                    "likes": 1
                },
                "highlight": {
                    "message": [
                        " with the &lt;em&gt;number&lt;/em&gt;",
                        " &lt;em&gt;1&lt;/em&gt;"
                    ]
                }
            }
        ]
    }
}</pre>
</div>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET twitter/tweet/_search
{
    "query" : {
        "match_phrase": { "message": "number 1" }
    },
    "highlight" : {
        "fields" : {
            "message" : {
                "fragment_size" : 15,
                "number_of_fragments" : 3,
                "fragmenter": "span"
            }
        }
    }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/253.console"></div>
<p>Response:</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">{
    ...
    "hits": {
        "total": 1,
        "max_score": 1.4818809,
        "hits": [
            {
                "_index": "twitter",
                "_type": "tweet",
                "_id": "1",
                "_score": 1.4818809,
                "_source": {
                    "user": "test",
                    "message": "some message with the number 1",
                    "date": "2009-11-15T14:12:12",
                    "likes": 1
                },
                "highlight": {
                    "message": [
                        "some message with the &lt;em&gt;number&lt;/em&gt; &lt;em&gt;1&lt;/em&gt;"
                    ]
                }
            }
        ]
    }
}</pre>
</div>
<p>If the <code class="literal">number_of_fragments</code> option is set to <code class="literal">0</code>,
<code class="literal">NullFragmenter</code> is used which does not fragment the text at all.
This is useful for highlighting the entire content of a document or field.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_highlight_query"></a>Highlight query<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch/edit/5.4/docs/reference/search/request/highlighting.asciidoc">edit</a></h3>
</div></div></div>
<p>It is also possible to highlight against a query other than the search
query by setting <code class="literal">highlight_query</code>.  This is especially useful if you
use a rescore query because those are not taken into account by
highlighting by default.  Elasticsearch does not validate that
<code class="literal">highlight_query</code> contains the search query in any way so it is possible
to define it so legitimate query results aren&#8217;t highlighted at all.
Generally it is better to include the search query in the
<code class="literal">highlight_query</code>.  Here is an example of including both the search
query and the rescore query in <code class="literal">highlight_query</code>.</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
    "stored_fields": [ "_id" ],
    "query" : {
        "match": {
            "content": {
                "query": "foo bar"
            }
        }
    },
    "rescore": {
        "window_size": 50,
        "query": {
            "rescore_query" : {
                "match_phrase": {
                    "content": {
                        "query": "foo bar",
                        "slop": 1
                    }
                }
            },
            "rescore_query_weight" : 10
        }
    },
    "highlight" : {
        "order" : "score",
        "fields" : {
            "content" : {
                "fragment_size" : 150,
                "number_of_fragments" : 3,
                "highlight_query": {
                    "bool": {
                        "must": {
                            "match": {
                                "content": {
                                    "query": "foo bar"
                                }
                            }
                        },
                        "should": {
                            "match_phrase": {
                                "content": {
                                    "query": "foo bar",
                                    "slop": 1,
                                    "boost": 10.0
                                }
                            }
                        },
                        "minimum_should_match": 0
                    }
                }
            }
        }
    }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/254.console"></div>
<p>Note that the score of text fragment in this case is calculated by the Lucene
highlighting framework. For implementation details you can check the
<code class="literal">ScoreOrderFragmentsBuilder.java</code> class. On the other hand when using the
postings highlighter the fragments are scored using, as mentioned above,
the BM25 algorithm.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="highlighting-settings"></a>Global Settings<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch/edit/5.4/docs/reference/search/request/highlighting.asciidoc">edit</a></h3>
</div></div></div>
<p>Highlighting settings can be set on a global level and then overridden
at the field level.</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
    "query" : {
        "match": { "user": "kimchy" }
    },
    "highlight" : {
        "number_of_fragments" : 3,
        "fragment_size" : 150,
        "fields" : {
            "_all" : { "pre_tags" : ["&lt;em&gt;"], "post_tags" : ["&lt;/em&gt;"] },
            "bio.title" : { "number_of_fragments" : 0 },
            "bio.author" : { "number_of_fragments" : 0 },
            "bio.content" : { "number_of_fragments" : 5, "order" : "score" }
        }
    }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/255.console"></div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="field-match"></a>Require Field Match<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch/edit/5.4/docs/reference/search/request/highlighting.asciidoc">edit</a></h3>
</div></div></div>
<p><code class="literal">require_field_match</code> can be set to <code class="literal">false</code> which will cause any field to
be highlighted regardless of whether the query matched specifically on them.
The default behaviour is <code class="literal">true</code>, meaning that only fields that hold a query
match will be highlighted.</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
    "query" : {
        "match": { "user": "kimchy" }
    },
    "highlight" : {
        "require_field_match": false,
        "fields": {
                "_all" : { "pre_tags" : ["&lt;em&gt;"], "post_tags" : ["&lt;/em&gt;"] }
        }
    }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/256.console"></div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="boundary-scanners"></a>Boundary Scanners<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch/edit/5.4/docs/reference/search/request/highlighting.asciidoc">edit</a></h3>
</div></div></div>
<p>When highlighting a field using the unified highlighter or the fast vector highlighter,
you can specify how to break the highlighted fragments using <code class="literal">boundary_scanner</code>, which accepts
the following values:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
<code class="literal">chars</code> (default mode for the FVH): allows to configure which characters (<code class="literal">boundary_chars</code>)
constitute a boundary for highlighting. It&#8217;s a single string with each boundary
character defined in it (defaults to <code class="literal">.,!? \t\n</code>). It also allows configuring
the <code class="literal">boundary_max_scan</code> to control how far to look for boundary characters
(defaults to <code class="literal">20</code>). Works only with the Fast Vector Highlighter.
</li>
<li class="listitem">
<code class="literal">sentence</code> and <code class="literal">word</code>: use Java&#8217;s <a href="https://docs.oracle.com/javase/8/docs/api/java/text/BreakIterator.html" class="ulink" target="_top">BreakIterator</a>
to break the highlighted fragments at the next  <em>sentence</em> or <em>word</em> boundary.
You can further specify <code class="literal">boundary_scanner_locale</code> to control which Locale is used
to search the text for these boundaries.
</li>
</ul>
</div>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p>When used with the <code class="literal">unified</code> highlighter, the <code class="literal">sentence</code> scanner splits sentence
bigger than <code class="literal">fragment_size</code> at the first word boundary next to <code class="literal">fragment_size</code>.
You can set <code class="literal">fragment_size</code> to 0 to never split any sentence.</p>
</div>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="matched-fields"></a>Matched Fields<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch/edit/5.4/docs/reference/search/request/highlighting.asciidoc">edit</a></h3>
</div></div></div>
<p>The Fast Vector Highlighter can combine matches on multiple fields to
highlight a single field using <code class="literal">matched_fields</code>.  This is most
intuitive for multifields that analyze the same string in different
ways.  All <code class="literal">matched_fields</code> must have <code class="literal">term_vector</code> set to
<code class="literal">with_positions_offsets</code> but only the field to which the matches are
combined is loaded so only that field would benefit from having
<code class="literal">store</code> set to <code class="literal">yes</code>.</p>
<p>In the following examples <code class="literal">content</code> is analyzed by the <code class="literal">english</code>
analyzer and <code class="literal">content.plain</code> is analyzed by the <code class="literal">standard</code> analyzer.</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
    "query": {
        "query_string": {
            "query": "content.plain:running scissors",
            "fields": ["content"]
        }
    },
    "highlight": {
        "order": "score",
        "fields": {
            "content": {
                "matched_fields": ["content", "content.plain"],
                "type" : "fvh"
            }
        }
    }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/257.console"></div>
<p>The above matches both "run with scissors" and "running with scissors"
and would highlight "running" and "scissors" but not "run". If both
phrases appear in a large document then "running with scissors" is
sorted above "run with scissors" in the fragments list because there
are more matches in that fragment.</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
    "query": {
        "query_string": {
            "query": "running scissors",
            "fields": ["content", "content.plain^10"]
        }
    },
    "highlight": {
        "order": "score",
        "fields": {
            "content": {
                "matched_fields": ["content", "content.plain"],
                "type" : "fvh"
            }
        }
    }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/258.console"></div>
<p>The above highlights "run" as well as "running" and "scissors" but
still sorts "running with scissors" above "run with scissors" because
the plain match ("running") is boosted.</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
    "query": {
        "query_string": {
            "query": "running scissors",
            "fields": ["content", "content.plain^10"]
        }
    },
    "highlight": {
        "order": "score",
        "fields": {
            "content": {
                "matched_fields": ["content.plain"],
                "type" : "fvh"
            }
        }
    }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/259.console"></div>
<p>The above query wouldn&#8217;t highlight "run" or "scissor" but shows that
it is just fine not to list the field to which the matches are combined
(<code class="literal">content</code>) in the matched fields.</p>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p>Technically it is also fine to add fields to <code class="literal">matched_fields</code> that
don&#8217;t share the same underlying string as the field to which the matches
are combined.  The results might not make much sense and if one of the
matches is off the end of the text then the whole query will fail.</p>
</div>
</div>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p>There is a small amount of overhead involved with setting
<code class="literal">matched_fields</code> to a non-empty array so always prefer</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">    "highlight": {
        "fields": {
            "content": {}
        }
    }</pre>
</div>
<p>to</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">    "highlight": {
        "fields": {
            "content": {
                "matched_fields": ["content"],
                "type" : "fvh"
            }
        }
    }</pre>
</div>
</div>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="phrase-limit"></a>Phrase Limit<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch/edit/5.4/docs/reference/search/request/highlighting.asciidoc">edit</a></h3>
</div></div></div>
<p>The fast vector highlighter has a <code class="literal">phrase_limit</code> parameter that prevents
it from analyzing too many phrases and eating tons of memory.  It defaults
to 256 so only the first 256 matching phrases in the document scored
considered.  You can raise the limit with the <code class="literal">phrase_limit</code> parameter but
keep in mind that scoring more phrases consumes more time and memory.</p>
<p>If using <code class="literal">matched_fields</code> keep in mind that <code class="literal">phrase_limit</code> phrases per
matched field are considered.</p>
<h3><a id="explicit-field-order"></a>Field Highlight Order<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch/edit/5.4/docs/reference/search/request/highlighting.asciidoc">edit</a></h3>
<p>Elasticsearch highlights the fields in the order that they are sent.  Per the
json spec objects are unordered but if you need to be explicit about the order
that fields are highlighted then you can use an array for <code class="literal">fields</code> like this:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">GET /_search
{
    "highlight": {
        "fields": [
            { "title": {} },
            { "text": {} }
        ]
    }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/260.console"></div>
<p>None of the highlighters built into Elasticsearch care about the order that the
fields are highlighted but a plugin may.</p>
</div>

</div>
<div class="navfooter">
<span class="prev">
<a href="search-request-post-filter.html">« Post filter</a>
</span>
<span class="next">
<a href="search-request-rescore.html">Rescoring »</a>
</span>
</div>
</div>
</body>
</html>
