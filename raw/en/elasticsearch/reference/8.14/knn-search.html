<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>k-nearest neighbor (kNN) search | Elasticsearch Guide [8.14] | Elastic</title>
<meta class="elastic" name="content" content="k-nearest neighbor (kNN) search | Elasticsearch Guide [8.14]">

<link rel="home" href="index.html" title="Elasticsearch Guide [8.14]"/>
<link rel="up" href="search-with-elasticsearch.html" title="Search your data"/>
<link rel="prev" href="search-template.html" title="Search templates"/>
<link rel="next" href="semantic-search.html" title="Semantic search"/>
<meta class="elastic" name="product_version" content="8.14"/>
<meta class="elastic" name="product_name" content="Elasticsearch"/>
<meta class="elastic" name="website_area" content="documentation"/>
<meta name="DC.type" content="Learn/Docs/Elasticsearch/Reference/8.14"/>
<meta name="DC.subject" content="Elasticsearch"/>
<meta name="DC.identifier" content="8.14"/>
</head>
<body>
<div class="navheader">
<span class="prev">
<a href="search-template.html">« Search templates</a>
</span>
<span class="next">
<a href="semantic-search.html">Semantic search »</a>
</span>
</div>
<div class="book" lang="en">
<div class="titlepage">
<div class="breadcrumbs">
<span class="breadcrumb-link"><a href="/guide/">Elastic Docs</a></span>
<span class="chevron-right">›</span><span class="breadcrumb-link"><a href="index.html">Elasticsearch Guide [8.14]</a></span>
<span class="chevron-right">›</span><span class="breadcrumb-link"><a href="search-with-elasticsearch.html">Search your data</a></span>
</div>
<div>
<div><h1 class="title"><a id="id-1"></a>k-nearest neighbor (kNN) search</h1><a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.14/docs/reference/search/search-your-data/knn-search.asciidoc">edit</a></div>
</div>
<!--EXTRA-->
</div>
<div id="content">
<div class="chapter">
<div class="titlepage"><div><div>
<h2 class="title"><a id="knn-search"></a>k-nearest neighbor (kNN) search<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.14/docs/reference/search/search-your-data/knn-search.asciidoc">edit</a></h2>
</div></div></div>

<p>A <em>k-nearest neighbor</em> (kNN) search finds the <em>k</em> nearest vectors to a query
vector, as measured by a similarity metric.</p>
<p>Common use cases for kNN include:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
Relevance ranking based on natural language processing (NLP) algorithms
</li>
<li class="listitem">
Product recommendations and recommendation engines
</li>
<li class="listitem">
Similarity search for images or videos
</li>
</ul>
</div>
<h3><a id="knn-prereqs"></a>Prerequisites<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.14/docs/reference/search/search-your-data/knn-search.asciidoc">edit</a></h3>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
<p>To run a kNN search, you must be able to convert your data into meaningful
vector values. You can
<a href="/guide/en/machine-learning/8.14/ml-nlp-text-emb-vector-search-example.html" class="ulink" target="_top">create these vectors using
a natural language processing (NLP) model in Elasticsearch</a>, or generate them outside
Elasticsearch. Vectors can be added to documents as <a class="xref" href="dense-vector.html" title="Dense vector field type"><code class="literal">dense_vector</code></a> field
values. Queries are represented as vectors with the same dimension.</p>
<p>Design your vectors so that the closer a document&#8217;s vector is to a query vector,
based on a similarity metric, the better its match.</p>
</li>
<li class="listitem">
<p>To complete the steps in this guide, you must have the following
<a class="xref" href="security-privileges.html#privileges-list-indices" title="Indices privileges">index privileges</a>:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
<code class="literal">create_index</code> or <code class="literal">manage</code> to create an index with a <code class="literal">dense_vector</code> field
</li>
<li class="listitem">
<code class="literal">create</code>, <code class="literal">index</code>, or <code class="literal">write</code> to add data to the index you created
</li>
<li class="listitem">
<code class="literal">read</code> to search the index
</li>
</ul>
</div>
</li>
</ul>
</div>
<h3><a id="knn-methods"></a>kNN methods<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.14/docs/reference/search/search-your-data/knn-search.asciidoc">edit</a></h3>
<p>Elasticsearch supports two methods for kNN search:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
<a class="xref" href="knn-search.html#approximate-knn" title="Approximate kNN">Approximate kNN</a> using the <code class="literal">knn</code> search
option or <code class="literal">knn</code> query
</li>
<li class="listitem">
<a class="xref" href="knn-search.html#exact-knn" title="Exact kNN">Exact, brute-force kNN</a> using a <code class="literal">script_score</code> query with a
vector function
</li>
</ul>
</div>
<p>In most cases, you&#8217;ll want to use approximate kNN. Approximate kNN offers lower
latency at the cost of slower indexing and imperfect accuracy.</p>
<p>Exact, brute-force kNN guarantees accurate results but doesn&#8217;t scale well with
large datasets. With this approach, a <code class="literal">script_score</code> query must scan each
matching document to compute the vector function, which can result in slow
search speeds. However, you can improve latency by using a <a class="xref" href="query-dsl.html" title="Query DSL">query</a>
to limit the number of matching documents passed to the function. If you
filter your data to a small subset of documents, you can get good search
performance using this approach.</p>
<h3><a id="approximate-knn"></a>Approximate kNN<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.14/docs/reference/search/search-your-data/knn-search.asciidoc">edit</a></h3>
<div class="warning admon">
<div class="icon"></div>
<div class="admon_content">
<p>Compared to other types of search, approximate kNN search has specific
resource requirements. In particular, all vector data must fit in the node&#8217;s
page cache for it to be efficient. Please consult the
<a class="xref" href="tune-knn-search.html" title="Tune approximate kNN search">approximate kNN search tuning guide</a> for important notes on
configuration and sizing.</p>
</div>
</div>
<p>To run an approximate kNN search, use the <a class="xref" href="search-search.html#search-api-knn"><code class="literal">knn</code> option</a>
to search one or more <code class="literal">dense_vector</code> fields with indexing enabled.</p>
<div class="olist orderedlist">
<ol class="orderedlist">
<li class="listitem">
<p>Explicitly map one or more <code class="literal">dense_vector</code> fields. Approximate kNN search
requires the following mapping options:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
A <code class="literal">similarity</code> value. This value determines the similarity metric used to
score documents based on similarity between the query and document vector. For a
list of available metrics, see the <a class="xref" href="dense-vector.html#dense-vector-similarity"><code class="literal">similarity</code></a>
parameter documentation. The <code class="literal">similarity</code> setting defaults to <code class="literal">cosine</code>.
</li>
</ul>
</div>
<div class="pre_wrapper lang-ruby alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-ruby alternative">response = client.indices.create(
  index: 'image-index',
  body: {
    mappings: {
      properties: {
        "image-vector": {
          type: 'dense_vector',
          dims: 3,
          similarity: 'l2_norm'
        },
        "title-vector": {
          type: 'dense_vector',
          dims: 5,
          similarity: 'l2_norm'
        },
        title: {
          type: 'text'
        },
        "file-type": {
          type: 'keyword'
        }
      }
    }
  }
)
puts response</pre>
</div>
<a id="dadb69a225778ecd6528924c0aa029bb"></a>
<div class="pre_wrapper lang-console default has-ruby">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-console default has-ruby">PUT image-index
{
  "mappings": {
    "properties": {
      "image-vector": {
        "type": "dense_vector",
        "dims": 3,
        "similarity": "l2_norm"
      },
      "title-vector": {
        "type": "dense_vector",
        "dims": 5,
        "similarity": "l2_norm"
      },
      "title": {
        "type": "text"
      },
      "file-type": {
        "type": "keyword"
      }
    }
  }
}</pre>
</div>
<div class="console_widget has-ruby" data-snippet="snippets/967.console"></div>
</li>
<li class="listitem">
<p>Index your data.</p>
<a id="c9c21191ae15a49955bffde0ac749a49"></a>
<div class="pre_wrapper lang-console">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-console">POST image-index/_bulk?refresh=true
{ "index": { "_id": "1" } }
{ "image-vector": [1, 5, -20], "title-vector": [12, 50, -10, 0, 1], "title": "moose family", "file-type": "jpg" }
{ "index": { "_id": "2" } }
{ "image-vector": [42, 8, -15], "title-vector": [25, 1, 4, -12, 2], "title": "alpine lake", "file-type": "png" }
{ "index": { "_id": "3" } }
{ "image-vector": [15, 11, 23], "title-vector": [1, 5, 25, 50, 20], "title": "full moon", "file-type": "jpg" }
...</pre>
</div>
<div class="console_widget" data-snippet="snippets/968.console"></div>
</li>
<li class="listitem">
<p>Run the search using the <a class="xref" href="search-search.html#search-api-knn"><code class="literal">knn</code> option</a> or the
<a class="xref" href="query-dsl-knn-query.html" title="Knn query"><code class="literal">knn</code> query</a> (expert case).</p>
<div class="pre_wrapper lang-ruby alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-ruby alternative">response = client.search(
  index: 'image-index',
  body: {
    knn: {
      field: 'image-vector',
      query_vector: [
        -5,
        9,
        -12
      ],
      k: 10,
      num_candidates: 100
    },
    fields: [
      'title',
      'file-type'
    ]
  }
)
puts response</pre>
</div>
<a id="9c6ea5fe2339d6c7e5e4bf1b98990248"></a>
<div class="pre_wrapper lang-console default has-ruby">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-console default has-ruby">POST image-index/_search
{
  "knn": {
    "field": "image-vector",
    "query_vector": [-5, 9, -12],
    "k": 10,
    "num_candidates": 100
  },
  "fields": [ "title", "file-type" ]
}</pre>
</div>
<div class="console_widget has-ruby" data-snippet="snippets/969.console"></div>
</li>
</ol>
</div>
<p>The <a class="xref" href="search-search.html#search-api-response-body-score">document <code class="literal">_score</code></a> is determined by
the similarity between the query and document vector. See
<a class="xref" href="dense-vector.html#dense-vector-similarity"><code class="literal">similarity</code></a> for more information on how kNN
search scores are computed.</p>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p>Support for approximate kNN search was added in version 8.0. Before
this, <code class="literal">dense_vector</code> fields did not support enabling <code class="literal">index</code> in the mapping.
If you created an index prior to 8.0 containing <code class="literal">dense_vector</code> fields, then to
support approximate kNN search the data must be reindexed using a new field
mapping that sets <code class="literal">index: true</code> which is the default option.</p>
</div>
</div>
<h4><a id="tune-approximate-knn-for-speed-accuracy"></a>Tune approximate kNN for speed or accuracy<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.14/docs/reference/search/search-your-data/knn-search.asciidoc">edit</a></h4>
<p>To gather results, the kNN search API finds a <code class="literal">num_candidates</code> number of
approximate nearest neighbor candidates on each shard. The search computes the
similarity of these candidate vectors to the query vector, selecting the <code class="literal">k</code>
most similar results from each shard. The search then merges the results from
each shard to return the global top <code class="literal">k</code> nearest neighbors.</p>
<p>You can increase <code class="literal">num_candidates</code> for more accurate results at the cost of
slower search speeds. A search with a high value for <code class="literal">num_candidates</code>
considers more candidates from each shard. This takes more time, but the
search has a higher probability of finding the true <code class="literal">k</code> top nearest neighbors.</p>
<p>Similarly, you can decrease <code class="literal">num_candidates</code> for faster searches with
potentially less accurate results.</p>
<h4><a id="approximate-knn-using-byte-vectors"></a>Approximate kNN using byte vectors<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.14/docs/reference/search/search-your-data/knn-search.asciidoc">edit</a></h4>
<p>The approximate kNN search API supports <code class="literal">byte</code> value vectors in
addition to <code class="literal">float</code> value vectors. Use the <a class="xref" href="search-search.html#search-api-knn"><code class="literal">knn</code> option</a>
to search a <code class="literal">dense_vector</code> field with <a class="xref" href="dense-vector.html#dense-vector-params" title="Parameters for dense vector fields"><code class="literal">element_type</code></a> set to
<code class="literal">byte</code> and indexing enabled.</p>
<div class="olist orderedlist">
<ol class="orderedlist">
<li class="listitem">
<p>Explicitly map one or more <code class="literal">dense_vector</code> fields with
<a class="xref" href="dense-vector.html#dense-vector-params" title="Parameters for dense vector fields"><code class="literal">element_type</code></a> set to <code class="literal">byte</code> and indexing enabled.</p>
<div class="pre_wrapper lang-ruby alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-ruby alternative">response = client.indices.create(
  index: 'byte-image-index',
  body: {
    mappings: {
      properties: {
        "byte-image-vector": {
          type: 'dense_vector',
          element_type: 'byte',
          dims: 2
        },
        title: {
          type: 'text'
        }
      }
    }
  }
)
puts response</pre>
</div>
<a id="d8ea6a1a1c546bf29f65f8c65439b156"></a>
<div class="pre_wrapper lang-console default has-ruby">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-console default has-ruby">PUT byte-image-index
{
  "mappings": {
    "properties": {
      "byte-image-vector": {
        "type": "dense_vector",
        "element_type": "byte",
        "dims": 2
      },
      "title": {
        "type": "text"
      }
    }
  }
}</pre>
</div>
<div class="console_widget has-ruby" data-snippet="snippets/970.console"></div>
</li>
<li class="listitem">
<p>Index your data ensuring all vector values
are integers within the range [-128, 127].</p>
<div class="pre_wrapper lang-ruby alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-ruby alternative">response = client.bulk(
  index: 'byte-image-index',
  refresh: true,
  body: [
    {
      index: {
        _id: '1'
      }
    },
    {
      "byte-image-vector": [
        5,
        -20
      ],
      title: 'moose family'
    },
    {
      index: {
        _id: '2'
      }
    },
    {
      "byte-image-vector": [
        8,
        -15
      ],
      title: 'alpine lake'
    },
    {
      index: {
        _id: '3'
      }
    },
    {
      "byte-image-vector": [
        11,
        23
      ],
      title: 'full moon'
    }
  ]
)
puts response</pre>
</div>
<a id="9851f5225150bc032fb3b195cd447f4f"></a>
<div class="pre_wrapper lang-console default has-ruby">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-console default has-ruby">POST byte-image-index/_bulk?refresh=true
{ "index": { "_id": "1" } }
{ "byte-image-vector": [5, -20], "title": "moose family" }
{ "index": { "_id": "2" } }
{ "byte-image-vector": [8, -15], "title": "alpine lake" }
{ "index": { "_id": "3" } }
{ "byte-image-vector": [11, 23], "title": "full moon" }</pre>
</div>
<div class="console_widget has-ruby" data-snippet="snippets/971.console"></div>
</li>
<li class="listitem">
<p>Run the search using the <a class="xref" href="search-search.html#search-api-knn"><code class="literal">knn</code> option</a>
ensuring the <code class="literal">query_vector</code> values are integers within the
range [-128, 127].</p>
<div class="pre_wrapper lang-ruby alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-ruby alternative">response = client.search(
  index: 'byte-image-index',
  body: {
    knn: {
      field: 'byte-image-vector',
      query_vector: [
        -5,
        9
      ],
      k: 10,
      num_candidates: 100
    },
    fields: [
      'title'
    ]
  }
)
puts response</pre>
</div>
<a id="55f0fec6342f677af74de2124b801aa2"></a>
<div class="pre_wrapper lang-console default has-ruby">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-console default has-ruby">POST byte-image-index/_search
{
  "knn": {
    "field": "byte-image-vector",
    "query_vector": [-5, 9],
    "k": 10,
    "num_candidates": 100
  },
  "fields": [ "title" ]
}</pre>
</div>
<div class="console_widget has-ruby" data-snippet="snippets/972.console"></div>
</li>
</ol>
</div>
<p><em>Note</em>: In addition to the standard byte array, one can also provide a hex-encoded string value
for the <code class="literal">query_vector</code> param. As an example, the search request above can also be expressed as follows,
which would yield the same results</p>
<a id="856c10ad554c26b70f1121454caff40a"></a>
<div class="pre_wrapper lang-console">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-console">POST byte-image-index/_search
{
  "knn": {
    "field": "byte-image-vector",
    "query_vector": "fb09",
    "k": 10,
    "num_candidates": 100
  },
  "fields": [ "title" ]
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/973.console"></div>
<h4><a id="knn-search-quantized-example"></a>Byte quantized kNN search<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.14/docs/reference/search/search-your-data/knn-search.asciidoc">edit</a></h4>
<p>If you want to provide <code class="literal">float</code> vectors, but want the memory savings of <code class="literal">byte</code> vectors, you can use the
<a class="xref" href="dense-vector.html#dense-vector-quantization" title="Automatically quantize vectors for kNN search">quantization</a> feature. Quantization allows you to provide <code class="literal">float</code> vectors, but
internally they are indexed as <code class="literal">byte</code> vectors. Additionally, the original <code class="literal">float</code> vectors are still retained
in the index.</p>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p>The default index type for <code class="literal">dense_vector</code> is <code class="literal">int8_hnsw</code>.</p>
</div>
</div>
<p>To use quantization, you can use the index type <code class="literal">int8_hnsw</code> object in the <code class="literal">dense_vector</code> mapping.</p>
<div class="pre_wrapper lang-ruby alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-ruby alternative">response = client.indices.create(
  index: 'quantized-image-index',
  body: {
    mappings: {
      properties: {
        "image-vector": {
          type: 'dense_vector',
          element_type: 'float',
          dims: 2,
          index: true,
          index_options: {
            type: 'int8_hnsw'
          }
        },
        title: {
          type: 'text'
        }
      }
    }
  }
)
puts response</pre>
</div>
<a id="f4ae3f3fbf07a7d39122ac5ac20b9c03"></a>
<div class="pre_wrapper lang-console default has-ruby">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-console default has-ruby">PUT quantized-image-index
{
  "mappings": {
    "properties": {
      "image-vector": {
        "type": "dense_vector",
        "element_type": "float",
        "dims": 2,
        "index": true,
        "index_options": {
          "type": "int8_hnsw"
        }
      },
      "title": {
        "type": "text"
      }
    }
  }
}</pre>
</div>
<div class="console_widget has-ruby" data-snippet="snippets/974.console"></div>
<div class="olist orderedlist">
<ol class="orderedlist">
<li class="listitem">
<p>Index your <code class="literal">float</code> vectors.</p>
<div class="pre_wrapper lang-ruby alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-ruby alternative">response = client.bulk(
  index: 'quantized-image-index',
  refresh: true,
  body: [
    {
      index: {
        _id: '1'
      }
    },
    {
      "image-vector": [
        0.1,
        -2
      ],
      title: 'moose family'
    },
    {
      index: {
        _id: '2'
      }
    },
    {
      "image-vector": [
        0.75,
        -1
      ],
      title: 'alpine lake'
    },
    {
      index: {
        _id: '3'
      }
    },
    {
      "image-vector": [
        1.2,
        0.1
      ],
      title: 'full moon'
    }
  ]
)
puts response</pre>
</div>
<a id="94cd66bf93f99881c1bda547283a0357"></a>
<div class="pre_wrapper lang-console default has-ruby">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-console default has-ruby">POST quantized-image-index/_bulk?refresh=true
{ "index": { "_id": "1" } }
{ "image-vector": [0.1, -2], "title": "moose family" }
{ "index": { "_id": "2" } }
{ "image-vector": [0.75, -1], "title": "alpine lake" }
{ "index": { "_id": "3" } }
{ "image-vector": [1.2, 0.1], "title": "full moon" }</pre>
</div>
<div class="console_widget has-ruby" data-snippet="snippets/975.console"></div>
</li>
<li class="listitem">
<p>Run the search using the <a class="xref" href="search-search.html#search-api-knn"><code class="literal">knn</code> option</a>. When searching, the <code class="literal">float</code> vector is
automatically quantized to a <code class="literal">byte</code> vector.</p>
<div class="pre_wrapper lang-ruby alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-ruby alternative">response = client.search(
  index: 'quantized-image-index',
  body: {
    knn: {
      field: 'image-vector',
      query_vector: [
        0.1,
        -2
      ],
      k: 10,
      num_candidates: 100
    },
    fields: [
      'title'
    ]
  }
)
puts response</pre>
</div>
<a id="c5cc19e48549fbc5327a9d46874bbeee"></a>
<div class="pre_wrapper lang-console default has-ruby">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-console default has-ruby">POST quantized-image-index/_search
{
  "knn": {
    "field": "image-vector",
    "query_vector": [0.1, -2],
    "k": 10,
    "num_candidates": 100
  },
  "fields": [ "title" ]
}</pre>
</div>
<div class="console_widget has-ruby" data-snippet="snippets/976.console"></div>
</li>
</ol>
</div>
<p>Since the original <code class="literal">float</code> vectors are still retained in the index, you can optionally use them for re-scoring. Meaning,
you can search over all the vectors quickly using the <code class="literal">int8_hnsw</code> index and then rescore only the top <code class="literal">k</code> results. This
provides the best of both worlds, fast search and accurate scoring.</p>
<div class="pre_wrapper lang-ruby alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-ruby alternative">response = client.search(
  index: 'quantized-image-index',
  body: {
    knn: {
      field: 'image-vector',
      query_vector: [
        0.1,
        -2
      ],
      k: 15,
      num_candidates: 100
    },
    fields: [
      'title'
    ],
    rescore: {
      window_size: 10,
      query: {
        rescore_query: {
          script_score: {
            query: {
              match_all: {}
            },
            script: {
              source: "cosineSimilarity(params.query_vector, 'image-vector') + 1.0",
              params: {
                query_vector: [
                  0.1,
                  -2
                ]
              }
            }
          }
        }
      }
    }
  }
)
puts response</pre>
</div>
<a id="3a3adae6dbb2c0316a7d98d0a6c1d4f8"></a>
<div class="pre_wrapper lang-console default has-ruby">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-console default has-ruby">POST quantized-image-index/_search
{
  "knn": {
    "field": "image-vector",
    "query_vector": [0.1, -2],
    "k": 15,
    "num_candidates": 100
  },
  "fields": [ "title" ],
  "rescore": {
    "window_size": 10,
    "query": {
      "rescore_query": {
        "script_score": {
          "query": {
            "match_all": {}
          },
          "script": {
            "source": "cosineSimilarity(params.query_vector, 'image-vector') + 1.0",
            "params": {
              "query_vector": [0.1, -2]
            }
          }
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget has-ruby" data-snippet="snippets/977.console"></div>
<h4><a id="knn-search-filter-example"></a>Filtered kNN search<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.14/docs/reference/search/search-your-data/knn-search.asciidoc">edit</a></h4>
<p>The kNN search API supports restricting the search using a filter. The search
will return the top <code class="literal">k</code> documents that also match the filter query.</p>
<p>The following request performs an approximate kNN search filtered by the
<code class="literal">file-type</code> field:</p>
<div class="pre_wrapper lang-ruby alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-ruby alternative">response = client.search(
  index: 'image-index',
  body: {
    knn: {
      field: 'image-vector',
      query_vector: [
        54,
        10,
        -2
      ],
      k: 5,
      num_candidates: 50,
      filter: {
        term: {
          "file-type": 'png'
        }
      }
    },
    fields: [
      'title'
    ],
    _source: false
  }
)
puts response</pre>
</div>
<a id="621f4553e24592d40c8cdbbdfaeb027e"></a>
<div class="pre_wrapper lang-console default has-ruby">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-console default has-ruby">POST image-index/_search
{
  "knn": {
    "field": "image-vector",
    "query_vector": [54, 10, -2],
    "k": 5,
    "num_candidates": 50,
    "filter": {
      "term": {
        "file-type": "png"
      }
    }
  },
  "fields": ["title"],
  "_source": false
}</pre>
</div>
<div class="console_widget has-ruby" data-snippet="snippets/978.console"></div>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p>The filter is applied <span class="strong strong"><strong>during</strong></span> the approximate kNN search to ensure
that <code class="literal">k</code> matching documents are returned. This contrasts with a
post-filtering approach, where the filter is applied <span class="strong strong"><strong>after</strong></span> the approximate
kNN search completes. Post-filtering has the downside that it sometimes
returns fewer than k results, even when there are enough matching documents.</p>
</div>
</div>
<h4><a id="approximate-knn-search-and-filtering"></a>Approximate kNN search and filtering<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.14/docs/reference/search/search-your-data/knn-search.asciidoc">edit</a></h4>
<p>Unlike conventional query filtering, where more restrictive filters typically lead to faster queries,
applying filters in an approximate kNN search with an HNSW index can decrease performance.
This is because searching the HNSW graph requires additional exploration to obtain the <code class="literal">num_candidates</code>
that meet the filter criteria.</p>
<p>To avoid significant performance drawbacks, Lucene implements the following strategies per segment:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
If the filtered document count is less than or equal to num_candidates, the search bypasses the HNSW graph and
uses a brute force search on the filtered documents.
</li>
<li class="listitem">
While exploring the HNSW graph, if the number of nodes explored exceeds the number of documents that satisfy the filter,
the search will stop exploring the graph and switch to a brute force search over the filtered documents.
</li>
</ul>
</div>
<h4><a id="_combine_approximate_knn_with_other_features"></a>Combine approximate kNN with other features<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.14/docs/reference/search/search-your-data/knn-search.asciidoc">edit</a></h4>
<p>You can perform <em>hybrid retrieval</em> by providing both the
<a class="xref" href="search-search.html#search-api-knn"><code class="literal">knn</code> option</a> and a <a class="xref" href="search-search.html#request-body-search-query"><code class="literal">query</code></a>:</p>
<div class="pre_wrapper lang-ruby alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-ruby alternative">response = client.search(
  index: 'image-index',
  body: {
    query: {
      match: {
        title: {
          query: 'mountain lake',
          boost: 0.9
        }
      }
    },
    knn: {
      field: 'image-vector',
      query_vector: [
        54,
        10,
        -2
      ],
      k: 5,
      num_candidates: 50,
      boost: 0.1
    },
    size: 10
  }
)
puts response</pre>
</div>
<a id="c6abe91b5527870face2b826f37ba1da"></a>
<div class="pre_wrapper lang-console default has-ruby">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-console default has-ruby">POST image-index/_search
{
  "query": {
    "match": {
      "title": {
        "query": "mountain lake",
        "boost": 0.9
      }
    }
  },
  "knn": {
    "field": "image-vector",
    "query_vector": [54, 10, -2],
    "k": 5,
    "num_candidates": 50,
    "boost": 0.1
  },
  "size": 10
}</pre>
</div>
<div class="console_widget has-ruby" data-snippet="snippets/979.console"></div>
<p>This search finds the global top <code class="literal">k = 5</code> vector matches, combines them with the matches from the <code class="literal">match</code> query, and
finally returns the 10 top-scoring results. The <code class="literal">knn</code> and <code class="literal">query</code> matches are combined through a disjunction, as if you
took a boolean <em>or</em> between them. The top <code class="literal">k</code> vector results represent the global nearest neighbors across all index
shards.</p>
<p>The score of each hit is the sum of the <code class="literal">knn</code> and <code class="literal">query</code> scores. You can specify a <code class="literal">boost</code> value to give a weight to
each score in the sum. In the example above, the scores will be calculated as</p>
<pre class="screen">score = 0.9 * match_score + 0.1 * knn_score</pre>
<p>The <code class="literal">knn</code> option can also be used with <a class="xref" href="search-aggregations.html" title="Aggregations"><code class="literal">aggregations</code></a>.
In general, Elasticsearch computes aggregations over all documents that match the search.
So for approximate kNN search, aggregations are calculated on the top <code class="literal">k</code>
nearest documents. If the search also includes a <code class="literal">query</code>, then aggregations are
calculated on the combined set of <code class="literal">knn</code> and <code class="literal">query</code> matches.</p>
<h4><a id="knn-semantic-search"></a>Perform semantic search<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.14/docs/reference/search/search-your-data/knn-search.asciidoc">edit</a></h4>
<p>kNN search enables you to perform semantic search by using a previously deployed
<a href="/guide/en/machine-learning/8.14/ml-nlp-search-compare.html#ml-nlp-text-embedding" class="ulink" target="_top">text embedding model</a>.
Instead of literal matching on search terms, semantic search retrieves results
based on the intent and the contextual meaning of a search query.</p>
<p>Under the hood, the text embedding NLP model generates a dense vector from the
input query string called <code class="literal">model_text</code> you provide. Then, it is searched
against an index containing dense vectors created with the same text embedding
machine learning model. The search results are semantically similar as learned by the model.</p>
<div class="important admon">
<div class="icon"></div>
<div class="admon_content">
<p>To perform semantic search:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
you need an index that contains the dense vector representation of the input
data to search against,
</li>
<li class="listitem">
you must use the same text embedding model for search that you used to create
the dense vectors from the input data,
</li>
<li class="listitem">
the text embedding NLP model deployment must be started.
</li>
</ul>
</div>
</div>
</div>
<p>Reference the deployed text embedding model or the model deployment in the
<code class="literal">query_vector_builder</code> object and provide the search query as <code class="literal">model_text</code>:</p>
<div class="pre_wrapper lang-js">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-js">(...)
{
  "knn": {
    "field": "dense-vector-field",
    "k": 10,
    "num_candidates": 100,
    "query_vector_builder": {
      "text_embedding": { <a id="CO227-1"></a><i class="conum" data-value="1"></i>
        "model_id": "my-text-embedding-model", <a id="CO227-2"></a><i class="conum" data-value="2"></i>
        "model_text": "The opposite of blue" <a id="CO227-3"></a><i class="conum" data-value="3"></i>
      }
    }
  }
}
(...)</pre>
</div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO227-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>The natural language processing task to perform. It must be <code class="literal">text_embedding</code>.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO227-2"><i class="conum" data-value="2"></i></a></p>
</td>
<td align="left" valign="top">
<p>The ID of the text embedding model to use to generate the dense vectors from
the query string. Use the same model that generated the embeddings from the
input text in the index you search against. You can use the value of the
<code class="literal">deployment_id</code> instead in the <code class="literal">model_id</code> argument.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO227-3"><i class="conum" data-value="3"></i></a></p>
</td>
<td align="left" valign="top">
<p>The query string from which the model generates the dense vector
representation.</p>
</td>
</tr>
</table>
</div>
<p>For more information on how to deploy a trained model and use it to create text
embeddings, refer to this
<a href="/guide/en/machine-learning/8.14/ml-nlp-text-emb-vector-search-example.html" class="ulink" target="_top">end-to-end example</a>.</p>
<h4><a id="_search_multiple_knn_fields"></a>Search multiple kNN fields<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.14/docs/reference/search/search-your-data/knn-search.asciidoc">edit</a></h4>
<p>In addition to <em>hybrid retrieval</em>, you can search more than one kNN vector field at a time:</p>
<div class="pre_wrapper lang-ruby alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-ruby alternative">response = client.search(
  index: 'image-index',
  body: {
    query: {
      match: {
        title: {
          query: 'mountain lake',
          boost: 0.9
        }
      }
    },
    knn: [
      {
        field: 'image-vector',
        query_vector: [
          54,
          10,
          -2
        ],
        k: 5,
        num_candidates: 50,
        boost: 0.1
      },
      {
        field: 'title-vector',
        query_vector: [
          1,
          20,
          -52,
          23,
          10
        ],
        k: 10,
        num_candidates: 10,
        boost: 0.5
      }
    ],
    size: 10
  }
)
puts response</pre>
</div>
<a id="7021ddb273a3a00847324d2f670c4c04"></a>
<div class="pre_wrapper lang-console default has-ruby">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-console default has-ruby">POST image-index/_search
{
  "query": {
    "match": {
      "title": {
        "query": "mountain lake",
        "boost": 0.9
      }
    }
  },
  "knn": [ {
    "field": "image-vector",
    "query_vector": [54, 10, -2],
    "k": 5,
    "num_candidates": 50,
    "boost": 0.1
  },
  {
    "field": "title-vector",
    "query_vector": [1, 20, -52, 23, 10],
    "k": 10,
    "num_candidates": 10,
    "boost": 0.5
  }],
  "size": 10
}</pre>
</div>
<div class="console_widget has-ruby" data-snippet="snippets/980.console"></div>
<p>This search finds the global top <code class="literal">k = 5</code> vector matches for <code class="literal">image-vector</code> and the global <code class="literal">k = 10</code> for the <code class="literal">title-vector</code>.
These top values are then combined with the matches from the <code class="literal">match</code> query and the top-10 documents are returned.
The multiple <code class="literal">knn</code> entries and the <code class="literal">query</code> matches are combined through a disjunction,
as if you took a boolean <em>or</em> between them. The top <code class="literal">k</code> vector results represent the global nearest neighbors across
all index shards.</p>
<p>The scoring for a doc with the above configured boosts would be:</p>
<pre class="screen">score = 0.9 * match_score + 0.1 * knn_score_image-vector + 0.5 * knn_score_title-vector</pre>
<h4><a id="knn-similarity-search"></a>Search kNN with expected similarity<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.14/docs/reference/search/search-your-data/knn-search.asciidoc">edit</a></h4>
<p>While kNN is a powerful tool, it always tries to return <code class="literal">k</code> nearest neighbors. Consequently, when using <code class="literal">knn</code> with
a <code class="literal">filter</code>, you could filter out all relevant documents and only have irrelevant ones left to search. In that situation,
<code class="literal">knn</code> will still do its best to return <code class="literal">k</code> nearest neighbors, even though those neighbors could be far away in the
vector space.</p>
<p>To alleviate this worry, there is a <code class="literal">similarity</code> parameter available in the <code class="literal">knn</code> clause. This value is the required
minimum similarity for a vector to be considered a match. The <code class="literal">knn</code> search flow with this parameter is as follows:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
Apply any user provided <code class="literal">filter</code> queries
</li>
<li class="listitem">
Explore the vector space to get <code class="literal">k</code> vectors
</li>
<li class="listitem">
Do not return any vectors that are further away than the configured <code class="literal">similarity</code>
</li>
</ul>
</div>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p><code class="literal">similarity</code> is the true <a class="xref" href="dense-vector.html#dense-vector-similarity">similarity</a> before it has been transformed into <code class="literal">_score</code> and boost applied.</p>
</div>
</div>
<p>For each configured <a class="xref" href="dense-vector.html#dense-vector-similarity">similarity</a>, here is the corresponding inverted <code class="literal">_score</code> function. This is so if you are wanting to filter from a <code class="literal">_score</code> perspective, you can do this minor transformation to correctly reject irrelevant results.</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
<code class="literal">l2_norm</code>: <code class="literal">sqrt((1 / _score) - 1)</code>
</li>
<li class="listitem">
<code class="literal">cosine</code>: <code class="literal">(2 * _score) - 1</code>
</li>
<li class="listitem">
<code class="literal">dot_product</code>: <code class="literal">(2 * _score) - 1</code>
</li>
<li class="listitem">
<p><code class="literal">max_inner_product</code>:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
<code class="literal">_score &lt; 1</code>: <code class="literal">1 - (1 / _score)</code>
</li>
<li class="listitem">
<code class="literal">_score &gt;= 1</code>: <code class="literal">_score - 1</code>
</li>
</ul>
</div>
</li>
</ul>
</div>
<p>Here is an example. In this example we search for the given <code class="literal">query_vector</code> for <code class="literal">k</code> nearest neighbors. However, with
<code class="literal">filter</code> applied and requiring that the found vectors have at least the provided <code class="literal">similarity</code> between them.</p>
<div class="pre_wrapper lang-ruby alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-ruby alternative">response = client.search(
  index: 'image-index',
  body: {
    knn: {
      field: 'image-vector',
      query_vector: [
        1,
        5,
        -20
      ],
      k: 5,
      num_candidates: 50,
      similarity: 36,
      filter: {
        term: {
          "file-type": 'png'
        }
      }
    },
    fields: [
      'title'
    ],
    _source: false
  }
)
puts response</pre>
</div>
<a id="2bc57cd3f32b59b0b44ca63b19cdfcc0"></a>
<div class="pre_wrapper lang-console default has-ruby">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-console default has-ruby">POST image-index/_search
{
  "knn": {
    "field": "image-vector",
    "query_vector": [1, 5, -20],
    "k": 5,
    "num_candidates": 50,
    "similarity": 36,
    "filter": {
      "term": {
        "file-type": "png"
      }
    }
  },
  "fields": ["title"],
  "_source": false
}</pre>
</div>
<div class="console_widget has-ruby" data-snippet="snippets/981.console"></div>
<p>In our data set, the only document with the file type of <code class="literal">png</code> has a vector of <code class="literal">[42, 8, -15]</code>. The <code class="literal">l2_norm</code> distance
between <code class="literal">[42, 8, -15]</code> and <code class="literal">[1, 5, -20]</code> is <code class="literal">41.412</code>, which is greater than the configured similarity of <code class="literal">36</code>. Meaning,
this search will return no hits.</p>
<h4><a id="nested-knn-search"></a>Nested kNN Search<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.14/docs/reference/search/search-your-data/knn-search.asciidoc">edit</a></h4>
<p>It is common for text to exceed a particular model&#8217;s token limit and requires chunking before building the embeddings
for individual chunks. When using <a class="xref" href="nested.html" title="Nested field type"><code class="literal">nested</code></a> with <a class="xref" href="dense-vector.html" title="Dense vector field type"><code class="literal">dense_vector</code></a>, you can achieve nearest
passage retrieval without copying top-level document metadata.</p>
<p>Here is a simple passage vectors index that stores vectors and some top-level metadata for filtering.</p>
<a id="186a7143d50e8c3ee01094e1a9ff0c0c"></a>
<div class="pre_wrapper lang-console">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-console">PUT passage_vectors
{
    "mappings": {
        "properties": {
            "full_text": {
                "type": "text"
            },
            "creation_time": {
                "type": "date"
            },
            "paragraph": {
                "type": "nested",
                "properties": {
                    "vector": {
                        "type": "dense_vector",
                        "dims": 2,
                        "index_options": {
                            "type": "hnsw"
                        }
                    },
                    "text": {
                        "type": "text",
                        "index": false
                    }
                }
            }
        }
    }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/982.console"></div>
<p>With the above mapping, we can index multiple passage vectors along with storing the individual passage text.</p>
<div class="pre_wrapper lang-ruby alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-ruby alternative">response = client.bulk(
  index: 'passage_vectors',
  refresh: true,
  body: [
    {
      index: {
        _id: '1'
      }
    },
    {
      full_text: 'first paragraph another paragraph',
      creation_time: '2019-05-04',
      paragraph: [
        {
          vector: [
            0.45,
            45
          ],
          text: 'first paragraph',
          paragraph_id: '1'
        },
        {
          vector: [
            0.8,
            0.6
          ],
          text: 'another paragraph',
          paragraph_id: '2'
        }
      ]
    },
    {
      index: {
        _id: '2'
      }
    },
    {
      full_text: 'number one paragraph number two paragraph',
      creation_time: '2020-05-04',
      paragraph: [
        {
          vector: [
            1.2,
            4.5
          ],
          text: 'number one paragraph',
          paragraph_id: '1'
        },
        {
          vector: [
            -1,
            42
          ],
          text: 'number two paragraph',
          paragraph_id: '2'
        }
      ]
    }
  ]
)
puts response</pre>
</div>
<a id="2009f2d1ba0780a799a0fdce889c9739"></a>
<div class="pre_wrapper lang-console default has-ruby">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-console default has-ruby">POST passage_vectors/_bulk?refresh=true
{ "index": { "_id": "1" } }
{ "full_text": "first paragraph another paragraph", "creation_time": "2019-05-04", "paragraph": [ { "vector": [ 0.45, 45 ], "text": "first paragraph", "paragraph_id": "1" }, { "vector": [ 0.8, 0.6 ], "text": "another paragraph", "paragraph_id": "2" } ] }
{ "index": { "_id": "2" } }
{ "full_text": "number one paragraph number two paragraph", "creation_time": "2020-05-04", "paragraph": [ { "vector": [ 1.2, 4.5 ], "text": "number one paragraph", "paragraph_id": "1" }, { "vector": [ -1, 42 ], "text": "number two paragraph", "paragraph_id": "2" } ] }</pre>
</div>
<div class="console_widget has-ruby" data-snippet="snippets/983.console"></div>
<p>The query will seem very similar to a typical kNN search:</p>
<div class="pre_wrapper lang-ruby alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-ruby alternative">response = client.search(
  index: 'passage_vectors',
  body: {
    fields: [
      'full_text',
      'creation_time'
    ],
    _source: false,
    knn: {
      query_vector: [
        0.45,
        45
      ],
      field: 'paragraph.vector',
      k: 2,
      num_candidates: 2
    }
  }
)
puts response</pre>
</div>
<a id="1d746272a7511bf91302a15b5c58ca0e"></a>
<div class="pre_wrapper lang-console default has-ruby">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-console default has-ruby">POST passage_vectors/_search
{
    "fields": ["full_text", "creation_time"],
    "_source": false,
    "knn": {
        "query_vector": [
            0.45,
            45
        ],
        "field": "paragraph.vector",
        "k": 2,
        "num_candidates": 2
    }
}</pre>
</div>
<div class="console_widget has-ruby" data-snippet="snippets/984.console"></div>
<p>Note below that even though we have 4 total vectors, we still return two documents. kNN search over nested dense_vectors
will always diversify the top results over the top-level document. Meaning, <code class="literal">"k"</code> top-level documents will be returned,
scored by their nearest passage vector (e.g. <code class="literal">"paragraph.vector"</code>).</p>
<a id="bc2c4a47c4c8927d0cdeb925b2fdb767"></a>
<div class="pre_wrapper lang-console-result">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-console-result">{
    "took": 4,
    "timed_out": false,
    "_shards": {
        "total": 1,
        "successful": 1,
        "skipped": 0,
        "failed": 0
    },
    "hits": {
        "total": {
            "value": 2,
            "relation": "eq"
        },
        "max_score": 1.0,
        "hits": [
            {
                "_index": "passage_vectors",
                "_id": "1",
                "_score": 1.0,
                "fields": {
                    "creation_time": [
                        "2019-05-04T00:00:00.000Z"
                    ],
                    "full_text": [
                        "first paragraph another paragraph"
                    ]
                }
            },
            {
                "_index": "passage_vectors",
                "_id": "2",
                "_score": 0.9997144,
                "fields": {
                    "creation_time": [
                        "2020-05-04T00:00:00.000Z"
                    ],
                    "full_text": [
                        "number one paragraph number two paragraph"
                    ]
                }
            }
        ]
    }
}</pre>
</div>
<p>What if you wanted to filter by some top-level document metadata? You can do this by adding <code class="literal">filter</code> to your
<code class="literal">knn</code> clause.</p>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p><code class="literal">filter</code> will always be over the top-level document metadata. This means you cannot filter based on <code class="literal">nested</code>
      field metadata.</p>
</div>
</div>
<div class="pre_wrapper lang-ruby alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-ruby alternative">response = client.search(
  index: 'passage_vectors',
  body: {
    fields: [
      'creation_time',
      'full_text'
    ],
    _source: false,
    knn: {
      query_vector: [
        0.45,
        45
      ],
      field: 'paragraph.vector',
      k: 2,
      num_candidates: 2,
      filter: {
        bool: {
          filter: [
            {
              range: {
                creation_time: {
                  gte: '2019-05-01',
                  lte: '2019-05-05'
                }
              }
            }
          ]
        }
      }
    }
  }
)
puts response</pre>
</div>
<a id="20407c847adb8393ce41dc656384afc4"></a>
<div class="pre_wrapper lang-console default has-ruby">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-console default has-ruby">POST passage_vectors/_search
{
    "fields": [
        "creation_time",
        "full_text"
    ],
    "_source": false,
    "knn": {
        "query_vector": [
            0.45,
            45
        ],
        "field": "paragraph.vector",
        "k": 2,
        "num_candidates": 2,
        "filter": {
            "bool": {
                "filter": [
                    {
                        "range": {
                            "creation_time": {
                                "gte": "2019-05-01",
                                "lte": "2019-05-05"
                            }
                        }
                    }
                ]
            }
        }
    }
}</pre>
</div>
<div class="console_widget has-ruby" data-snippet="snippets/985.console"></div>
<p>Now we have filtered based on the top level <code class="literal">"creation_time"</code> and only one document falls within that range.</p>
<a id="86d36759a598029396658a8408cb4290"></a>
<div class="pre_wrapper lang-console-result">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-console-result">{
    "took": 4,
    "timed_out": false,
    "_shards": {
        "total": 1,
        "successful": 1,
        "skipped": 0,
        "failed": 0
    },
    "hits": {
        "total": {
            "value": 1,
            "relation": "eq"
        },
        "max_score": 1.0,
        "hits": [
            {
                "_index": "passage_vectors",
                "_id": "1",
                "_score": 1.0,
                "fields": {
                    "creation_time": [
                        "2019-05-04T00:00:00.000Z"
                    ],
                    "full_text": [
                        "first paragraph another paragraph"
                    ]
                }
            }
        ]
    }
}</pre>
</div>
<h4><a id="nested-knn-search-inner-hits"></a>Nested kNN Search with Inner hits<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.14/docs/reference/search/search-your-data/knn-search.asciidoc">edit</a></h4>
<p>Additionally, if you wanted to extract the nearest passage for a matched document, you can supply <a class="xref" href="inner-hits.html" title="Retrieve inner hits">inner_hits</a>
to the <code class="literal">knn</code> clause.</p>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p>When using <code class="literal">inner_hits</code> and multiple <code class="literal">knn</code> clauses, be sure to specify the <a class="xref" href="inner-hits.html#inner-hits-options" title="Options"><code class="literal">inner_hits.name</code></a>
field. Otherwise, a naming clash can occur and fail the search request.</p>
</div>
</div>
<a id="908326e14ad76c2ff04a9b6d8365751f"></a>
<div class="pre_wrapper lang-console">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-console">POST passage_vectors/_search
{
    "fields": [
        "creation_time",
        "full_text"
    ],
    "_source": false,
    "knn": {
        "query_vector": [
            0.45,
            45
        ],
        "field": "paragraph.vector",
        "k": 2,
        "num_candidates": 2,
        "inner_hits": {
            "_source": false,
            "fields": [
                "paragraph.text"
            ],
            "size": 1
        }
    }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/986.console"></div>
<p>Now the result will contain the nearest found paragraph when searching.</p>
<a id="ec8d86c912b4ec121266603911ceaee2"></a>
<div class="pre_wrapper lang-console-result">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-console-result">{
    "took": 4,
    "timed_out": false,
    "_shards": {
        "total": 1,
        "successful": 1,
        "skipped": 0,
        "failed": 0
    },
    "hits": {
        "total": {
            "value": 2,
            "relation": "eq"
        },
        "max_score": 1.0,
        "hits": [
            {
                "_index": "passage_vectors",
                "_id": "1",
                "_score": 1.0,
                "fields": {
                    "creation_time": [
                        "2019-05-04T00:00:00.000Z"
                    ],
                    "full_text": [
                        "first paragraph another paragraph"
                    ]
                },
                "inner_hits": {
                    "paragraph": {
                        "hits": {
                            "total": {
                                "value": 2,
                                "relation": "eq"
                            },
                            "max_score": 1.0,
                            "hits": [
                                {
                                    "_index": "passage_vectors",
                                    "_id": "1",
                                    "_nested": {
                                        "field": "paragraph",
                                        "offset": 0
                                    },
                                    "_score": 1.0,
                                    "fields": {
                                        "paragraph": [
                                            {
                                                "text": [
                                                    "first paragraph"
                                                ]
                                            }
                                        ]
                                    }
                                }
                            ]
                        }
                    }
                }
            },
            {
                "_index": "passage_vectors",
                "_id": "2",
                "_score": 0.9997144,
                "fields": {
                    "creation_time": [
                        "2020-05-04T00:00:00.000Z"
                    ],
                    "full_text": [
                        "number one paragraph number two paragraph"
                    ]
                },
                "inner_hits": {
                    "paragraph": {
                        "hits": {
                            "total": {
                                "value": 2,
                                "relation": "eq"
                            },
                            "max_score": 0.9997144,
                            "hits": [
                                {
                                    "_index": "passage_vectors",
                                    "_id": "2",
                                    "_nested": {
                                        "field": "paragraph",
                                        "offset": 1
                                    },
                                    "_score": 0.9997144,
                                    "fields": {
                                        "paragraph": [
                                            {
                                                "text": [
                                                    "number two paragraph"
                                                ]
                                            }
                                        ]
                                    }
                                }
                            ]
                        }
                    }
                }
            }
        ]
    }
}</pre>
</div>
<h4><a id="knn-indexing-considerations"></a>Indexing considerations<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.14/docs/reference/search/search-your-data/knn-search.asciidoc">edit</a></h4>
<p>For approximate kNN search, Elasticsearch stores the dense vector values of each
segment as an <a href="https://arxiv.org/abs/1603.09320" class="ulink" target="_top">HNSW graph</a>. Indexing vectors for
approximate kNN search can take substantial time because of how expensive it is
to build these graphs. You may need to increase the client request timeout for
index and bulk requests. The <a class="xref" href="tune-knn-search.html" title="Tune approximate kNN search">approximate kNN tuning guide</a>
contains important guidance around indexing performance, and how the index
configuration can affect search performance.</p>
<p>In addition to its search-time tuning parameters, the HNSW algorithm has
index-time parameters that trade off between the cost of building the graph,
search speed, and accuracy. When setting up the <code class="literal">dense_vector</code> mapping, you
can use the <a class="xref" href="dense-vector.html#dense-vector-index-options"><code class="literal">index_options</code></a> argument to adjust
these parameters:</p>
<div class="pre_wrapper lang-ruby alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-ruby alternative">response = client.indices.create(
  index: 'image-index',
  body: {
    mappings: {
      properties: {
        "image-vector": {
          type: 'dense_vector',
          dims: 3,
          similarity: 'l2_norm',
          index_options: {
            type: 'hnsw',
            m: 32,
            ef_construction: 100
          }
        }
      }
    }
  }
)
puts response</pre>
</div>
<a id="d49318764244113ad2ac4cc0f06d77ec"></a>
<div class="pre_wrapper lang-console default has-ruby">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-console default has-ruby">PUT image-index
{
  "mappings": {
    "properties": {
      "image-vector": {
        "type": "dense_vector",
        "dims": 3,
        "similarity": "l2_norm",
        "index_options": {
          "type": "hnsw",
          "m": 32,
          "ef_construction": 100
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget has-ruby" data-snippet="snippets/987.console"></div>
<h4><a id="approximate-knn-limitations"></a>Limitations for approximate kNN search<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.14/docs/reference/search/search-your-data/knn-search.asciidoc">edit</a></h4>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
When using kNN search in <a class="xref" href="modules-cross-cluster-search.html" title="Search across clusters">cross-cluster search</a>, the <a class="xref" href="modules-cross-cluster-search.html#ccs-min-roundtrips" title="Considerations for choosing whether to minimize roundtrips in a cross-cluster search"><code class="literal">ccs_minimize_roundtrips</code></a>
option is not supported.
</li>
<li class="listitem">

Elasticsearch uses the <a href="https://arxiv.org/abs/1603.09320" class="ulink" target="_top">HNSW algorithm</a> to support
efficient kNN search. Like most kNN algorithms, HNSW is an approximate method
that sacrifices result accuracy for improved search speed. This means the
results returned are not always the true <em>k</em> closest neighbors.
</li>
</ul>
</div>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p>Approximate kNN search always uses the
<a class="xref" href="search-search.html#dfs-query-then-fetch"><code class="literal">dfs_query_then_fetch</code></a> search type in order to gather
the global top <code class="literal">k</code> matches across shards. You cannot set the
<code class="literal">search_type</code> explicitly when running kNN search.</p>
</div>
</div>
<h3><a id="exact-knn"></a>Exact kNN<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.14/docs/reference/search/search-your-data/knn-search.asciidoc">edit</a></h3>
<p>To run an exact kNN search, use a <code class="literal">script_score</code> query with a vector function.</p>
<div class="olist orderedlist">
<ol class="orderedlist">
<li class="listitem">
<p>Explicitly map one or more <code class="literal">dense_vector</code> fields. If you don&#8217;t intend to use
the field for approximate kNN, set the <code class="literal">index</code> mapping option to <code class="literal">false</code>. This
can significantly improve indexing speed.</p>
<div class="pre_wrapper lang-ruby alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-ruby alternative">response = client.indices.create(
  index: 'product-index',
  body: {
    mappings: {
      properties: {
        "product-vector": {
          type: 'dense_vector',
          dims: 5,
          index: false
        },
        price: {
          type: 'long'
        }
      }
    }
  }
)
puts response</pre>
</div>
<a id="ea68e3428cc2ca3455bf312d09451489"></a>
<div class="pre_wrapper lang-console default has-ruby">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-console default has-ruby">PUT product-index
{
  "mappings": {
    "properties": {
      "product-vector": {
        "type": "dense_vector",
        "dims": 5,
        "index": false
      },
      "price": {
        "type": "long"
      }
    }
  }
}</pre>
</div>
<div class="console_widget has-ruby" data-snippet="snippets/988.console"></div>
</li>
<li class="listitem">
<p>Index your data.</p>
<a id="ba70b92f745a1765f1eb62e3457a86c3"></a>
<div class="pre_wrapper lang-console">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-console">POST product-index/_bulk?refresh=true
{ "index": { "_id": "1" } }
{ "product-vector": [230.0, 300.33, -34.8988, 15.555, -200.0], "price": 1599 }
{ "index": { "_id": "2" } }
{ "product-vector": [-0.5, 100.0, -13.0, 14.8, -156.0], "price": 799 }
{ "index": { "_id": "3" } }
{ "product-vector": [0.5, 111.3, -13.0, 14.8, -156.0], "price": 1099 }
...</pre>
</div>
<div class="console_widget" data-snippet="snippets/989.console"></div>
</li>
<li class="listitem">
<p>Use the <a class="xref" href="search-search.html" title="Search API">search API</a> to run a <code class="literal">script_score</code> query containing
a <a class="xref" href="query-dsl-script-score-query.html#vector-functions" title="Functions for vector fields">vector function</a>.</p>
<div class="tip admon">
<div class="icon"></div>
<div class="admon_content">
<p>To limit the number of matched documents passed to the vector function, we
recommend you specify a filter query in the <code class="literal">script_score.query</code> parameter. If
needed, you can use a <a class="xref" href="query-dsl-match-all-query.html" title="Match all query"><code class="literal">match_all</code> query</a> in this
parameter to match all documents. However, matching all documents can
significantly increase search latency.</p>
</div>
</div>
<div class="pre_wrapper lang-ruby alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-ruby alternative">response = client.search(
  index: 'product-index',
  body: {
    query: {
      script_score: {
        query: {
          bool: {
            filter: {
              range: {
                price: {
                  gte: 1000
                }
              }
            }
          }
        },
        script: {
          source: "cosineSimilarity(params.queryVector, 'product-vector') + 1.0",
          params: {
            "queryVector": [
              -0.5,
              90,
              -10,
              14.8,
              -156
            ]
          }
        }
      }
    }
  }
)
puts response</pre>
</div>
<a id="9ab351893dae65ec97fd8cb6832950fb"></a>
<div class="pre_wrapper lang-console default has-ruby">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-console default has-ruby">POST product-index/_search
{
  "query": {
    "script_score": {
      "query" : {
        "bool" : {
          "filter" : {
            "range" : {
              "price" : {
                "gte": 1000
              }
            }
          }
        }
      },
      "script": {
        "source": "cosineSimilarity(params.queryVector, 'product-vector') + 1.0",
        "params": {
          "queryVector": [-0.5, 90.0, -10, 14.8, -156.0]
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget has-ruby" data-snippet="snippets/990.console"></div>
</li>
</ol>
</div>
</div>
</div>
</div><div class="navfooter">
<span class="prev">
<a href="search-template.html">« Search templates</a>
</span>
<span class="next">
<a href="semantic-search.html">Semantic search »</a>
</span>
</div>
</body>
</html>
