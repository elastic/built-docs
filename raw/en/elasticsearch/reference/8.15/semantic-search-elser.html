<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Tutorial: semantic search with ELSER | Elasticsearch Guide [8.15] | Elastic</title>
<meta class="elastic" name="content" content="Tutorial: semantic search with ELSER | Elasticsearch Guide [8.15]">

<link rel="home" href="index.html" title="Elasticsearch Guide [8.15]"/>
<link rel="up" href="semantic-search.html" title="Semantic search"/>
<link rel="prev" href="semantic-search.html" title="Semantic search"/>
<link rel="next" href="semantic-search-semantic-text.html" title="Tutorial: semantic search with semantic_text"/>
<meta class="elastic" name="product_version" content="8.15"/>
<meta class="elastic" name="product_name" content="Elasticsearch"/>
<meta class="elastic" name="website_area" content="documentation"/>
<meta name="DC.type" content="Learn/Docs/Elasticsearch/Reference/8.15"/>
<meta name="DC.subject" content="Elasticsearch"/>
<meta name="DC.identifier" content="8.15"/>
</head>
<body>
<div class="navheader">
<span class="prev">
<a href="semantic-search.html">« Semantic search</a>
</span>
<span class="next">
<a href="semantic-search-semantic-text.html">Tutorial: semantic search with <code class="literal">semantic_text</code> »</a>
</span>
</div>
<div class="book" lang="en">
<div class="titlepage">
<div class="breadcrumbs">
<span class="breadcrumb-link"><a href="/guide/">Elastic Docs</a></span>
<span class="chevron-right">›</span><span class="breadcrumb-link"><a href="index.html">Elasticsearch Guide [8.15]</a></span>
<span class="chevron-right">›</span><span class="breadcrumb-link"><a href="search-with-elasticsearch.html">Search your data</a></span>
<span class="chevron-right">›</span><span class="breadcrumb-link"><a href="semantic-search.html">Semantic search</a></span>
</div>
<div>
<div><h1 class="title"><a id="id-1"></a>Tutorial: semantic search with ELSER</h1><a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.15/docs/reference/search/search-your-data/semantic-search-elser.asciidoc">edit</a></div>
</div>
<!--EXTRA-->
</div>
<div id="content">
<div class="section">
<div class="titlepage"><div><div>
<h2 class="title"><a id="semantic-search-elser"></a>Tutorial: semantic search with ELSER<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.15/docs/reference/search/search-your-data/semantic-search-elser.asciidoc">edit</a></h2>
</div></div></div>

<p>Elastic Learned Sparse EncodeR - or ELSER - is an NLP model trained by Elastic that enables you to perform semantic search by using sparse vector representation.
Instead of literal matching on search terms, semantic search retrieves results based on the intent and the contextual meaning of a search query.</p>
<p>The instructions in this tutorial shows you how to use ELSER to perform semantic search on your data.</p>
<div class="important admon">
<div class="icon"></div>
<div class="admon_content">
<p>For the easiest way to perform semantic search in the Elastic Stack, refer to the <a class="xref" href="semantic-search-semantic-text.html" title="Tutorial: semantic search with semantic_text"><code class="literal">semantic_text</code></a> end-to-end tutorial.</p>
</div>
</div>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p>Only the first 512 extracted tokens per field are considered during semantic search with ELSER.
Refer to <a href="/guide/en/machine-learning/8.15/ml-nlp-limitations.html#ml-nlp-elser-v1-limit-512" class="ulink" target="_top">this page</a> for more information.</p>
</div>
</div>
<h4><a id="requirements"></a>Requirements<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.15/docs/reference/search/search-your-data/semantic-search-elser.asciidoc">edit</a></h4>
<p>To perform semantic search by using ELSER, you must have the NLP model deployed in your cluster.
Refer to the <a href="/guide/en/machine-learning/8.15/ml-nlp-elser.html" class="ulink" target="_top">ELSER documentation</a> to learn how to download and deploy the model.</p>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p>The minimum dedicated ML node size for deploying and using the ELSER model is 4 GB in Elasticsearch Service if
<a href="/guide/en/cloud/current/ec-autoscaling.html" class="ulink" target="_top">deployment autoscaling</a> is turned off.
Turning on autoscaling is recommended because it allows your deployment to dynamically adjust resources based on demand.
Better performance can be achieved by using more allocations or more threads per allocation, which requires bigger ML nodes.
Autoscaling provides bigger nodes when required.
If autoscaling is turned off, you must provide suitably sized nodes yourself.</p>
</div>
</div>
<h4><a id="elser-mappings"></a>Create the index mapping<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.15/docs/reference/search/search-your-data/semantic-search-elser.asciidoc">edit</a></h4>
<p>First, the mapping of the destination index - the index that contains the tokens that the model created based on your text - must be created.
The destination index must have a field with the <a class="xref" href="sparse-vector.html" title="Sparse vector field type"><code class="literal">sparse_vector</code></a> or <a class="xref" href="rank-features.html" title="Rank features field type"><code class="literal">rank_features</code></a> field type to index the ELSER output.</p>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p>ELSER output must be ingested into a field with the <code class="literal">sparse_vector</code> or <code class="literal">rank_features</code> field type.
Otherwise, Elasticsearch interprets the token-weight pairs as a massive amount of fields in a document.
If you get an error similar to this: <code class="literal">"Limit of total fields [1000] has been exceeded while adding new fields"</code> then the ELSER output field is not mapped properly and it has a field type different than <code class="literal">sparse_vector</code> or <code class="literal">rank_features</code>.</p>
</div>
</div>
<div class="pre_wrapper lang-ruby alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-ruby alternative">response = client.indices.create(
  index: 'my-index',
  body: {
    mappings: {
      properties: {
        content_embedding: {
          type: 'sparse_vector'
        },
        content: {
          type: 'text'
        }
      }
    }
  }
)
puts response</pre>
</div>
<div class="pre_wrapper lang-js alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-js alternative">const response = await client.indices.create({
  index: "my-index",
  mappings: {
    properties: {
      content_embedding: {
        type: "sparse_vector",
      },
      content: {
        type: "text",
      },
    },
  },
});
console.log(response);</pre>
</div>
<a id="a2bd0782aadfd0a902d7f590ee7f49fe"></a>
<div class="pre_wrapper lang-console default has-ruby has-js">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-console default has-ruby has-js">PUT my-index
{
  "mappings": {
    "properties": {
      "content_embedding": { <a id="CO238-1"></a><i class="conum" data-value="1"></i>
        "type": "sparse_vector" <a id="CO238-2"></a><i class="conum" data-value="2"></i>
      },
      "content": { <a id="CO238-3"></a><i class="conum" data-value="3"></i>
        "type": "text" <a id="CO238-4"></a><i class="conum" data-value="4"></i>
      }
    }
  }
}</pre>
</div>
<div class="console_widget has-ruby has-js" data-snippet="snippets/1024.console"></div>
<div class="calloutlist default has-ruby has-js lang-console">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO238-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>The name of the field to contain the generated tokens.
It must be referenced in the inference pipeline configuration in the next step.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO238-2"><i class="conum" data-value="2"></i></a></p>
</td>
<td align="left" valign="top">
<p>The field to contain the tokens is a <code class="literal">sparse_vector</code> field.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO238-3"><i class="conum" data-value="3"></i></a></p>
</td>
<td align="left" valign="top">
<p>The name of the field from which to create the sparse vector representation.
In this example, the name of the field is <code class="literal">content</code>.
It must be referenced in the inference pipeline configuration in the next step.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO238-4"><i class="conum" data-value="4"></i></a></p>
</td>
<td align="left" valign="top">
<p>The field type which is text in this example.</p>
</td>
</tr>
</table>
</div>
<p>To learn how to optimize space, refer to the <a class="xref" href="semantic-search-elser.html#save-space" title="Saving disk space by excluding the ELSER tokens from document source">Saving disk space by excluding the ELSER tokens from document source</a> section.</p>
<h4><a id="inference-ingest-pipeline"></a>Create an ingest pipeline with an inference processor<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.15/docs/reference/search/search-your-data/semantic-search-elser.asciidoc">edit</a></h4>
<p>Create an <a class="xref" href="ingest.html" title="Ingest pipelines">ingest pipeline</a> with an
<a class="xref" href="inference-processor.html" title="Inference processor">inference processor</a> to use ELSER to infer against the data that is being ingested in the pipeline.</p>
<div class="pre_wrapper lang-ruby alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-ruby alternative">response = client.ingest.put_pipeline(
  id: 'elser-v2-test',
  body: {
    processors: [
      {
        inference: {
          model_id: '.elser_model_2',
          input_output: [
            {
              input_field: 'content',
              output_field: 'content_embedding'
            }
          ]
        }
      }
    ]
  }
)
puts response</pre>
</div>
<div class="pre_wrapper lang-js alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-js alternative">const response = await client.ingest.putPipeline({
  id: "elser-v2-test",
  processors: [
    {
      inference: {
        model_id: ".elser_model_2",
        input_output: [
          {
            input_field: "content",
            output_field: "content_embedding",
          },
        ],
      },
    },
  ],
});
console.log(response);</pre>
</div>
<a id="d003ee256d24aa6000bd9dbf1d608dc5"></a>
<div class="pre_wrapper lang-console default has-ruby has-js">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-console default has-ruby has-js">PUT _ingest/pipeline/elser-v2-test
{
  "processors": [
    {
      "inference": {
        "model_id": ".elser_model_2",
        "input_output": [ <a id="CO239-1"></a><i class="conum" data-value="1"></i>
          {
            "input_field": "content",
            "output_field": "content_embedding"
          }
        ]
      }
    }
  ]
}</pre>
</div>
<div class="console_widget has-ruby has-js" data-snippet="snippets/1025.console"></div>
<div class="calloutlist default has-ruby has-js lang-console">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO239-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>Configuration object that defines the <code class="literal">input_field</code> for the inference process and the <code class="literal">output_field</code> that will contain the inference results.</p>
</td>
</tr>
</table>
</div>
<h4><a id="load-data"></a>Load data<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.15/docs/reference/search/search-your-data/semantic-search-elser.asciidoc">edit</a></h4>
<p>In this step, you load the data that you later use in the inference ingest pipeline to extract tokens from it.</p>
<p>Use the <code class="literal">msmarco-passagetest2019-top1000</code> data set, which is a subset of the MS MARCO Passage Ranking data set.
It consists of 200 queries, each accompanied by a list of relevant text passages.
All unique passages, along with their IDs, have been extracted from that data set and compiled into a
<a href="https://github.com/elastic/stack-docs/blob/main/docs/en/stack/ml/nlp/data/msmarco-passagetest2019-unique.tsv" class="ulink" target="_top">tsv file</a>.</p>
<div class="important admon">
<div class="icon"></div>
<div class="admon_content">
<p>The <code class="literal">msmarco-passagetest2019-top1000</code> dataset was not utilized to train the model.
It is only used in this tutorial as a sample dataset that is easily accessible for demonstration purposes.
You can use a different data set to test the workflow and become familiar with it.</p>
</div>
</div>
<p>Download the file and upload it to your cluster using the
<a href="/guide/en/kibana/8.15/connect-to-elasticsearch.html#upload-data-kibana" class="ulink" target="_top">Data Visualizer</a>
in the Machine Learning UI.
Assign the name <code class="literal">id</code> to the first column and <code class="literal">content</code> to the second column.
The index name is <code class="literal">test-data</code>.
Once the upload is complete, you can see an index named <code class="literal">test-data</code> with 182469 documents.</p>
<h4><a id="reindexing-data-elser"></a>Ingest the data through the inference ingest pipeline<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.15/docs/reference/search/search-your-data/semantic-search-elser.asciidoc">edit</a></h4>
<p>Create the tokens from the text by reindexing the data throught the inference
pipeline that uses ELSER as the inference model.</p>
<div class="pre_wrapper lang-ruby alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-ruby alternative">response = client.reindex(
  wait_for_completion: false,
  body: {
    source: {
      index: 'test-data',
      size: 50
    },
    dest: {
      index: 'my-index',
      pipeline: 'elser-v2-test'
    }
  }
)
puts response</pre>
</div>
<div class="pre_wrapper lang-js alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-js alternative">const response = await client.reindex({
  wait_for_completion: "false",
  source: {
    index: "test-data",
    size: 50,
  },
  dest: {
    index: "my-index",
    pipeline: "elser-v2-test",
  },
});
console.log(response);</pre>
</div>
<a id="bf17440ac178d2ef5f5be643d033920b"></a>
<div class="pre_wrapper lang-console default has-ruby has-js">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-console default has-ruby has-js">POST _reindex?wait_for_completion=false
{
  "source": {
    "index": "test-data",
    "size": 50 <a id="CO240-1"></a><i class="conum" data-value="1"></i>
  },
  "dest": {
    "index": "my-index",
    "pipeline": "elser-v2-test"
  }
}</pre>
</div>
<div class="console_widget has-ruby has-js" data-snippet="snippets/1026.console"></div>
<div class="calloutlist default has-ruby has-js lang-console">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO240-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>The default batch size for reindexing is 1000. Reducing <code class="literal">size</code> to a smaller number makes the update of the reindexing process quicker which enables you to follow the progress closely and detect errors early.</p>
</td>
</tr>
</table>
</div>
<p>The call returns a task ID to monitor the progress:</p>
<div class="pre_wrapper lang-js alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-js alternative">const response = await client.tasks.get({
  task_id: "&lt;task_id&gt;",
});
console.log(response);</pre>
</div>
<a id="8a1b6eae4893c5dd27b3d81fd8d70f5b"></a>
<div class="pre_wrapper lang-console default has-js">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-console default has-js">GET _tasks/&lt;task_id&gt;</pre>
</div>
<div class="console_widget has-js" data-snippet="snippets/1027.console"></div>
<p>You can also open the Trained Models UI, select the Pipelines tab under ELSER to follow the progress.</p>
<h4><a id="text-expansion-query"></a>Semantic search by using the <code class="literal">sparse_vector</code> query<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.15/docs/reference/search/search-your-data/semantic-search-elser.asciidoc">edit</a></h4>
<p>To perform semantic search, use the <a class="xref" href="query-dsl-sparse-vector-query.html" title="Sparse vector query"><code class="literal">sparse_vector</code> query</a>, and provide the query text and the inference ID associated with your ELSER model.
The example below uses the query text "How to avoid muscle soreness after running?", the <code class="literal">content_embedding</code> field contains the generated ELSER output:</p>
<div class="pre_wrapper lang-js alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-js alternative">const response = await client.search({
  index: "my-index",
  query: {
    sparse_vector: {
      field: "content_embedding",
      inference_id: "my-elser-endpoint",
      query: "How to avoid muscle soreness after running?",
    },
  },
});
console.log(response);</pre>
</div>
<a id="4310869b97d4224acaa6d66b1e196048"></a>
<div class="pre_wrapper lang-console default has-js">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-console default has-js">GET my-index/_search
{
   "query":{
      "sparse_vector":{
         "field": "content_embedding",
         "inference_id": "my-elser-endpoint",
         "query": "How to avoid muscle soreness after running?"
      }
   }
}</pre>
</div>
<div class="console_widget has-js" data-snippet="snippets/1028.console"></div>
<p>The result is the top 10 documents that are closest in meaning to your query text from the <code class="literal">my-index</code> index sorted by their relevancy.
The result also contains the extracted tokens for each of the relevant search results with their weights.
Tokens are learned associations capturing relevance, they are not synonyms.
To learn more about what tokens are, refer to <a href="/guide/en/machine-learning/8.15/ml-nlp-elser.html#elser-tokens" class="ulink" target="_top">this page</a>.
It is possible to exclude tokens from source, refer to <a class="xref" href="semantic-search-elser.html#save-space" title="Saving disk space by excluding the ELSER tokens from document source">this section</a> to learn more.</p>
<div class="pre_wrapper lang-consol-result">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-consol-result">"hits": {
  "total": {
    "value": 10000,
    "relation": "gte"
  },
  "max_score": 26.199875,
  "hits": [
    {
      "_index": "my-index",
      "_id": "FPr9HYsBag9jXmT8lEpI",
      "_score": 26.199875,
      "_source": {
        "content_embedding": {
          "muscular": 0.2821541,
          "bleeding": 0.37929374,
          "foods": 1.1718726,
          "delayed": 1.2112266,
          "cure": 0.6848574,
          "during": 0.5886185,
          "fighting": 0.35022718,
          "rid": 0.2752442,
          "soon": 0.2967024,
          "leg": 0.37649947,
          "preparation": 0.32974035,
          "advance": 0.09652356,
          (...)
        },
        "id": 1713868,
        "model_id": ".elser_model_2",
        "content": "For example, if you go for a run, you will mostly use the muscles in your lower body. Give yourself 2 days to rest those muscles so they have a chance to heal before you exercise them again. Not giving your muscles enough time to rest can cause muscle damage, rather than muscle development."
      }
    },
    (...)
  ]
}</pre>
</div>
<h4><a id="text-expansion-compound-query"></a>Combining semantic search with other queries<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.15/docs/reference/search/search-your-data/semantic-search-elser.asciidoc">edit</a></h4>
<p>You can combine <a class="xref" href="query-dsl-sparse-vector-query.html" title="Sparse vector query"><code class="literal">sparse_vector</code></a> with other queries in a <a class="xref" href="compound-queries.html" title="Compound queries">compound query</a>.
For example, use a filter clause in a <a class="xref" href="query-dsl-bool-query.html" title="Boolean query">Boolean</a> or a full text query with the same (or different) query text as the <code class="literal">sparse_vector</code> query.
This enables you to combine the search results from both queries.</p>
<p>The search hits from the <code class="literal">sparse_vector</code> query tend to score higher than other
Elasticsearch queries.
Those scores can be regularized by increasing or decreasing the relevance scores of each query by using the <code class="literal">boost</code> parameter.
Recall on the <code class="literal">sparse_vector</code> query can be high where there is a long tail of less relevant results.
Use the <code class="literal">min_score</code> parameter to prune those less relevant documents.</p>
<div class="pre_wrapper lang-js alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-js alternative">const response = await client.search({
  index: "my-index",
  query: {
    bool: {
      should: [
        {
          sparse_vector: {
            field: "content_embedding",
            inference_id: "my-elser-endpoint",
            query: "How to avoid muscle soreness after running?",
            boost: 1,
          },
        },
        {
          query_string: {
            query: "toxins",
            boost: 4,
          },
        },
      ],
    },
  },
  min_score: 10,
});
console.log(response);</pre>
</div>
<a id="b6a7ffd2003c38f4aa321f067d162be5"></a>
<div class="pre_wrapper lang-console default has-js">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-console default has-js">GET my-index/_search
{
  "query": {
    "bool": { <a id="CO241-1"></a><i class="conum" data-value="1"></i>
      "should": [
        {
          "sparse_vector": {
            "field": "content_embedding",
            "inference_id": "my-elser-endpoint",
            "query": "How to avoid muscle soreness after running?",
            "boost": 1 <a id="CO241-2"></a><i class="conum" data-value="2"></i>
          }
        },
        {
          "query_string": {
            "query": "toxins",
            "boost": 4 <a id="CO241-3"></a><i class="conum" data-value="3"></i>
          }
        }
      ]
    }
  },
  "min_score": 10 <a id="CO241-4"></a><i class="conum" data-value="4"></i>
}</pre>
</div>
<div class="console_widget has-js" data-snippet="snippets/1029.console"></div>
<div class="calloutlist default has-js lang-console">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO241-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>Both the <code class="literal">sparse_vector</code> and the <code class="literal">query_string</code> queries are in a <code class="literal">should</code> clause of a <code class="literal">bool</code> query.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO241-2"><i class="conum" data-value="2"></i></a></p>
</td>
<td align="left" valign="top">
<p>The <code class="literal">boost</code> value is <code class="literal">1</code> for the <code class="literal">sparse_vector</code> query which is the default value.
This means that the relevance score of the results of this query are not boosted.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO241-3"><i class="conum" data-value="3"></i></a></p>
</td>
<td align="left" valign="top">
<p>The <code class="literal">boost</code> value is <code class="literal">4</code> for the <code class="literal">query_string</code> query.
The relevance score of the results of this query is increased causing them to rank higher in the search results.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO241-4"><i class="conum" data-value="4"></i></a></p>
</td>
<td align="left" valign="top">
<p>Only the results with a score equal to or higher than <code class="literal">10</code> are displayed.</p>
</td>
</tr>
</table>
</div>
<h3><a id="optimization"></a>Optimizing performance<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.15/docs/reference/search/search-your-data/semantic-search-elser.asciidoc">edit</a></h3>
<h4><a id="save-space"></a>Saving disk space by excluding the ELSER tokens from document source<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.15/docs/reference/search/search-your-data/semantic-search-elser.asciidoc">edit</a></h4>
<p>The tokens generated by ELSER must be indexed for use in the <a class="xref" href="query-dsl-sparse-vector-query.html" title="Sparse vector query">sparse_vector query</a>.
However, it is not necessary to retain those terms in the document source.
You can save disk space by using the <a class="xref" href="mapping-source-field.html#include-exclude" title="Including / Excluding fields from _source">source exclude</a> mapping to remove the ELSER terms from the document source.</p>
<div class="warning admon">
<div class="icon"></div>
<div class="admon_content">
<p>Reindex uses the document source to populate the destination index.
<span class="strong strong"><strong>Once the ELSER terms have been excluded from the source, they cannot be recovered through reindexing.</strong></span>
Excluding the tokens from the source is a space-saving optimization that should only be applied if you are certain that reindexing will not be required in the future!
It&#8217;s important to carefully consider this trade-off and make sure that excluding the ELSER terms from the source aligns with your specific requirements and use case.
Review the
<a class="xref" href="mapping-source-field.html#disable-source-field" title="Disabling the _source field">Disabling the <code class="literal">_source</code> field</a> and <a class="xref" href="mapping-source-field.html#include-exclude" title="Including / Excluding fields from _source">Including / Excluding fields from <code class="literal">_source</code></a> sections carefully to learn more about the possible consequences of excluding the tokens from the <code class="literal">_source</code>.</p>
</div>
</div>
<p>The mapping that excludes <code class="literal">content_embedding</code> from the  <code class="literal">_source</code> field can be created by the following API call:</p>
<div class="pre_wrapper lang-ruby alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-ruby alternative">response = client.indices.create(
  index: 'my-index',
  body: {
    mappings: {
      _source: {
        excludes: [
          'content_embedding'
        ]
      },
      properties: {
        content_embedding: {
          type: 'sparse_vector'
        },
        content: {
          type: 'text'
        }
      }
    }
  }
)
puts response</pre>
</div>
<div class="pre_wrapper lang-js alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-js alternative">const response = await client.indices.create({
  index: "my-index",
  mappings: {
    _source: {
      excludes: ["content_embedding"],
    },
    properties: {
      content_embedding: {
        type: "sparse_vector",
      },
      content: {
        type: "text",
      },
    },
  },
});
console.log(response);</pre>
</div>
<a id="fc1907515f6a913884a9f86451e90ee8"></a>
<div class="pre_wrapper lang-console default has-ruby has-js">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-console default has-ruby has-js">PUT my-index
{
  "mappings": {
    "_source": {
      "excludes": [
        "content_embedding"
      ]
    },
    "properties": {
      "content_embedding": {
        "type": "sparse_vector"
      },
      "content": {
        "type": "text"
      }
    }
  }
}</pre>
</div>
<div class="console_widget has-ruby has-js" data-snippet="snippets/1030.console"></div>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p>Depending on your data, the <code class="literal">sparse_vector</code> query may be faster with <code class="literal">track_total_hits: false</code>.</p>
</div>
</div>
<h4><a id="further-reading"></a>Further reading<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.15/docs/reference/search/search-your-data/semantic-search-elser.asciidoc">edit</a></h4>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
<a href="/guide/en/machine-learning/8.15/ml-nlp-elser.html" class="ulink" target="_top">How to download and deploy ELSER</a>
</li>
<li class="listitem">
<a href="/guide/en/machine-learning/8.15/ml-nlp-limitations.html#ml-nlp-elser-v1-limit-512" class="ulink" target="_top">ELSER limitation</a>
</li>
<li class="listitem">
<a href="/blog/may-2023-launch-information-retrieval-elasticsearch-ai-model" class="ulink" target="_top">Improving information retrieval in the Elastic Stack: Introducing Elastic Learned Sparse Encoder, our new retrieval model</a>
</li>
</ul>
</div>
<h4><a id="interactive-example"></a>Interactive example<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/8.15/docs/reference/search/search-your-data/semantic-search-elser.asciidoc">edit</a></h4>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
The <code class="literal">elasticsearch-labs</code> repo has an interactive example of running <a href="https://github.com/elastic/elasticsearch-labs/blob/main/notebooks/search/03-ELSER.ipynb" class="ulink" target="_top">ELSER-powered semantic search</a> using the Elasticsearch Python client.
</li>
</ul>
</div>
</div>
</div>
</div><div class="navfooter">
<span class="prev">
<a href="semantic-search.html">« Semantic search</a>
</span>
<span class="next">
<a href="semantic-search-semantic-text.html">Tutorial: semantic search with <code class="literal">semantic_text</code> »</a>
</span>
</div>
</body>
</html>
