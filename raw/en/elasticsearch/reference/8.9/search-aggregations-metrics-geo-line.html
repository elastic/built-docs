<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Geo-Line Aggregation | Elasticsearch Guide [8.9] | Elastic</title>
<meta class="elastic" name="content" content="Geo-Line Aggregation | Elasticsearch Guide [8.9]">

<link rel="home" href="index.html" title="Elasticsearch Guide [8.9]"/>
<link rel="up" href="search-aggregations-metrics.html" title="Metrics aggregations"/>
<link rel="prev" href="search-aggregations-metrics-geocentroid-aggregation.html" title="Geo-centroid aggregation"/>
<link rel="next" href="search-aggregations-metrics-cartesian-bounds-aggregation.html" title="Cartesian-bounds aggregation"/>
<meta class="elastic" name="product_version" content="8.9"/>
<meta class="elastic" name="product_name" content="Elasticsearch"/>
<meta class="elastic" name="website_area" content="documentation"/>
<meta name="DC.type" content="Learn/Docs/Elasticsearch/Reference/8.9"/>
<meta name="DC.subject" content="Elasticsearch"/>
<meta name="DC.identifier" content="8.9"/>
<meta name="robots" content="noindex,nofollow"/>
</head>
<body><div class="page_header">
You are looking at preliminary documentation for a future release.
Not what you want? See the
<a href="../current/index.html">current release documentation</a>.
</div>
<div id="content">
<div class="breadcrumbs">
<span class="breadcrumb-link"><a href="/guide/">Elastic Docs</a></span>
<span class="chevron-right">›</span><span class="breadcrumb-link"><a href="index.html">Elasticsearch Guide [8.9]</a></span>
<span class="chevron-right">›</span><span class="breadcrumb-link"><a href="search-aggregations.html">Aggregations</a></span>
<span class="chevron-right">›</span><span class="breadcrumb-link"><a href="search-aggregations-metrics.html">Metrics aggregations</a></span>
</div>
<div class="navheader">
<span class="prev">
<a href="search-aggregations-metrics-geocentroid-aggregation.html">« Geo-centroid aggregation</a>
</span>
<span class="next">
<a href="search-aggregations-metrics-cartesian-bounds-aggregation.html">Cartesian-bounds aggregation »</a>
</span>
</div>
<div class="section xpack">
<div class="titlepage"><div><div>
<h2 class="title"><a id="search-aggregations-metrics-geo-line"></a>Geo-Line Aggregation<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/metrics/geoline-aggregation.asciidoc">edit</a></h2>
</div></div></div>

<p>The <code class="literal">geo_line</code> aggregation aggregates all <code class="literal">geo_point</code> values within a bucket into a <code class="literal">LineString</code> ordered
by the chosen <code class="literal">sort</code> field. This <code class="literal">sort</code> can be a date field, for example. The bucket returned is a valid
<a href="https://tools.ietf.org/html/rfc7946#section-3.2" class="ulink" target="_top">GeoJSON Feature</a> representing the line geometry.</p>
<a id="487f0e07fd83c05f9763e0795c525e2e"></a>
<a id="search-aggregations-metrics-geo-line-simple"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">PUT test
{
    "mappings": {
        "properties": {
            "my_location": { "type": "geo_point" },
            "group":       { "type": "keyword" },
            "@timestamp":  { "type": "date" }
        }
    }
}

POST /test/_bulk?refresh
{"index":{}}
{"my_location": {"lat":52.373184, "lon":4.889187}, "@timestamp": "2023-01-02T09:00:00Z"}
{"index":{}}
{"my_location": {"lat":52.370159, "lon":4.885057}, "@timestamp": "2023-01-02T10:00:00Z"}
{"index":{}}
{"my_location": {"lat":52.369219, "lon":4.901618}, "@timestamp": "2023-01-02T13:00:00Z"}
{"index":{}}
{"my_location": {"lat":52.374081, "lon":4.912350}, "@timestamp": "2023-01-02T16:00:00Z"}
{"index":{}}
{"my_location": {"lat":52.371667, "lon":4.914722}, "@timestamp": "2023-01-03T12:00:00Z"}

POST /test/_search?filter_path=aggregations
{
  "aggs": {
    "line": {
      "geo_line": {
        "point": {"field": "my_location"},
        "sort":  {"field": "@timestamp"}
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1370.console"></div>
<p>Which returns:</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">{
  "aggregations": {
    "line": {
      "type": "Feature",
      "geometry": {
        "type": "LineString",
        "coordinates": [
            [ 4.889187, 52.373184 ],
            [ 4.885057, 52.370159 ],
            [ 4.901618, 52.369219 ],
            [ 4.912350, 52.374081 ],
            [ 4.914722, 52.371667 ]
        ]
      },
      "properties": {
        "complete": true
      }
    }
  }
}</pre>
</div>
<p>The resulting <a href="https://tools.ietf.org/html/rfc7946#section-3.2" class="ulink" target="_top">GeoJSON Feature</a> contains both a <code class="literal">LineString</code> geometry
for the path generated by the aggregation, as well as a map of <code class="literal">properties</code>.
The property <code class="literal">complete</code> informs of whether all documents matched were used to generate the geometry.
The <code class="literal">size</code> option described below can be used to limit the number of documents included in the aggregation,
leading to results  with <code class="literal">complete: false</code>.
Exactly which documents are dropped from results depends on whether the aggregation is based
on <code class="literal">time_series</code> or not, and this is discussed in
<a class="xref" href="search-aggregations-metrics-geo-line.html#search-aggregations-metrics-geo-line-grouping-time-series-advantages" title="Why group with time-series?">more detail below</a>.</p>
<p>The above result could be displayed in a map user interface:</p>
<p><span class="image"><img src="images/spatial/geo_line.png" alt="Kibana map with museum tour of Amsterdam"></span></p>
<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="search-aggregations-metrics-geo-line-options"></a>Options<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/metrics/geoline-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<div class="variablelist">
<dl class="variablelist">
<dt>
<span class="term">
<code class="literal">point</code>
</span>
</dt>
<dd>
(Required)
</dd>
</dl>
</div>
<p>This option specifies the name of the <code class="literal">geo_point</code> field</p>
<p>Example usage configuring <code class="literal">my_location</code> as the point field:</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">"point": {
  "field": "my_location"
}</pre>
</div>
<div class="variablelist">
<dl class="variablelist">
<dt>
<span class="term">
<code class="literal">sort</code>
</span>
</dt>
<dd>
(Required outside <a class="xref" href="search-aggregations-metrics-geo-line.html#search-aggregations-metrics-geo-line-grouping-time-series" title="Grouping with time-series"><code class="literal">time_series</code></a> aggregations)
</dd>
</dl>
</div>
<p>This option specifies the name of the numeric field to use as the sort key for ordering the points.
When the <code class="literal">geo_line</code> aggregation is nested inside a
<a class="xref" href="search-aggregations-metrics-geo-line.html#search-aggregations-metrics-geo-line-grouping-time-series" title="Grouping with time-series"><code class="literal">time_series</code></a>
aggregation, this field defaults to <code class="literal">@timestamp</code>, and any other value will result in error.</p>
<p>Example usage configuring <code class="literal">@timestamp</code> as the sort key:</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">"sort": {
  "field": "@timestamp"
}</pre>
</div>
<div class="variablelist">
<dl class="variablelist">
<dt>
<span class="term">
<code class="literal">include_sort</code>
</span>
</dt>
<dd>
(Optional, boolean, default: <code class="literal">false</code>) This option includes, when true, an additional array of the sort values in the
feature properties.
</dd>
<dt>
<span class="term">
<code class="literal">sort_order</code>
</span>
</dt>
<dd>
(Optional, string, default: <code class="literal">"ASC"</code>) This option accepts one of two values: "ASC", "DESC".
The line is sorted in ascending order by the sort key when set to "ASC", and in descending
with "DESC".
</dd>
<dt>
<span class="term">
<code class="literal">size</code>
</span>
</dt>
<dd>
(Optional, integer, default: <code class="literal">10000</code>) The maximum length of the line represented in the aggregation.
Valid sizes are between one and 10000.
Within <a class="xref" href="search-aggregations-metrics-geo-line.html#search-aggregations-metrics-geo-line-grouping-time-series" title="Grouping with time-series"><code class="literal">time_series</code></a>
the aggregation uses line simplification to constrain the size, otherwise it uses truncation.
See <a class="xref" href="search-aggregations-metrics-geo-line.html#search-aggregations-metrics-geo-line-grouping-time-series-advantages" title="Why group with time-series?">below</a>
for a discussion on the subtleties involved.
</dd>
</dl>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="search-aggregations-metrics-geo-line-grouping"></a>Grouping<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/metrics/geoline-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>The simple example above will produce a single track for all the data selected by the query. However, it is far more
common to need to group the data into multiple tracks. For example, grouping flight transponder measurements by
flight call-sign before sorting each flight by timestamp and producing a separate track for each.</p>
<p>In the following examples we will group the locations of points of interest in the cities of
Amsterdam, Antwerp and Paris.
The tracks will be ordered by the planned visit sequence for a walking tour of the museums and others attractions.</p>
<p>In order to demonstrate the difference between a time-series grouping and a non-time-series grouping, we will
first create an index with <a class="xref" href="tsds-index-settings.html" title="Time series index settings">time-series enabled</a>,
and then give examples of grouping the same data without time-series and with time-series.</p>
<a id="89dee10a24ea2727af5b00039a4271bd"></a>
<a id="search-aggregations-metrics-geo-line-grouping-setup"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">PUT tour
{
    "mappings": {
        "properties": {
            "city": {
                "type": "keyword",
                "time_series_dimension": true
            },
            "category":   { "type": "keyword" },
            "route":      { "type": "long" },
            "name":       { "type": "keyword" },
            "location":   { "type": "geo_point" },
            "@timestamp": { "type": "date" }
        }
    },
    "settings": {
        "index": {
            "mode": "time_series",
            "routing_path": [ "city" ],
            "time_series": {
                "start_time": "2023-01-01T00:00:00Z",
                "end_time": "2024-01-01T00:00:00Z"
            }
        }
    }
}

POST /tour/_bulk?refresh
{"index":{}}
{"@timestamp": "2023-01-02T09:00:00Z", "route": 0, "location": "POINT(4.889187 52.373184)", "city": "Amsterdam", "category": "Attraction", "name": "Royal Palace Amsterdam"}
{"index":{}}
{"@timestamp": "2023-01-02T10:00:00Z", "route": 1, "location": "POINT(4.885057 52.370159)", "city": "Amsterdam", "category": "Attraction", "name": "The Amsterdam Dungeon"}
{"index":{}}
{"@timestamp": "2023-01-02T13:00:00Z", "route": 2, "location": "POINT(4.901618 52.369219)", "city": "Amsterdam", "category": "Museum", "name": "Museum Het Rembrandthuis"}
{"index":{}}
{"@timestamp": "2023-01-02T16:00:00Z", "route": 3, "location": "POINT(4.912350 52.374081)", "city": "Amsterdam", "category": "Museum", "name": "NEMO Science Museum"}
{"index":{}}
{"@timestamp": "2023-01-03T12:00:00Z", "route": 4, "location": "POINT(4.914722 52.371667)", "city": "Amsterdam", "category": "Museum", "name": "Nederlands Scheepvaartmuseum"}
{"index":{}}
{"@timestamp": "2023-01-04T09:00:00Z", "route": 5, "location": "POINT(4.401384 51.220292)", "city": "Antwerp", "category": "Attraction", "name": "Cathedral of Our Lady"}
{"index":{}}
{"@timestamp": "2023-01-04T12:00:00Z", "route": 6, "location": "POINT(4.405819 51.221758)", "city": "Antwerp", "category": "Museum", "name": "Snijders&amp;Rockoxhuis"}
{"index":{}}
{"@timestamp": "2023-01-04T15:00:00Z", "route": 7, "location": "POINT(4.405200 51.222900)", "city": "Antwerp", "category": "Museum", "name": "Letterenhuis"}
{"index":{}}
{"@timestamp": "2023-01-05T10:00:00Z", "route": 8, "location": "POINT(2.336389 48.861111)", "city": "Paris", "category": "Museum", "name": "Musée du Louvre"}
{"index":{}}
{"@timestamp": "2023-01-05T14:00:00Z", "route": 9, "location": "POINT(2.327000 48.860000)", "city": "Paris", "category": "Museum", "name": "Musée dOrsay"}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1371.console"></div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="search-aggregations-metrics-geo-line-grouping-terms"></a>Grouping with terms<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/metrics/geoline-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>Using the above data, for a non-time-series use case, the grouping can be done using a
<a class="xref" href="search-aggregations-bucket-terms-aggregation.html" title="Terms aggregation">terms aggregation</a> based on city name.
This would work whether or not we had defined the <code class="literal">tour</code> index as a time series index.</p>
<a id="d7348119df9f89a556a7b767d5298c7e"></a>
<a id="search-aggregations-metrics-geo-line-terms"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /tour/_search?filter_path=aggregations
{
  "aggregations": {
    "path": {
      "terms": {"field": "city"},
      "aggregations": {
        "museum_tour": {
          "geo_line": {
            "point": {"field": "location"},
            "sort": {"field": "@timestamp"}
          }
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1372.console"></div>
<p>Which returns:</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">{
  "aggregations": {
    "path": {
      "doc_count_error_upper_bound": 0,
      "sum_other_doc_count": 0,
      "buckets": [
        {
          "key": "Amsterdam",
          "doc_count": 5,
          "museum_tour": {
            "type": "Feature",
            "geometry": {
              "coordinates": [ [ 4.889187, 52.373184 ], [ 4.885057, 52.370159 ], [ 4.901618, 52.369219 ], [ 4.91235, 52.374081 ], [ 4.914722, 52.371667 ] ],
              "type": "LineString"
            },
            "properties": {
              "complete": true
            }
          }
        },
        {
          "key": "Antwerp",
          "doc_count": 3,
          "museum_tour": {
            "type": "Feature",
            "geometry": {
              "coordinates": [ [ 4.401384, 51.220292 ], [ 4.405819, 51.221758 ], [ 4.4052, 51.2229 ] ],
              "type": "LineString"
            },
            "properties": {
              "complete": true
            }
          }
        },
        {
          "key": "Paris",
          "doc_count": 2,
          "museum_tour": {
            "type": "Feature",
            "geometry": {
              "coordinates": [ [ 2.336389, 48.861111 ], [ 2.327, 48.86 ] ],
              "type": "LineString"
            },
            "properties": {
              "complete": true
            }
          }
        }
      ]
    }
  }
}</pre>
</div>
<p>The above results contain an array of buckets, where each bucket is a JSON object with the <code class="literal">key</code> showing the name
of the <code class="literal">city</code> field, and an inner aggregation result called <code class="literal">museum_tour</code> containing a
<a href="https://tools.ietf.org/html/rfc7946#section-3.2" class="ulink" target="_top">GeoJSON Feature</a> describing the
actual route between the various attractions in that city.
Each result also includes a <code class="literal">properties</code> object with a <code class="literal">complete</code> value which will be <code class="literal">false</code> if the geometry
was truncated to the limits specified in the <code class="literal">size</code> parameter.
Note that when we use <code class="literal">time_series</code> in the example below, we will get the same results structured a little differently.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="search-aggregations-metrics-geo-line-grouping-time-series"></a>Grouping with time-series<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/metrics/geoline-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>Using the same data as before, we can also perform the grouping with a
<a class="xref" href="search-aggregations-bucket-time-series-aggregation.html" title="Time series aggregation"><code class="literal">time_series</code> aggregation</a>.
This will group by TSID, which is defined as the combinations of all fields with <code class="literal">time_series_dimension: true</code>,
in this case the same <code class="literal">city</code> field used in the previous
<a class="xref" href="search-aggregations-bucket-terms-aggregation.html" title="Terms aggregation">terms aggregation</a>.
This example will only work if we defined the <code class="literal">tour</code> index as a time series index using  <code class="literal">index.mode="time_series"</code>.</p>
<a id="fa5dcd1c7fadc473a791daf0d7ceec36"></a>
<a id="search-aggregations-metrics-geo-line-time-series"></a><div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /tour/_search?filter_path=aggregations
{
  "aggregations": {
    "path": {
      "time_series": {},
      "aggregations": {
        "museum_tour": {
          "geo_line": {
            "point": {"field": "location"}
          }
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1373.console"></div>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p>The <code class="literal">geo_line</code> aggregation no longer requires the <code class="literal">sort</code> field when nested within a
<a class="xref" href="search-aggregations-bucket-time-series-aggregation.html" title="Time series aggregation"><code class="literal">time_series</code> aggregation</a>.
This is because the sort field is set to <code class="literal">@timestamp</code>, which all time-series indexes are pre-sorted by.
If you do set this parameter, and set it to something other than <code class="literal">@timestamp</code> you will get an error.</p>
</div>
</div>
<p>The above query will result in:</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">{
  "aggregations": {
    "path": {
      "buckets": {
        "{city=Paris}": {
          "key": {
            "city": "Paris"
          },
          "doc_count": 2,
          "museum_tour": {
            "type": "Feature",
            "geometry": {
              "coordinates": [ [ 2.336389, 48.861111 ], [ 2.327, 48.86 ] ],
              "type": "LineString"
            },
            "properties": {
              "complete": true
            }
          }
        },
        "{city=Antwerp}": {
          "key": {
            "city": "Antwerp"
          },
          "doc_count": 3,
          "museum_tour": {
            "type": "Feature",
            "geometry": {
              "coordinates": [ [ 4.401384, 51.220292 ], [ 4.405819, 51.221758 ], [ 4.4052, 51.2229 ] ],
              "type": "LineString"
            },
            "properties": {
              "complete": true
            }
          }
        },
        "{city=Amsterdam}": {
          "key": {
            "city": "Amsterdam"
          },
          "doc_count": 5,
          "museum_tour": {
            "type": "Feature",
            "geometry": {
              "coordinates": [ [ 4.889187, 52.373184 ], [ 4.885057, 52.370159 ], [ 4.901618, 52.369219 ], [ 4.91235, 52.374081 ], [ 4.914722, 52.371667 ] ],
              "type": "LineString"
            },
            "properties": {
              "complete": true
            }
          }
        }
      }
    }
  }
}</pre>
</div>
<p>The above results are essentially the same as with the previous <code class="literal">terms</code> aggregation example, but structured differently.
Here we see the buckets returned as a map, where the key is an internal description of the TSID.
This TSID is unique for each unique combination of fields with <code class="literal">time_series_dimension: true</code>.
Each bucket contains a <code class="literal">key</code> field which is also a map of all dimension values for the TSID, in this case only the city
name is used for grouping.
In addition, there is an inner aggregation result called <code class="literal">museum_tour</code> containing a
<a href="https://tools.ietf.org/html/rfc7946#section-3.2" class="ulink" target="_top">GeoJSON Feature</a> describing the
actual route between the various attractions in that city.
Each result also includes a <code class="literal">properties</code> object with a <code class="literal">complete</code> value which will be false if the geometry
was simplified to the limits specified in the <code class="literal">size</code> parameter.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="search-aggregations-metrics-geo-line-grouping-time-series-advantages"></a>Why group with time-series?<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/metrics/geoline-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>When reviewing the above examples, you might think that there is little difference between using
<a class="xref" href="search-aggregations-bucket-terms-aggregation.html" title="Terms aggregation"><code class="literal">terms</code></a> or
<a class="xref" href="search-aggregations-bucket-time-series-aggregation.html" title="Time series aggregation"><code class="literal">time_series</code></a>
to group the geo-lines. However, there are some important differences in behaviour between the two cases.
Time series indexes are stored in a very specific order on disk.
They are pre-grouped by the time-series dimension fields, and pre-sorted by the <code class="literal">@timestamp</code> field.
This allows the <code class="literal">geo_line</code> aggregation to be considerably optimized:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
The same memory allocated for the first bucket can be re-used over and over for all subsequent buckets.
This is substantially less memory than required for non-time-series cases where all buckets are collected
concurrently.
</li>
<li class="listitem">
No sorting needs to be done, since the data is pre-sorted by <code class="literal">@timestamp</code>.
The time-series data will naturally arrive at the aggregation collector in <code class="literal">DESC</code> order.
This means that if we specify <code class="literal">sort_order:ASC</code> (the default), we still collect in <code class="literal">DESC</code> order,
but perform an efficient in-memory reverse order before generating the final <code class="literal">LineString</code> geometry.
</li>
<li class="listitem">
The <code class="literal">size</code> parameter can be used for a streaming line-simplification algorithm.
Without time-series, we are forced to truncate data, by default after 10000 documents per bucket, in order to
prevent memory usage from being unbounded.
This can result in geo-lines being truncated, and therefor loosing important data.
With time-series we can run a streaming line-simplification algorithm, retaining control over memory usage,
while also maintaining the overall geometry shape.
In fact, for most use cases it would work to set this <code class="literal">size</code> parameter to a much lower bound, and save even more
memory. For example, if the <code class="literal">geo_line</code> is to be drawn on a display map with a specific resolution, it might look
just as good to simplify to as few as 100 or 200 points. This will save memory on the server, on the network and
in the client.
</li>
</ul>
</div>
<p>Note: There are other significant advantages to working with time-series data and using <code class="literal">time_series</code> index mode.
These are discussed in the documentation on <a class="xref" href="tsds.html" title="Time series data stream (TSDS)">time series data streams</a>.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="search-aggregations-metrics-geo-line-simplification"></a>Streaming line simplification<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch/edit/8.9/docs/reference/aggregations/metrics/geoline-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>Line simplification is a great way to reduce the size of the final results sent to the client, and displayed in a map
user interface. However, normally these algorithms use a lot of memory to perform the simplification, requiring the
entire geometry to be maintained in memory together with supporting data for the simplification itself.
The use of a streaming line simplification algorithm allows for minimal memory usage during the simplification
process by constraining memory to the bounds defined for the simplified geometry. This is only possible if no sorting
is required, which is the case when grouping is done by the
<a class="xref" href="search-aggregations-bucket-time-series-aggregation.html" title="Time series aggregation"><code class="literal">time_series</code> aggregation</a>,
running on an index with the <code class="literal">time_series</code> index mode.</p>
<p>Under these conditions the <code class="literal">geo_line</code> aggregation allocates memory to the <code class="literal">size</code> specified, and then fills that
memory with the incoming documents.
Once the memory is completely filled, documents from within the line are removed as new documents are added.
The choice of document to remove is made to minimize the visual impact on the geometry.
This process makes use of the
<a href="https://en.wikipedia.org/wiki/Visvalingam%E2%80%93Whyatt_algorithm" class="ulink" target="_top">Visvalingam–Whyatt algorithm</a>.
Essentially this means points are removed if they have the minimum triangle area, with the triangle defined
by the point under consideration and the two points before and after it in the line.
In addition, we calculate the area using spherical coordinates so that no planar distortions affect the choice.</p>
<p>In order to demonstrate how much better line simplification is to line truncation, consider this example of the north
shore of Kodiak Island.
The data for this is only 209 points, but if we want to set <code class="literal">size</code> to <code class="literal">100</code> we get dramatic truncation.</p>
<p><span class="image"><img src="images/spatial/kodiak_geo_line_truncated.png" alt="North short of Kodiak Island truncated to 100 points"></span></p>
<p>The grey line is the entire geometry of 209 points, while the blue line is the first 100 points, a very different
geometry than the original.</p>
<p>Now consider the same geometry simplified to 100 points.</p>
<p><span class="image"><img src="images/spatial/kodiak_geo_line_simplified.png" alt="North short of Kodiak Island simplified to 100 points"></span></p>
<p>For comparison we have shown the original in grey, the truncated in blue and the new simplified geometry
in magenta. It is possible to see where the new simplified line deviates from the original, but the overall
geometry appears almost identical and is still clearly recognizable as the north shore of Kodiak Island.</p>
</div>

</div>
<div class="navfooter">
<span class="prev">
<a href="search-aggregations-metrics-geocentroid-aggregation.html">« Geo-centroid aggregation</a>
</span>
<span class="next">
<a href="search-aggregations-metrics-cartesian-bounds-aggregation.html">Cartesian-bounds aggregation »</a>
</span>
</div>
</div>
</body>
</html>
