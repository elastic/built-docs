<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Semantic re-ranking | Elasticsearch Guide [8.x] | Elastic</title>
<meta class="elastic" name="content" content="Semantic re-ranking | Elasticsearch Guide [8.x]">

<link rel="home" href="index.html" title="Elasticsearch Guide [8.x]"/>
<link rel="up" href="re-ranking-overview.html" title="Re-ranking"/>
<link rel="prev" href="re-ranking-overview.html" title="Re-ranking"/>
<link rel="next" href="learning-to-rank.html" title="Learning To Rank"/>
<meta class="elastic" name="product_version" content="8.x"/>
<meta class="elastic" name="product_name" content="Elasticsearch"/>
<meta class="elastic" name="website_area" content="documentation"/>
<meta name="DC.type" content="Learn/Docs/Elasticsearch/Reference/8.x"/>
<meta name="DC.subject" content="Elasticsearch"/>
<meta name="DC.identifier" content="8.x"/>
<meta name="robots" content="noindex,nofollow"/>
</head>
<body>
<div class="page_header">
This documentation contains work-in-progress information for future Elastic Stack and Cloud releases. Use the version selector to view supported release docs. It also contains some Elastic Cloud serverless information. Check out our <a href="https://www.elastic.co/docs/current/serverless">serverless docs</a> for more details.
</div>
<div class="navheader">
<span class="prev">
<a href="re-ranking-overview.html">« Re-ranking</a>
</span>
<span class="next">
<a href="learning-to-rank.html">Learning To Rank »</a>
</span>
</div>
<div class="book" lang="en">
<div class="titlepage">
<div class="breadcrumbs">
<span class="breadcrumb-link"><a href="/guide/">Elastic Docs</a></span>
<span class="chevron-right">›</span><span class="breadcrumb-link"><a href="index.html">Elasticsearch Guide [8.x]</a></span>
<span class="chevron-right">›</span><span class="breadcrumb-link"><a href="re-ranking-overview.html">Re-ranking</a></span>
</div>
<div>
<div><h1 class="title"><a id="id-1"></a>Semantic re-ranking</h1><a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch/edit/8.x/docs/reference/reranking/semantic-reranking.asciidoc">edit</a></div>
</div>
<!--EXTRA-->
</div>
<div id="content">
<div class="chapter">
<div class="titlepage"><div><div>
<div class="position-relative"><h2 class="title"><a id="semantic-reranking"></a>Semantic re-ranking</h2><a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch/edit/8.x/docs/reference/reranking/semantic-reranking.asciidoc">edit</a></div>
</div></div></div>
<div class="warning admon">
<div class="icon"></div>
<div class="admon_content">
<p>This functionality is in technical preview and may be changed or removed in a future release. Elastic will work to fix any issues, but features in technical preview are not subject to the support SLA of official GA features.</p>
</div>
</div>
<div class="tip admon">
<div class="icon"></div>
<div class="admon_content">
<p>This overview focuses more on the high-level concepts and use cases for semantic re-ranking. For full implementation details on how to set up and use semantic re-ranking in Elasticsearch, see the <a class="xref" href="retriever.html#text-similarity-reranker-retriever" title="Text Similarity Re-ranker Retriever">reference documentation</a> in the Search API docs.</p>
</div>
</div>
<p>Re-rankers improve the relevance of results from earlier-stage retrieval mechanisms.
<em>Semantic</em> re-rankers use machine learning models to reorder search results based on their semantic similarity to a query.</p>
<p>Semantic re-ranking requires relatively large and complex machine learning models and operates in real-time in response to queries.
This technique makes sense on a small <em>top-k</em> result set, as one the of the final steps in a pipeline.
This is a powerful technique for improving search relevance that works equally well with keyword, semantic, or hybrid retrieval algorithms.</p>
<p>The next sections provide more details on the benefits, use cases, and model types used for semantic re-ranking.
The final sections include a practical, high-level overview of how to implement <a class="xref" href="semantic-reranking.html#semantic-reranking-in-es" title="Semantic re-ranking in Elasticsearch">semantic re-ranking in Elasticsearch</a> and links to the full reference documentation.</p>
<div class="position-relative"><h3><a id="semantic-reranking-use-cases"></a>Use cases</h3><a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch/edit/8.x/docs/reference/reranking/semantic-reranking.asciidoc">edit</a></div>
<p>Semantic re-ranking enables a variety of use cases:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
<p><span class="strong strong"><strong>Lexical (BM25) retrieval results re-ranking</strong></span></p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
Out-of-the-box semantic search by adding a simple API call to any lexical/BM25 retrieval pipeline.
</li>
<li class="listitem">
Adds semantic search capabilities on top of existing indices without reindexing, perfect for quick improvements.
</li>
<li class="listitem">
Ideal for environments with complex existing indices.
</li>
</ul>
</div>
</li>
<li class="listitem">
<p><span class="strong strong"><strong>Semantic retrieval results re-ranking</strong></span></p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
Improves results from semantic retrievers using ELSER sparse vector embeddings or dense vector embeddings by using more powerful models.
</li>
<li class="listitem">
Adds a refinement layer on top of hybrid retrieval with <a class="xref" href="rrf.html" title="Reciprocal rank fusion">reciprocal rank fusion (RRF)</a>.
</li>
</ul>
</div>
</li>
<li class="listitem">
<p><span class="strong strong"><strong>General applications</strong></span></p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
Supports automatic and transparent chunking, eliminating the need for pre-chunking at index time.
</li>
<li class="listitem">
Provides explicit control over document relevance in retrieval-augmented generation (RAG) uses cases or other scenarios involving language model (LLM) inputs.
</li>
</ul>
</div>
</li>
</ul>
</div>
<p>Now that we&#8217;ve outlined the value of semantic re-ranking, we&#8217;ll explore the specific models that power this process and how they differ.</p>
<div class="position-relative"><h3><a id="semantic-reranking-models"></a>Cross-encoder and bi-encoder models</h3><a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch/edit/8.x/docs/reference/reranking/semantic-reranking.asciidoc">edit</a></div>
<p>At a high level, two model types are used for semantic re-ranking: cross-encoders and bi-encoders.</p>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p>In this version, Elasticsearch <span class="strong strong"><strong>only supports cross-encoders</strong></span> for semantic re-ranking.</p>
</div>
</div>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
A <span class="strong strong"><strong>cross-encoder model</strong></span> can be thought of as a more powerful, all-in-one solution, because it generates query-aware document representations.
It takes the query and document texts as a single, concatenated input.
</li>
<li class="listitem">
<p>A <span class="strong strong"><strong>bi-encoder model</strong></span> takes as input either document or query text.
Documents and query embeddings are computed separately, so they aren&#8217;t aware of each other.</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
To compute a ranking score, an external operation is required. This typically involves computing dot-product or cosine similarity between the query and document embeddings.
</li>
</ul>
</div>
</li>
</ul>
</div>
<p>In brief, cross-encoders provide high accuracy but are more resource-intensive.
Bi-encoders are faster and more cost-effective but less precise.</p>
<p>In future versions, Elasticsearch will also support bi-encoders.
If you&#8217;re interested in a more detailed analysis of the practical differences between cross-encoders and bi-encoders, untoggle the next section.</p>
<details>
<summary class="title">Comparisons between cross-encoder and bi-encoder</summary>
<div class="content">
<p>The following is a non-exhaustive list of considerations when choosing between cross-encoders and bi-encoders for semantic re-ranking:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
Because a cross-encoder model simultaneously processes both query and document texts, it can better infer their relevance, making it more effective as a reranker than a bi-encoder.
</li>
<li class="listitem">
Cross-encoder models are generally larger and more computationally intensive, resulting in higher latencies and increased computational costs.
</li>
<li class="listitem">
There are significantly fewer open-source cross-encoders, while bi-encoders offer a wide variety of sizes, languages, and other trade-offs.
</li>
<li class="listitem">
The effectiveness of cross-encoders can also improve the relevance of semantic retrievers.
For example, their ability to take word order into account can improve on dense or sparse embedding retrieval.
</li>
<li class="listitem">
When trained in tandem with specific retrievers (like lexical/BM25), cross-encoders can “correct” typical errors made by those retrievers.
</li>
<li class="listitem">
Cross-encoders output scores that are consistent across queries.
This enables you to maintain high relevance in result sets, by setting a minimum score threshold for all queries.
For example, this is important when using results in a RAG workflow or if you&#8217;re otherwise feeding results to LLMs.
Note that similarity scores from bi-encoders/embedding similarities are <em>query-dependent</em>, meaning you cannot set universal cut-offs.
</li>
<li class="listitem">
Bi-encoders rerank using embeddings. You can improve your re-ranking latency by creating embeddings at ingest-time. These embeddings can be stored for re-ranking without being indexed for retrieval, reducing your memory footprint.
</li>
</ul>
</div>
</div>
</details>
<div class="position-relative"><h3><a id="semantic-reranking-in-es"></a>Semantic re-ranking in Elasticsearch</h3><a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch/edit/8.x/docs/reference/reranking/semantic-reranking.asciidoc">edit</a></div>
<p>In Elasticsearch, semantic re-rankers are implemented using the Elasticsearch <a class="xref" href="inference-apis.html" title="Inference APIs">Inference API</a> and a <a class="xref" href="retriever.html" title="Retriever">retriever</a>.</p>
<p>To use semantic re-ranking in Elasticsearch, you need to:</p>
<div class="olist orderedlist">
<ol class="orderedlist">
<li class="listitem">
<p><span class="strong strong"><strong>Select and configure a re-ranking model</strong></span>.
You have the following options:</p>
<div class="olist orderedlist">
<ol class="orderedlist">
<li class="listitem">
Use the <a class="xref" href="infer-service-elasticsearch.html#inference-example-elastic-reranker" title="Elastic Rerank via the elasticsearch service">Elastic Rerank</a> cross-encoder model via the inference API&#8217;s Elasticsearch service.
</li>
<li class="listitem">
Use the <a class="xref" href="infer-service-cohere.html" title="Cohere inference service">Cohere Rerank inference endpoint</a> to create a <code class="literal">rerank</code> endpoint.
</li>
<li class="listitem">
Use the <a class="xref" href="infer-service-google-vertex-ai.html" title="Google Vertex AI inference service">Google Vertex AI inference endpoint</a> to create a <code class="literal">rerank</code> endpoint.
</li>
<li class="listitem">
<p>Upload a model to Elasticsearch from Hugging Face with <a href="/guide/en/elasticsearch/client/eland/current/machine-learning.html#ml-nlp-pytorch" class="ulink" target="_top">Eland</a>. You&#8217;ll need to use the <code class="literal">text_similarity</code> NLP task type when loading the model using Eland. Then set up an <a class="xref" href="infer-service-elasticsearch.html#inference-example-eland" title="Models uploaded by Eland via the elasticsearch service">Elasticsearch service inference endpoint</a> with the <code class="literal">rerank</code> endpoint type.</p>
<p>Refer to <a href="/guide/en/machine-learning/8.x/ml-nlp-model-ref.html#ml-nlp-model-ref-text-similarity" class="ulink" target="_top">the Elastic NLP model reference</a> for a list of third party text similarity models supported by Elasticsearch for semantic re-ranking.</p>
</li>
</ol>
</div>
</li>
<li class="listitem">
<span class="strong strong"><strong>Create a <code class="literal">rerank</code> endpoint using the <a class="xref" href="put-inference-api.html" title="Create inference API">Elasticsearch Inference API</a></strong></span>.
The Inference API creates an inference endpoint and configures your chosen machine learning model to perform the re-ranking task.
</li>
<li class="listitem">
<span class="strong strong"><strong>Define a <code class="literal">text_similarity_reranker</code> retriever in your search request</strong></span>.
The retriever syntax makes it simple to configure both the retrieval and re-ranking of search results in a single API call.
</li>
</ol>
</div>
<details>
<summary class="title"><span class="strong strong"><strong>Example search request</strong></span> with semantic reranker</summary>
<div class="content">
<p>The following example shows a search request that uses a semantic reranker to reorder the top-k documents based on their semantic similarity to the query.</p>
<a id="17b1647c8509543f2388c886f2584a20"></a>
<div class="pre_wrapper lang-console">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-console">POST _search
{
  "retriever": {
    "text_similarity_reranker": {
      "retriever": {
        "standard": {
          "query": {
            "match": {
              "text": "How often does the moon hide the sun?"
            }
          }
        }
      },
      "field": "text",
      "inference_id": "elastic-rerank",
      "inference_text": "How often does the moon hide the sun?",
      "rank_window_size": 100,
      "min_score": 0.5
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1203.console"></div>
</div>
</details>
<div class="position-relative"><h3><a id="semantic-reranking-learn-more"></a>Learn more</h3><a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch/edit/8.x/docs/reference/reranking/semantic-reranking.asciidoc">edit</a></div>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
Read the <a class="xref" href="retriever.html" title="Retriever">retriever reference documentation</a> for syntax and implementation details
</li>
<li class="listitem">
Learn more about the <a class="xref" href="retrievers-overview.html" title="Retrievers">retrievers</a> abstraction
</li>
<li class="listitem">
Learn more about the Elastic <a class="xref" href="inference-apis.html" title="Inference APIs">Inference APIs</a>
</li>
<li class="listitem">
Check out our <a href="https://github.com/elastic/elasticsearch-labs/blob/main/notebooks/integrations/cohere/cohere-elasticsearch.ipynb" class="ulink" target="_top">Python notebook</a> for using Cohere with Elasticsearch
</li>
</ul>
</div>
</div>
</div>
</div><div class="navfooter">
<span class="prev">
<a href="re-ranking-overview.html">« Re-ranking</a>
</span>
<span class="next">
<a href="learning-to-rank.html">Learning To Rank »</a>
</span>
</div>
</body>
</html>
