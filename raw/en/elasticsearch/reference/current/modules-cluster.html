<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Cluster-level shard allocation and routing settings | Elasticsearch Reference [7.11] | Elastic</title>
<link rel="home" href="index.html" title="Elasticsearch Reference [7.11]"/>
<link rel="up" href="settings.html" title="Configuring Elasticsearch"/>
<link rel="prev" href="circuit-breaker.html" title="Circuit breaker settings"/>
<link rel="next" href="ccr-settings.html" title="Cross-cluster replication settings"/>
<meta name="DC.type" content="Learn/Docs/Elasticsearch/Reference/7.11"/>
<meta name="DC.subject" content="Elasticsearch"/>
<meta name="DC.identifier" content="7.11"/>
</head>
<body>
<div id="content">
<div class="breadcrumbs">
<span class="breadcrumb-link"><a href="index.html">Elasticsearch Reference [7.11]</a></span>
»
<span class="breadcrumb-link"><a href="setup.html">Set up Elasticsearch</a></span>
»
<span class="breadcrumb-link"><a href="settings.html">Configuring Elasticsearch</a></span>
»
<span class="breadcrumb-node">Cluster-level shard allocation and routing settings</span>
</div>
<div class="navheader">
<span class="prev">
<a href="circuit-breaker.html">« Circuit breaker settings</a>
</span>
<span class="next">
<a href="ccr-settings.html">Cross-cluster replication settings »</a>
</span>
</div>
<div class="section">
<div class="titlepage"><div><div>
<h2 class="title"><a id="modules-cluster"></a>Cluster-level shard allocation and routing settings<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.11/docs/reference/modules/cluster.asciidoc">edit</a></h2>
</div></div></div>
<p><em>Shard allocation</em> is the process of allocating shards to nodes. This can
happen during initial recovery, replica allocation, rebalancing, or
when nodes are added or removed.</p>
<p>One of the main roles of the master is to decide which shards to allocate to
which nodes, and when to move shards between nodes in order to rebalance the
cluster.</p>
<p>There are a number of settings available to control the shard allocation process:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
<a class="xref" href="modules-cluster.html#cluster-shard-allocation-settings" title="Cluster-level shard allocation settings">Cluster-level shard allocation settings</a> control allocation and
rebalancing operations.
</li>
<li class="listitem">
<a class="xref" href="modules-cluster.html#disk-based-shard-allocation" title="Disk-based shard allocation settings">Disk-based shard allocation settings</a> explains how Elasticsearch takes available
disk space into account, and the related settings.
</li>
<li class="listitem">
<a class="xref" href="modules-cluster.html#shard-allocation-awareness" title="Shard allocation awareness">Shard allocation awareness</a> and <a class="xref" href="modules-cluster.html#forced-awareness" title="Forced awareness">Forced awareness</a> control how shards
can be distributed across different racks or availability zones.
</li>
<li class="listitem">
<a class="xref" href="modules-cluster.html#cluster-shard-allocation-filtering" title="Cluster-level shard allocation filtering">Cluster-level shard allocation filtering</a> allows certain nodes or groups of
nodes excluded from allocation so that they can be decommissioned.
</li>
</ul>
</div>
<p>Besides these, there are a few other <a class="xref" href="modules-cluster.html#misc-cluster-settings" title="Miscellaneous cluster settings">miscellaneous cluster-level settings</a>.</p>
<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="cluster-shard-allocation-settings"></a>Cluster-level shard allocation settings<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.11/docs/reference/modules/cluster/shards_allocation.asciidoc">edit</a></h3>
</div></div></div>
<p>You can use the following settings to control shard allocation and recovery:</p>
<div class="variablelist">
<a id="cluster-routing-allocation-enable"></a>
<dl class="variablelist">
<dt>
<span class="term">
<code class="literal">cluster.routing.allocation.enable</code>
</span>
</dt>
<dd>
<p>(<a class="xref" href="settings.html#dynamic-cluster-setting">Dynamic</a>)
Enable or disable allocation for specific kinds of shards:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
<code class="literal">all</code> -             (default) Allows shard allocation for all kinds of shards.
</li>
<li class="listitem">
<code class="literal">primaries</code> -       Allows shard allocation only for primary shards.
</li>
<li class="listitem">
<code class="literal">new_primaries</code> -   Allows shard allocation only for primary shards for new indices.
</li>
<li class="listitem">
<code class="literal">none</code> -            No shard allocations of any kind are allowed for any indices.
</li>
</ul>
</div>
<p>This setting does not affect the recovery of local primary shards when
restarting a node.  A restarted node that has a copy of an unassigned primary
shard will recover that primary immediately, assuming that its allocation id matches
one of the active allocation ids in the cluster state.</p>
</dd>
<dt>
<span class="term">
<code class="literal">cluster.routing.allocation.node_concurrent_incoming_recoveries</code>
</span>
</dt>
<dd>
(<a class="xref" href="settings.html#dynamic-cluster-setting">Dynamic</a>)
How many concurrent incoming shard recoveries are allowed to happen on a node. Incoming recoveries are the recoveries
where the target shard (most likely the replica unless a shard is relocating) is allocated on the node. Defaults to <code class="literal">2</code>.
</dd>
<dt>
<span class="term">
<code class="literal">cluster.routing.allocation.node_concurrent_outgoing_recoveries</code>
</span>
</dt>
<dd>
(<a class="xref" href="settings.html#dynamic-cluster-setting">Dynamic</a>)
How many concurrent outgoing shard recoveries are allowed to happen on a node. Outgoing recoveries are the recoveries
where the source shard (most likely the primary unless a shard is relocating) is allocated on the node. Defaults to <code class="literal">2</code>.
</dd>
<dt>
<span class="term">
<code class="literal">cluster.routing.allocation.node_concurrent_recoveries</code>
</span>
</dt>
<dd>
(<a class="xref" href="settings.html#dynamic-cluster-setting">Dynamic</a>)
A shortcut to set both <code class="literal">cluster.routing.allocation.node_concurrent_incoming_recoveries</code> and
<code class="literal">cluster.routing.allocation.node_concurrent_outgoing_recoveries</code>.
</dd>
<dt>
<span class="term">
<code class="literal">cluster.routing.allocation.node_initial_primaries_recoveries</code>
</span>
</dt>
<dd>
(<a class="xref" href="settings.html#dynamic-cluster-setting">Dynamic</a>)
While the recovery of replicas happens over the network, the recovery of
an unassigned primary after node restart uses data from the local disk.
These should be fast so more initial primary recoveries can happen in
parallel on the same node.  Defaults to <code class="literal">4</code>.
</dd>
<dt>
<span class="term">
<code class="literal">cluster.routing.allocation.same_shard.host</code>
</span>
</dt>
<dd>
(<a class="xref" href="settings.html#dynamic-cluster-setting">Dynamic</a>)
Allows to perform a check to prevent allocation of multiple instances of
the same shard on a single host, based on host name and host address.
Defaults to <code class="literal">false</code>, meaning that no check is performed by default. This
setting only applies if multiple nodes are started on the same machine.
</dd>
</dl>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="shards-rebalancing-settings"></a>Shard rebalancing settings<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.11/docs/reference/modules/cluster/shards_allocation.asciidoc">edit</a></h3>
</div></div></div>
<p>A cluster is <em>balanced</em> when it has an equal number of shards on each node
without having a concentration of shards from any index on any node. Elasticsearch runs
an automatic process called <em>rebalancing</em> which moves shards between the nodes
in your cluster to improve its balance. Rebalancing obeys all other shard
allocation rules such as <a class="xref" href="modules-cluster.html#cluster-shard-allocation-filtering" title="Cluster-level shard allocation filtering">allocation
filtering</a> and <a class="xref" href="modules-cluster.html#forced-awareness" title="Forced awareness">forced awareness</a> which may prevent it from
completely balancing the cluster. In that case, rebalancing strives to acheve
the most balanced cluster possible within the rules you have configured. If you
are using <a class="xref" href="data-tiers.html" title="Data tiers">data tiers</a> then Elasticsearch automatically applies allocation
filtering rules to place each shard within the appropriate tier. These rules
mean that the balancer works independently within each tier.</p>
<p>You can use the following settings to control the rebalancing of shards across
the cluster:</p>
<div class="variablelist">
<dl class="variablelist">
<dt>
<span class="term">
<code class="literal">cluster.routing.rebalance.enable</code>
</span>
</dt>
<dd>
<p>(<a class="xref" href="settings.html#dynamic-cluster-setting">Dynamic</a>)
Enable or disable rebalancing for specific kinds of shards:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
<code class="literal">all</code> -         (default) Allows shard balancing for all kinds of shards.
</li>
<li class="listitem">
<code class="literal">primaries</code> -   Allows shard balancing only for primary shards.
</li>
<li class="listitem">
<code class="literal">replicas</code> -    Allows shard balancing only for replica shards.
</li>
<li class="listitem">
<code class="literal">none</code> -        No shard balancing of any kind are allowed for any indices.
</li>
</ul>
</div>
</dd>
<dt>
<span class="term">
<code class="literal">cluster.routing.allocation.allow_rebalance</code>
</span>
</dt>
<dd>
<p>(<a class="xref" href="settings.html#dynamic-cluster-setting">Dynamic</a>)
Specify when shard rebalancing is allowed:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
<code class="literal">always</code> -                    Always allow rebalancing.
</li>
<li class="listitem">
<code class="literal">indices_primaries_active</code> -  Only when all primaries in the cluster are allocated.
</li>
<li class="listitem">
<code class="literal">indices_all_active</code> -        (default) Only when all shards (primaries and replicas) in the cluster are allocated.
</li>
</ul>
</div>
</dd>
<dt>
<span class="term">
<code class="literal">cluster.routing.allocation.cluster_concurrent_rebalance</code>
</span>
</dt>
<dd>
(<a class="xref" href="settings.html#dynamic-cluster-setting">Dynamic</a>)
Allow to control how many concurrent shard rebalances are
allowed cluster wide. Defaults to <code class="literal">2</code>. Note that this setting
only controls the number of concurrent shard relocations due
to imbalances in the cluster. This setting does not limit shard
relocations due to <a class="xref" href="modules-cluster.html#cluster-shard-allocation-filtering" title="Cluster-level shard allocation filtering">allocation
filtering</a> or <a class="xref" href="modules-cluster.html#forced-awareness" title="Forced awareness">forced awareness</a>.
</dd>
</dl>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="shards-rebalancing-heuristics"></a>Shard balancing heuristics settings<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.11/docs/reference/modules/cluster/shards_allocation.asciidoc">edit</a></h3>
</div></div></div>
<p>Rebalancing works by computing a <em>weight</em> for each node based on its allocation
of shards, and then moving shards between nodes to reduce the weight of the
heavier nodes and increase the weight of the lighter ones. The cluster is
balanced when there is no possible shard movement that can bring the weight of
any node closer to the weight of any other node by more than a configurable
threshold. The following settings allow you to control the details of these
calculations.</p>
<div class="variablelist">
<dl class="variablelist">
<dt>
<span class="term">
<code class="literal">cluster.routing.allocation.balance.shard</code>
</span>
</dt>
<dd>
(<a class="xref" href="settings.html#dynamic-cluster-setting">Dynamic</a>)
Defines the weight factor for the total number of shards allocated on a node
(float). Defaults to <code class="literal">0.45f</code>.  Raising this raises the tendency to
equalize the number of shards across all nodes in the cluster.
</dd>
<dt>
<span class="term">
<code class="literal">cluster.routing.allocation.balance.index</code>
</span>
</dt>
<dd>
(<a class="xref" href="settings.html#dynamic-cluster-setting">Dynamic</a>)
Defines the weight factor for the number of shards per index allocated
 on a specific node (float). Defaults to <code class="literal">0.55f</code>.  Raising this raises the
 tendency to equalize the number of shards per index across all nodes in
 the cluster.
</dd>
<dt>
<span class="term">
<code class="literal">cluster.routing.allocation.balance.threshold</code>
</span>
</dt>
<dd>
(<a class="xref" href="settings.html#dynamic-cluster-setting">Dynamic</a>)
Minimal optimization value of operations that should be performed (non
 negative float). Defaults to <code class="literal">1.0f</code>.  Raising this will cause the cluster
 to be less aggressive about optimizing the shard balance.
</dd>
</dl>
</div>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p>Regardless of the result of the balancing algorithm, rebalancing might
not be allowed due to forced awareness or allocation filtering.</p>
</div>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="disk-based-shard-allocation"></a>Disk-based shard allocation settings<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.11/docs/reference/modules/cluster/disk_allocator.asciidoc">edit</a></h3>
</div></div></div>
<p><a id="disk-based-shard-allocation-description"></a>The disk-based shard allocator ensures that all nodes have enough disk space
without performing more shard movements than necessary. It allocates shards
based on a pair of thresholds known as the <em>low watermark</em> and the <em>high
watermark</em>. Its primary goal is to ensure that no node exceeds the high
watermark, or at least that any such overage is only temporary. If a node
exceeds the high watermark then Elasticsearch will solve this by moving some of its
shards onto other nodes in the cluster.</p>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p>It is normal for nodes to temporarily exceed the high watermark from time
to time.</p>
</div>
</div>
<p>The allocator also tries to keep nodes clear of the high watermark by
forbidding the allocation of more shards to a node that exceeds the low
watermark. Importantly, if all of your nodes have exceeded the low watermark
then no new shards can be allocated and Elasticsearch will not be able to move any
shards between nodes in order to keep the disk usage below the high watermark.
You must ensure that your cluster has enough disk space in total and that there
are always some nodes below the low watermark.</p>
<p>Shard movements triggered by the disk-based shard allocator must also satisfy
all other shard allocation rules such as
<a class="xref" href="modules-cluster.html#cluster-shard-allocation-filtering" title="Cluster-level shard allocation filtering">allocation filtering</a> and
<a class="xref" href="modules-cluster.html#forced-awareness" title="Forced awareness">forced awareness</a>. If these rules are too strict then they
can also prevent the shard movements needed to keep the nodes' disk usage under
control. If you are using <a class="xref" href="data-tiers.html" title="Data tiers">data tiers</a> then Elasticsearch automatically
configures allocation filtering rules to place shards within the appropriate
tier, which means that the disk-based shard allocator works independently
within each tier.</p>
<p>If a node is filling up its disk faster than Elasticsearch can move shards elsewhere
then there is a risk that the disk will completely fill up. To prevent this, as
a last resort, once the disk usage reaches the <em>flood-stage</em> watermark Elasticsearch
will block writes to indices with a shard on the affected node. It will also
continue to move shards onto the other nodes in the cluster.  When disk usage
on the affected node drops below the high watermark, Elasticsearch automatically removes
the write block.</p>
<div class="tip admon">
<div class="icon"></div>
<div class="admon_content">
<a id="disk-based-shard-allocation-does-not-balance"></a>
<p>It is normal for the nodes in your cluster to be using very different amounts
of disk space. The <a class="xref" href="modules-cluster.html#shards-rebalancing-settings" title="Shard rebalancing settings">balance</a> of the cluster
depends only on the number of shards on each node and the indices to which
those shards belong. It considers neither the sizes of these shards nor the
available disk space on each node, for the following reasons:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
Disk usage changes over time. Balancing the disk usage of individual nodes
would require a lot more shard movements, perhaps even wastefully undoing
earlier movements. Moving a shard consumes resources such as I/O and network
bandwidth and may evict data from the filesystem cache. These resources are
better spent handling your searches and indexing where possible.
</li>
<li class="listitem">
A cluster with equal disk usage on every node typically performs no better
than one that has unequal disk usage, as long as no disk is too full.
</li>
</ul>
</div>
</div>
</div>
<p>You can use the following settings to control disk-based allocation:</p>
<div class="variablelist">
<a id="cluster-routing-disk-threshold"></a>
<dl class="variablelist">
<dt>
<span class="term">
<code class="literal">cluster.routing.allocation.disk.threshold_enabled</code> <span class="image"><a class="image" href="https://www.elastic.co/cloud/elasticsearch-service/signup?baymax=docs-body&amp;elektra=docs"><img src="https://doc-icons.s3.us-east-2.amazonaws.com/logo_cloud.svg" alt="logo cloud" title="Supported on Elasticsearch Service"></a></span>
</span>
</dt>
<dd>
(<a class="xref" href="settings.html#dynamic-cluster-setting">Dynamic</a>)
Defaults to <code class="literal">true</code>.  Set to <code class="literal">false</code> to disable the disk allocation decider.
</dd>
</dl>
</div>
<div class="variablelist">
<a id="cluster-routing-watermark-low"></a>
<dl class="variablelist">
<dt>
<span class="term">
<code class="literal">cluster.routing.allocation.disk.watermark.low</code> <span class="image"><a class="image" href="https://www.elastic.co/cloud/elasticsearch-service/signup?baymax=docs-body&amp;elektra=docs"><img src="https://doc-icons.s3.us-east-2.amazonaws.com/logo_cloud.svg" alt="logo cloud" title="Supported on Elasticsearch Service"></a></span>
</span>
</dt>
<dd>
(<a class="xref" href="settings.html#dynamic-cluster-setting">Dynamic</a>)
Controls the low watermark for disk usage. It defaults to <code class="literal">85%</code>, meaning that Elasticsearch will not allocate shards to nodes that have more than 85% disk used. It can also be set to an absolute byte value (like <code class="literal">500mb</code>) to prevent Elasticsearch from allocating shards if less than the specified amount of space is available. This setting has no effect on the primary shards of newly-created indices but will prevent their replicas from being allocated.
</dd>
</dl>
</div>
<div class="variablelist">
<a id="cluster-routing-watermark-high"></a>
<dl class="variablelist">
<dt>
<span class="term">
<code class="literal">cluster.routing.allocation.disk.watermark.high</code> <span class="image"><a class="image" href="https://www.elastic.co/cloud/elasticsearch-service/signup?baymax=docs-body&amp;elektra=docs"><img src="https://doc-icons.s3.us-east-2.amazonaws.com/logo_cloud.svg" alt="logo cloud" title="Supported on Elasticsearch Service"></a></span>
</span>
</dt>
<dd>
(<a class="xref" href="settings.html#dynamic-cluster-setting">Dynamic</a>)
Controls the high watermark. It defaults to <code class="literal">90%</code>, meaning that Elasticsearch will attempt to relocate shards away from a node whose disk usage is above 90%. It can also be set to an absolute byte value (similarly to the low watermark) to relocate shards away from a node if it has less than the specified amount of free space. This setting affects the allocation of all shards, whether previously allocated or not.
</dd>
<dt>
<span class="term">
<code class="literal">cluster.routing.allocation.disk.watermark.enable_for_single_data_node</code>
</span>
</dt>
<dd>
(<a class="xref" href="settings.html#static-cluster-setting">Static</a>)
For a single data node, the default is to disregard disk watermarks when
making an allocation decision. This is deprecated behavior and will be
changed in 8.0. This setting can be set to <code class="literal">true</code> to enable the
disk watermarks for a single data node cluster (will become default in 8.0).
</dd>
</dl>
</div>
<div class="variablelist">
<a id="cluster-routing-flood-stage"></a>
<dl class="variablelist">
<dt>
<span class="term">
<code class="literal">cluster.routing.allocation.disk.watermark.flood_stage</code> <span class="image"><a class="image" href="https://www.elastic.co/cloud/elasticsearch-service/signup?baymax=docs-body&amp;elektra=docs"><img src="https://doc-icons.s3.us-east-2.amazonaws.com/logo_cloud.svg" alt="logo cloud" title="Supported on Elasticsearch Service"></a></span>
</span>
</dt>
<dd>
<p>(<a class="xref" href="settings.html#dynamic-cluster-setting">Dynamic</a>)
Controls the flood stage watermark, which defaults to 95%. Elasticsearch enforces a read-only index block (<code class="literal">index.blocks.read_only_allow_delete</code>) on every index that has one or more shards allocated on the node, and that has at least one disk exceeding the flood stage. This setting is a last resort to prevent nodes from running out of disk space. The index block is automatically released when the disk utilization falls below the high watermark.</p>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p>You cannot mix the usage of percentage values and byte values within
these settings. Either all values are set to percentage values, or all are set to byte values. This enforcement is so that Elasticsearch can validate that the settings are internally consistent, ensuring that the low disk threshold is less than the high disk threshold, and the high disk threshold is less than the flood stage threshold.</p>
</div>
</div>
<p>An example of resetting the read-only index block on the <code class="literal">my-index-000001</code> index:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">PUT /my-index-000001/_settings
{
  "index.blocks.read_only_allow_delete": null
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/19.console"></div>
</dd>
<dt>
<span class="term">
<code class="literal">cluster.info.update.interval</code>
</span>
</dt>
<dd>
(<a class="xref" href="settings.html#dynamic-cluster-setting">Dynamic</a>)
How often Elasticsearch should check on disk usage for each node in the
cluster. Defaults to <code class="literal">30s</code>.
</dd>
<dt>
<span class="term">
<code class="literal">cluster.routing.allocation.disk.include_relocations</code>
</span>
</dt>
<dd>
<span class="Admonishment Admonishment--change">
[<span class="Admonishment-version u-mono u-strikethrough">7.5.0</span>]
<span class="Admonishment-detail">
Deprecated in 7.5.0. Future versions will always account for relocations.
</span>
</span>
Defaults to <code class="literal">true</code>, which means that Elasticsearch will take into account
shards that are currently being relocated to the target node when computing
a node&#8217;s disk usage. Taking relocating shards' sizes into account may,
however, mean that the disk usage for a node is incorrectly estimated on
the high side, since the relocation could be 90% complete and a recently
retrieved disk usage would include the total size of the relocating shard
as well as the space already used by the running relocation.
</dd>
</dl>
</div>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p>Percentage values refer to used disk space, while byte values refer to
free disk space. This can be confusing, since it flips the meaning of high and
low. For example, it makes sense to set the low watermark to 10gb and the high
watermark to 5gb, but not the other way around.</p>
</div>
</div>
<p>An example of updating the low watermark to at least 100 gigabytes free, a high
watermark of at least 50 gigabytes free, and a flood stage watermark of 10
gigabytes free, and updating the information about the cluster every minute:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">PUT _cluster/settings
{
  "transient": {
    "cluster.routing.allocation.disk.watermark.low": "100gb",
    "cluster.routing.allocation.disk.watermark.high": "50gb",
    "cluster.routing.allocation.disk.watermark.flood_stage": "10gb",
    "cluster.info.update.interval": "1m"
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/20.console"></div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="shard-allocation-awareness"></a>Shard allocation awareness<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.11/docs/reference/modules/cluster/allocation_awareness.asciidoc">edit</a></h3>
</div></div></div>
<p>You can use custom node attributes as <em>awareness attributes</em> to enable Elasticsearch
to take your physical hardware configuration into account when allocating shards.
If Elasticsearch knows which nodes are on the same physical server, in the same rack, or
in the same zone, it can distribute the primary shard and its replica shards to
minimise the risk of losing all shard copies in the event of a failure.</p>
<p>When shard allocation awareness is enabled with the
<a class="xref" href="settings.html#dynamic-cluster-setting">dynamic</a>
<code class="literal">cluster.routing.allocation.awareness.attributes</code> setting, shards are only
allocated to nodes that have values set for the specified awareness attributes.
If you use multiple awareness attributes, Elasticsearch considers each attribute
separately when allocating shards.</p>
<p>By default Elasticsearch uses <a class="xref" href="search-shard-routing.html#search-adaptive-replica" title="Adaptive replica selection">adaptive replica selection</a>
to route search or GET requests. However, with the presence of allocation awareness
attributes Elasticsearch will prefer using shards in the same location (with the same
awareness attribute values) to process these requests. This behavior can be
disabled by specifying <code class="literal">export ES_JAVA_OPTS="$ES_JAVA_OPTS -Des.search.ignore_awareness_attributes=true"</code>
system property on every node that is part of the cluster.</p>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p>The number of attribute values determines how many shard copies are
allocated in each location. If the number of nodes in each location is
unbalanced and there are a lot of replicas, replica shards might be left
unassigned.</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="enabling-awareness"></a>Enabling shard allocation awareness<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.11/docs/reference/modules/cluster/allocation_awareness.asciidoc">edit</a></h4>
</div></div></div>
<p>To enable shard allocation awareness:</p>
<div class="olist orderedlist">
<ol class="orderedlist">
<li class="listitem">
<p>Specify the location of each node with a custom node attribute. For example,
if you want Elasticsearch to distribute shards across different racks, you might
set an awareness attribute called <code class="literal">rack_id</code> in each node&#8217;s <code class="literal">elasticsearch.yml</code>
config file.</p>
<div class="pre_wrapper lang-yaml">
<pre class="programlisting prettyprint lang-yaml">node.attr.rack_id: rack_one</pre>
</div>
<p>You can also set custom attributes when you start a node:</p>
<div class="pre_wrapper lang-sh">
<pre class="programlisting prettyprint lang-sh">`./bin/elasticsearch -Enode.attr.rack_id=rack_one`</pre>
</div>
</li>
<li class="listitem">
<p>Tell Elasticsearch to take one or more awareness attributes into account when
allocating shards by setting
<code class="literal">cluster.routing.allocation.awareness.attributes</code> in <span class="strong strong"><strong>every</strong></span> master-eligible
node&#8217;s <code class="literal">elasticsearch.yml</code> config file.</p>
<div class="pre_wrapper lang-yaml">
<pre class="programlisting prettyprint lang-yaml">cluster.routing.allocation.awareness.attributes: rack_id <a id="CO7-1"></a><i class="conum" data-value="1"></i></pre>
</div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO7-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>Specify multiple attributes as a comma-separated list.</p>
</td>
</tr>
</table>
</div>
<p>You can also use the
<a class="xref" href="cluster-update-settings.html" title="Cluster update settings API">cluster-update-settings</a> API to set or update
a cluster&#8217;s awareness attributes.</p>
</li>
</ol>
</div>
<p>With this example configuration, if you start two nodes with
<code class="literal">node.attr.rack_id</code> set to <code class="literal">rack_one</code> and create an index with 5 primary
shards and 1 replica of each primary, all primaries and replicas are
allocated across the two nodes.</p>
<p>If you add two nodes with <code class="literal">node.attr.rack_id</code> set to <code class="literal">rack_two</code>,
Elasticsearch moves shards to the new nodes, ensuring (if possible)
that no two copies of the same shard are in the same rack.</p>
<p>If <code class="literal">rack_two</code> fails and takes down both its nodes, by default Elasticsearch
allocates the lost shard copies to nodes in <code class="literal">rack_one</code>. To prevent multiple
copies of a particular shard from being allocated in the same location, you can
enable forced awareness.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="forced-awareness"></a>Forced awareness<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.11/docs/reference/modules/cluster/allocation_awareness.asciidoc">edit</a></h4>
</div></div></div>
<p>By default, if one location fails, Elasticsearch assigns all of the missing
replica shards to the remaining locations. While you might have sufficient
resources across all locations to host your primary and replica shards, a single
location might be unable to host <span class="strong strong"><strong>ALL</strong></span> of the shards.</p>
<p>To prevent a single location from being overloaded in the event of a failure,
you can set <code class="literal">cluster.routing.allocation.awareness.force</code> so no replicas are
allocated until nodes are available in another location.</p>
<p>For example, if you have an awareness attribute called <code class="literal">zone</code> and configure nodes
in <code class="literal">zone1</code> and <code class="literal">zone2</code>, you can use forced awareness to prevent Elasticsearch
from allocating replicas if only one zone is available:</p>
<div class="pre_wrapper lang-yaml">
<pre class="programlisting prettyprint lang-yaml">cluster.routing.allocation.awareness.attributes: zone
cluster.routing.allocation.awareness.force.zone.values: zone1,zone2 <a id="CO8-1"></a><i class="conum" data-value="1"></i></pre>
</div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO8-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>Specify all possible values for the awareness attribute.</p>
</td>
</tr>
</table>
</div>
<p>With this example configuration, if you start two nodes with <code class="literal">node.attr.zone</code> set
to <code class="literal">zone1</code> and create an index with 5 shards and 1 replica, Elasticsearch creates
the index and allocates the 5 primary shards but no replicas. Replicas are
only allocated once nodes with <code class="literal">node.attr.zone</code> set to <code class="literal">zone2</code> are available.</p>
</div>

</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="cluster-shard-allocation-filtering"></a>Cluster-level shard allocation filtering<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.11/docs/reference/modules/cluster/allocation_filtering.asciidoc">edit</a></h3>
</div></div></div>
<p>You can use cluster-level shard allocation filters to control where Elasticsearch
allocates shards from any index. These cluster wide filters are applied in
conjunction with <a class="xref" href="shard-allocation-filtering.html" title="Index-level shard allocation filtering">per-index allocation filtering</a>
and <a class="xref" href="modules-cluster.html#shard-allocation-awareness" title="Shard allocation awareness">allocation awareness</a>.</p>
<p>Shard allocation filters can be based on custom node attributes or the built-in
<code class="literal">_name</code>, <code class="literal">_host_ip</code>, <code class="literal">_publish_ip</code>, <code class="literal">_ip</code>, <code class="literal">_host</code>, <code class="literal">_id</code> and <code class="literal">_tier</code> attributes.</p>
<p>The <code class="literal">cluster.routing.allocation</code> settings are <a class="xref" href="settings.html#dynamic-cluster-setting">dynamic</a>, enabling live indices to
be moved from one set of nodes to another. Shards are only relocated if it is
possible to do so without breaking another routing constraint, such as never
allocating a primary and replica shard on the same node.</p>
<p>The most common use case for cluster-level shard allocation filtering is when
you want to decommission a node. To move shards off of a node prior to shutting
it down, you could create a filter that excludes the node by its IP address:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">PUT _cluster/settings
{
  "transient" : {
    "cluster.routing.allocation.exclude._ip" : "10.0.0.1"
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/21.console"></div>
<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="cluster-routing-settings"></a>Cluster routing settings<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.11/docs/reference/modules/cluster/allocation_filtering.asciidoc">edit</a></h4>
</div></div></div>
<div class="variablelist">
<dl class="variablelist">
<dt>
<span class="term">
<code class="literal">cluster.routing.allocation.include.{attribute}</code>
</span>
</dt>
<dd>
(<a class="xref" href="settings.html#dynamic-cluster-setting">Dynamic</a>)
Allocate shards to a node whose <code class="literal">{attribute}</code> has at least one of the
comma-separated values.
</dd>
<dt>
<span class="term">
<code class="literal">cluster.routing.allocation.require.{attribute}</code>
</span>
</dt>
<dd>
(<a class="xref" href="settings.html#dynamic-cluster-setting">Dynamic</a>)
Only allocate shards to a node whose <code class="literal">{attribute}</code> has <em>all</em> of the
comma-separated values.
</dd>
<dt>
<span class="term">
<code class="literal">cluster.routing.allocation.exclude.{attribute}</code>
</span>
</dt>
<dd>
(<a class="xref" href="settings.html#dynamic-cluster-setting">Dynamic</a>)
Do not allocate shards to a node whose <code class="literal">{attribute}</code> has <em>any</em> of the
comma-separated values.
</dd>
</dl>
</div>
<p>The cluster allocation settings support the following built-in attributes:</p>
<div class="informaltable">
<table border="0" cellpadding="4px">
<colgroup>
<col/>
<col/>
</colgroup>
<tbody valign="top">
<tr>
<td valign="top">
<p>
<code class="literal">_name</code>
</p>
</td>
<td valign="top">
<p>
Match nodes by node name
</p>
</td>
</tr>
<tr>
<td valign="top">
<p>
<code class="literal">_host_ip</code>
</p>
</td>
<td valign="top">
<p>
Match nodes by host IP address (IP associated with hostname)
</p>
</td>
</tr>
<tr>
<td valign="top">
<p>
<code class="literal">_publish_ip</code>
</p>
</td>
<td valign="top">
<p>
Match nodes by publish IP address
</p>
</td>
</tr>
<tr>
<td valign="top">
<p>
<code class="literal">_ip</code>
</p>
</td>
<td valign="top">
<p>
Match either <code class="literal">_host_ip</code> or <code class="literal">_publish_ip</code>
</p>
</td>
</tr>
<tr>
<td valign="top">
<p>
<code class="literal">_host</code>
</p>
</td>
<td valign="top">
<p>
Match nodes by hostname
</p>
</td>
</tr>
<tr>
<td valign="top">
<p>
<code class="literal">_id</code>
</p>
</td>
<td valign="top">
<p>
Match nodes by node id
</p>
</td>
</tr>
<tr>
<td valign="top">
<p>
<code class="literal">_tier</code>
</p>
</td>
<td valign="top">
<p>
Match nodes by the node&#8217;s <a class="xref" href="data-tiers.html" title="Data tiers">data tier</a> role
</p>
</td>
</tr>
</tbody>
</table>
</div>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p><code class="literal">_tier</code> filtering is based on <a class="xref" href="modules-node.html" title="Node">node</a> roles. Only
a subset of roles are <a class="xref" href="data-tiers.html" title="Data tiers">data tier</a> roles, and the generic
<a class="xref" href="modules-node.html#data-node" title="Data node">data role</a> will match any tier filtering.
a subset of roles that are <a class="xref" href="data-tiers.html" title="Data tiers">data tier</a> roles, but the generic
<a class="xref" href="modules-node.html#data-node" title="Data node">data role</a> will match any tier filtering.</p>
</div>
</div>
<p>You can use wildcards when specifying attribute values, for example:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">PUT _cluster/settings
{
  "transient": {
    "cluster.routing.allocation.exclude._ip": "192.168.2.*"
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/22.console"></div>
</div>

</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="misc-cluster-settings"></a>Miscellaneous cluster settings<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.11/docs/reference/modules/cluster/misc.asciidoc">edit</a></h3>
</div></div></div>
<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="cluster-read-only"></a>Metadata<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.11/docs/reference/modules/cluster/misc.asciidoc">edit</a></h4>
</div></div></div>
<p>An entire cluster may be set to read-only with the following setting:</p>
<div class="variablelist">
<dl class="variablelist">
<dt>
<span class="term">
<code class="literal">cluster.blocks.read_only</code>
</span>
</dt>
<dd>
(<a class="xref" href="settings.html#dynamic-cluster-setting">Dynamic</a>)
Make the whole cluster read only (indices do not accept write
operations), metadata is not allowed to be modified (create or delete
indices).
</dd>
<dt>
<span class="term">
<code class="literal">cluster.blocks.read_only_allow_delete</code>
</span>
</dt>
<dd>
(<a class="xref" href="settings.html#dynamic-cluster-setting">Dynamic</a>)
Identical to <code class="literal">cluster.blocks.read_only</code> but allows to delete indices
to free up resources.
</dd>
</dl>
</div>
<div class="warning admon">
<div class="icon"></div>
<div class="admon_content">
<p>Don&#8217;t rely on this setting to prevent changes to your cluster. Any
user with access to the <a class="xref" href="cluster-update-settings.html" title="Cluster update settings API">cluster-update-settings</a>
API can make the cluster read-write again.</p>
</div>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="cluster-shard-limit"></a>Cluster shard limit<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.11/docs/reference/modules/cluster/misc.asciidoc">edit</a></h4>
</div></div></div>
<p>There is a soft limit on the number of shards in a cluster, based on the number
of nodes in the cluster. This is intended to prevent operations which may
unintentionally destabilize the cluster.</p>
<div class="important admon">
<div class="icon"></div>
<div class="admon_content">
<p>This limit is intended as a safety net, not a sizing recommendation. The
exact number of shards your cluster can safely support depends on your hardware
configuration and workload, but should remain well below this limit in almost
all cases, as the default limit is set quite high.</p>
</div>
</div>
<p>If an operation, such as creating a new index, restoring a snapshot of an index,
or opening a closed index would lead to the number of shards in the cluster
going over this limit, the operation will fail with an error indicating the
shard limit.</p>
<p>If the cluster is already over the limit, due to changes in node membership or
setting changes, all operations that create or open indices will fail until
either the limit is increased as described below, or some indices are
<a class="xref" href="indices-open-close.html" title="Open index API">closed</a> or <a class="xref" href="indices-delete-index.html" title="Delete index API">deleted</a> to bring the
number of shards below the limit.</p>
<p>The cluster shard limit defaults to 1,000 shards per data node.
Both primary and replica shards of all open indices count toward the limit,
including unassigned shards.
For example, an open index with 5 primary shards and 2 replicas counts as 15 shards.
Closed indices do not contribute to the shard count.</p>
<p>You can dynamically adjust the cluster shard limit with the following setting:</p>
<div class="variablelist">
<a id="cluster-max-shards-per-node"></a>
<dl class="variablelist">
<dt>
<span class="term">
<code class="literal">cluster.max_shards_per_node</code>
</span>
</dt>
<dd>
<p>(<a class="xref" href="settings.html#dynamic-cluster-setting">Dynamic</a>)
Limits the total number of primary and replica shards for the cluster. Elasticsearch
calculates the limit as follows:</p>
<p><code class="literal">cluster.max_shards_per_node * number of data nodes</code></p>
<p>Shards for closed indices do not count toward this limit. Defaults to <code class="literal">1000</code>.
A cluster with no data nodes is unlimited.</p>
<p>Elasticsearch rejects any request that creates more shards than this limit allows. For
example, a cluster with a <code class="literal">cluster.max_shards_per_node</code> setting of <code class="literal">100</code> and
three data nodes has a shard limit of 300. If the cluster already contains 296
shards, Elasticsearch rejects any request that adds five or more shards to the cluster.</p>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p>This setting does not limit shards for individual nodes. To limit the
number of shards for each node, use the
<a class="xref" href="allocation-total-shards.html#cluster-total-shards-per-node"><code class="literal">cluster.routing.allocation.total_shards_per_node</code></a>
setting.</p>
</div>
</div>
</dd>
</dl>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="user-defined-data"></a>User-defined cluster metadata<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.11/docs/reference/modules/cluster/misc.asciidoc">edit</a></h4>
</div></div></div>
<p>User-defined metadata can be stored and retrieved using the Cluster Settings API.
This can be used to store arbitrary, infrequently-changing data about the cluster
without the need to create an index to store it. This data may be stored using
any key prefixed with <code class="literal">cluster.metadata.</code>.  For example, to store the email
address of the administrator of a cluster under the key <code class="literal">cluster.metadata.administrator</code>,
issue this request:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">PUT /_cluster/settings
{
  "persistent": {
    "cluster.metadata.administrator": "sysadmin@example.com"
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/23.console"></div>
<div class="important admon">
<div class="icon"></div>
<div class="admon_content">
<p>User-defined cluster metadata is not intended to store sensitive or
confidential information. Any information stored in user-defined cluster
metadata will be viewable by anyone with access to the
<a class="xref" href="cluster-get-settings.html" title="Cluster get settings API">Cluster Get Settings</a> API, and is recorded in the
Elasticsearch logs.</p>
</div>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="cluster-max-tombstones"></a>Index tombstones<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.11/docs/reference/modules/cluster/misc.asciidoc">edit</a></h4>
</div></div></div>
<p>The cluster state maintains index tombstones to explicitly denote indices that
have been deleted.  The number of tombstones maintained in the cluster state is
controlled by the following setting:</p>
<div class="variablelist">
<dl class="variablelist">
<dt>
<span class="term">
<code class="literal">cluster.indices.tombstones.size</code>
</span>
</dt>
<dd>
(<a class="xref" href="settings.html#static-cluster-setting">Static</a>)
Index tombstones prevent nodes that are not part of the cluster when a delete
occurs from joining the cluster and reimporting the index as though the delete
was never issued. To keep the cluster state from growing huge we only keep the
last <code class="literal">cluster.indices.tombstones.size</code> deletes, which defaults to 500. You can
increase it if you expect nodes to be absent from the cluster and miss more
than 500 deletes. We think that is rare, thus the default. Tombstones don&#8217;t take
up much space, but we also think that a number like 50,000 is probably too big.
</dd>
</dl>
</div>
<p>If Elasticsearch encounters index data that is absent from the current cluster
state, those indices are considered to be dangling. For example,
this can happen if you delete more than
<code class="literal">cluster.indices.tombstones.size</code> indices while an Elasticsearch node is offline.</p>
<p>You can use the <a class="xref" href="indices.html#dangling-indices-api" title="Dangling indices:">Dangling indices API</a> to manage
this situation.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="cluster-logger"></a>Logger<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.11/docs/reference/modules/cluster/misc.asciidoc">edit</a></h4>
</div></div></div>
<p>The settings which control logging can be updated <a class="xref" href="settings.html#dynamic-cluster-setting">dynamically</a> with the
<code class="literal">logger.</code> prefix.  For instance, to increase the logging level of the
<code class="literal">indices.recovery</code> module to <code class="literal">DEBUG</code>, issue this request:</p>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">PUT /_cluster/settings
{
  "transient": {
    "logger.org.elasticsearch.indices.recovery": "DEBUG"
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/24.console"></div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="persistent-tasks-allocation"></a>Persistent tasks allocation<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/7.11/docs/reference/modules/cluster/misc.asciidoc">edit</a></h4>
</div></div></div>
<p>Plugins can create a kind of tasks called persistent tasks. Those tasks are
usually long-lived tasks and are stored in the cluster state, allowing the
tasks to be revived after a full cluster restart.</p>
<p>Every time a persistent task is created, the master node takes care of
assigning the task to a node of the cluster, and the assigned node will then
pick up the task and execute it locally. The process of assigning persistent
tasks to nodes is controlled by the following settings:</p>
<div class="variablelist">
<dl class="variablelist">
<dt>
<span class="term">
<code class="literal">cluster.persistent_tasks.allocation.enable</code>
</span>
</dt>
<dd>
<p>(<a class="xref" href="settings.html#dynamic-cluster-setting">Dynamic</a>)
Enable or disable allocation for persistent tasks:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
<code class="literal">all</code> -             (default) Allows persistent tasks to be assigned to nodes
</li>
<li class="listitem">
<code class="literal">none</code> -            No allocations are allowed for any type of persistent task
</li>
</ul>
</div>
<p>This setting does not affect the persistent tasks that are already being executed.
Only newly created persistent tasks, or tasks that must be reassigned (after a node
left the cluster, for example), are impacted by this setting.</p>
</dd>
<dt>
<span class="term">
<code class="literal">cluster.persistent_tasks.allocation.recheck_interval</code>
</span>
</dt>
<dd>
(<a class="xref" href="settings.html#dynamic-cluster-setting">Dynamic</a>)
The master node will automatically check whether persistent tasks need to
be assigned when the cluster state changes significantly. However, there
may be other factors, such as memory usage, that affect whether persistent
tasks can be assigned to nodes but do not cause the cluster state to change.
This setting controls how often assignment checks are performed to react to
these factors. The default is 30 seconds. The minimum permitted value is 10
seconds.
</dd>
</dl>
</div>
</div>

</div>

</div>
<div class="navfooter">
<span class="prev">
<a href="circuit-breaker.html">« Circuit breaker settings</a>
</span>
<span class="next">
<a href="ccr-settings.html">Cross-cluster replication settings »</a>
</span>
</div>
</div>
</body>
</html>
