<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Nested datatype | Elasticsearch Reference [master] | Elastic</title>
<link rel="home" href="index.html" title="Elasticsearch Reference [master]"/>
<link rel="up" href="mapping-types.html" title="Field datatypes"/>
<link rel="prev" href="keyword.html" title="Keyword datatype"/>
<link rel="next" href="number.html" title="Numeric datatypes"/>
<meta name="DC.type" content="Learn/Docs/Elasticsearch/Reference/master"/>
<meta name="DC.subject" content="Elasticsearch"/>
<meta name="DC.identifier" content="master"/>
</head>
<body><div class="page_header">
You are looking at preliminary documentation for a future release.
Not what you want? See the
<a href="../current/index.html">current release documentation</a>.
</div>
<div id="content">
<div class="breadcrumbs">
<span class="breadcrumb-link"><a href="index.html">Elasticsearch Reference [master]</a></span>
»
<span class="breadcrumb-link"><a href="mapping.html">Mapping</a></span>
»
<span class="breadcrumb-link"><a href="mapping-types.html">Field datatypes</a></span>
»
<span class="breadcrumb-node">Nested datatype</span>
</div>
<div class="navheader">
<span class="prev">
<a href="keyword.html">« Keyword datatype</a>
</span>
<span class="next">
<a href="number.html">Numeric datatypes »</a>
</span>
</div>
<div class="section">
<div class="titlepage"><div><div>
<h2 class="title"><a id="nested"></a>Nested datatype<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/master/docs/reference/mapping/types/nested.asciidoc">edit</a></h2>
</div></div></div>

<p>The <code class="literal">nested</code> type is a specialised version of the <a class="xref" href="object.html" title="Object datatype"><code class="literal">object</code></a> datatype
that allows arrays of objects to be indexed in a way that they can be queried
independently of each other.</p>
<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_how_arrays_of_objects_are_flattened"></a>How arrays of objects are flattened<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/master/docs/reference/mapping/types/nested.asciidoc">edit</a></h3>
</div></div></div>
<p>Arrays of inner <a class="xref" href="object.html" title="Object datatype"><code class="literal">object</code> fields</a> do not work the way you may expect.
Lucene has no concept of inner objects, so Elasticsearch flattens object
hierarchies into a simple list of field names and values. For instance, the
following document:</p>
<div class="pre_wrapper lang-csharp alternative">
<pre class="programlisting prettyprint lang-csharp alternative">var indexResponse = client.Index(new GroupDoc
{
    Group = "fans",
    User = new List&lt;User&gt;
                    {
                        new User { First = "John", Last = "Smith" },
                        new User { First = "Alice", Last = "White" }
                    }
}, i =&gt; i
.Index("my_index")
.Id(1)
);</pre>
</div>
<div class="pre_wrapper lang-python alternative">
<pre class="programlisting prettyprint lang-python alternative">resp = client.index(
    index="my_index",
    id="1",
    body={
        "group": "fans",
        "user": [
            {"first": "John", "last": "Smith"},
            {"first": "Alice", "last": "White"},
        ],
    },
)
print(resp)</pre>
</div>
<div class="pre_wrapper lang-ruby alternative">
<pre class="programlisting prettyprint lang-ruby alternative">response = client.index(
  index: 'my_index',
  id: 1,
  body: {
    group: 'fans',
    user: [
      {
        first: 'John',
        last: 'Smith'
      },
      {
        first: 'Alice',
        last: 'White'
      }
    ]
  }
)
puts response</pre>
</div>
<div class="pre_wrapper lang-go alternative">
<pre class="programlisting prettyprint lang-go alternative">res, err := es.Index(
	"my_index",
	strings.NewReader(`{
	  "group": "fans",
	  "user": [
	    {
	      "first": "John",
	      "last": "Smith"
	    },
	    {
	      "first": "Alice",
	      "last": "White"
	    }
	  ]
	}`),
	es.Index.WithDocumentID("1"),
	es.Index.WithPretty(),
)
fmt.Println(res, err)</pre>
</div>
<div class="pre_wrapper lang-js alternative">
<pre class="programlisting prettyprint lang-js alternative">const response = await client.index({
  index: 'my_index',
  id: '1',
  body: {
    group: 'fans',
    user: [
      {
        first: 'John',
        last: 'Smith'
      },
      {
        first: 'Alice',
        last: 'White'
      }
    ]
  }
})
console.log(response)</pre>
</div>
<a id="8baccd8688a6bad1749b8935f9601ea4"></a>
<div class="pre_wrapper lang-console default has-csharp has-python has-ruby has-go has-js">
<pre class="programlisting prettyprint lang-console default has-csharp has-python has-ruby has-go has-js">PUT my_index/_doc/1
{
  "group" : "fans",
  "user" : [ <a id="CO300-1"></a><i class="conum" data-value="1"></i>
    {
      "first" : "John",
      "last" :  "Smith"
    },
    {
      "first" : "Alice",
      "last" :  "White"
    }
  ]
}</pre>
</div>
<div class="console_widget has-csharp has-python has-ruby has-go has-js" data-snippet="snippets/626.console"></div>
<div class="calloutlist default has-csharp has-python has-ruby has-go has-js lang-console">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO300-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>The <code class="literal">user</code> field is dynamically added as a field of type <code class="literal">object</code>.</p>
</td>
</tr>
</table>
</div>
<p>would be transformed internally into a document that looks more like this:</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">{
  "group" :        "fans",
  "user.first" : [ "alice", "john" ],
  "user.last" :  [ "smith", "white" ]
}</pre>
</div>
<p>The <code class="literal">user.first</code> and <code class="literal">user.last</code> fields are flattened into multi-value fields,
and the association between <code class="literal">alice</code> and <code class="literal">white</code> is lost.  This document would
incorrectly match a query for <code class="literal">alice AND smith</code>:</p>
<div class="pre_wrapper lang-csharp alternative">
<pre class="programlisting prettyprint lang-csharp alternative">var searchResponse = client.Search&lt;GroupDoc&gt;(s =&gt; s
    .Index("my_index")
    .Query(q =&gt; q
        .Match(m =&gt; m
            .Field(f =&gt; f.User[0].First) <a id="A648-CO1-1"></a><i class="conum" data-value="1"></i>
            .Query("Alice")
        ) &amp;&amp; q
        .Match(m =&gt; m
            .Field(f =&gt; f.User[0].Last) <a id="A648-CO1-2"></a><i class="conum" data-value="2"></i>
            .Query("Smith")
        )
    )
);</pre>
</div>
<div class="pre_wrapper lang-python alternative">
<pre class="programlisting prettyprint lang-python alternative">resp = client.search(
    index="my_index",
    body={
        "query": {
            "bool": {
                "must": [
                    {"match": {"user.first": "Alice"}},
                    {"match": {"user.last": "Smith"}},
                ]
            }
        }
    },
)
print(resp)</pre>
</div>
<div class="pre_wrapper lang-ruby alternative">
<pre class="programlisting prettyprint lang-ruby alternative">response = client.search(
  index: 'my_index',
  body: {
    query: {
      bool: {
        must: [
          {
            match: {
              "user.first": 'Alice'
            }
          },
          {
            match: {
              "user.last": 'Smith'
            }
          }
        ]
      }
    }
  }
)
puts response</pre>
</div>
<div class="pre_wrapper lang-go alternative">
<pre class="programlisting prettyprint lang-go alternative">res, err := es.Search(
	es.Search.WithIndex("my_index"),
	es.Search.WithBody(strings.NewReader(`{
	  "query": {
	    "bool": {
	      "must": [
	        {
	          "match": {
	            "user.first": "Alice"
	          }
	        },
	        {
	          "match": {
	            "user.last": "Smith"
	          }
	        }
	      ]
	    }
	  }
	}`)),
	es.Search.WithPretty(),
)
fmt.Println(res, err)</pre>
</div>
<div class="pre_wrapper lang-js alternative">
<pre class="programlisting prettyprint lang-js alternative">const response = await client.search({
  index: 'my_index',
  body: {
    query: {
      bool: {
        must: [
          {
            match: {
              'user.first': 'Alice'
            }
          },
          {
            match: {
              'user.last': 'Smith'
            }
          }
        ]
      }
    }
  }
})
console.log(response)</pre>
</div>
<a id="b214942b938e47f2c486e523546cb574"></a>
<div class="pre_wrapper lang-console default has-csharp has-python has-ruby has-go has-js">
<pre class="programlisting prettyprint lang-console default has-csharp has-python has-ruby has-go has-js">GET my_index/_search
{
  "query": {
    "bool": {
      "must": [
        { "match": { "user.first": "Alice" }},
        { "match": { "user.last":  "Smith" }}
      ]
    }
  }
}</pre>
</div>
<div class="console_widget has-csharp has-python has-ruby has-go has-js" data-snippet="snippets/627.console"></div>
<div class="calloutlist alternative lang-csharp">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#A648-CO1-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>An expression to build a path to the field <code class="literal">user.first</code> from the <code class="literal">GroupDoc</code> type.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#A648-CO1-2"><i class="conum" data-value="2"></i></a></p>
</td>
<td align="left" valign="top">
<p>An expression to build a path to the field <code class="literal">user.last</code> from the <code class="literal">GroupDoc</code> type.</p>
</td>
</tr>
</table>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="nested-fields-array-objects"></a>Using <code class="literal">nested</code> fields for arrays of objects<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/master/docs/reference/mapping/types/nested.asciidoc">edit</a></h3>
</div></div></div>
<p>If you need to index arrays of objects and to maintain the independence of
each object in the array, you should use the <code class="literal">nested</code> datatype instead of the
<a class="xref" href="object.html" title="Object datatype"><code class="literal">object</code></a> datatype.  Internally, nested objects index each object in
the array as a separate hidden document, meaning that each nested object can be
queried independently of the others, with the <a class="xref" href="query-dsl-nested-query.html" title="Nested query"><code class="literal">nested</code> query</a>:</p>
<div class="pre_wrapper lang-csharp alternative">
<pre class="programlisting prettyprint lang-csharp alternative">var createIndexResponse = client.Indices.Create("my_index", c =&gt; c
    .Map&lt;GroupDoc&gt;(m =&gt; m
        .Properties(p =&gt; p
            .Nested&lt;User&gt;(n =&gt; n
                .Name(nn =&gt; nn.User)
            )
        )
    )
);

var indexResponse = client.Index(new GroupDoc
{
    Group = "fans",
    User = new List&lt;User&gt;
                    {
                        new User { First = "John", Last = "Smith" },
                        new User { First = "Alice", Last = "White" }
                    }
}, i =&gt; i
    .Index("my_index")
    .Id(1)
);

var searchResponse = client.Search&lt;GroupDoc&gt;(s =&gt; s
    .Index("my_index")
    .Query(q =&gt; q
        .Nested(n =&gt; n
            .Path(p =&gt; p.User)
            .Query(nq =&gt; nq
                .Match(m =&gt; m
                    .Field(f =&gt; f.User[0].First)
                    .Query("Alice")
                ) &amp;&amp; nq
                .Match(m =&gt; m
                    .Field(f =&gt; f.User[0].Last)
                    .Query("Smith")
                )
            )
        )
    )
);

var searchResponse2 = client.Search&lt;GroupDoc&gt;(s =&gt; s
    .Index("my_index")
    .Query(q =&gt; q
        .Nested(n =&gt; n
            .Path(p =&gt; p.User)
            .Query(nq =&gt; nq
                .Match(m =&gt; m
                    .Field(f =&gt; f.User[0].First)
                    .Query("Alice")
                ) &amp;&amp; nq
                .Match(m =&gt; m
                    .Field(f =&gt; f.User[0].Last)
                    .Query("White")
                )
            )
            .InnerHits(i =&gt; i
                .Highlight(h =&gt; h
                    .Fields(hf =&gt; hf
                        .Field(f =&gt; f.User[0].First)
                    )
                )
            )
        )
    )
);</pre>
</div>
<div class="pre_wrapper lang-python alternative">
<pre class="programlisting prettyprint lang-python alternative">resp = client.indices.create(
    index="my_index",
    body={"mappings": {"properties": {"user": {"type": "nested"}}}},
)
print(resp)

resp = client.index(
    index="my_index",
    id="1",
    body={
        "group": "fans",
        "user": [
            {"first": "John", "last": "Smith"},
            {"first": "Alice", "last": "White"},
        ],
    },
)
print(resp)

resp = client.search(
    index="my_index",
    body={
        "query": {
            "nested": {
                "path": "user",
                "query": {
                    "bool": {
                        "must": [
                            {"match": {"user.first": "Alice"}},
                            {"match": {"user.last": "Smith"}},
                        ]
                    }
                },
            }
        }
    },
)
print(resp)

resp = client.search(
    index="my_index",
    body={
        "query": {
            "nested": {
                "path": "user",
                "query": {
                    "bool": {
                        "must": [
                            {"match": {"user.first": "Alice"}},
                            {"match": {"user.last": "White"}},
                        ]
                    }
                },
                "inner_hits": {
                    "highlight": {"fields": {"user.first": {}}}
                },
            }
        }
    },
)
print(resp)</pre>
</div>
<div class="pre_wrapper lang-ruby alternative">
<pre class="programlisting prettyprint lang-ruby alternative">response = client.indices.create(
  index: 'my_index',
  body: {
    mappings: {
      properties: {
        user: {
          type: 'nested'
        }
      }
    }
  }
)
puts response

response = client.indices.create(
  index: 'my_index',
  id: 1,
  body: {
    group: 'fans',
    user: [
      {
        first: 'John',
        last: 'Smith'
      },
      {
        first: 'Alice',
        last: 'White'
      }
    ]
  }
)
puts response

response = client.indices.create(
  index: 'my_index',
  body: {
    query: {
      nested: {
        path: 'user',
        query: {
          bool: {
            must: [
              {
                match: {
                  "user.first": 'Alice'
                }
              },
              {
                match: {
                  "user.last": 'Smith'
                }
              }
            ]
          }
        }
      }
    }
  }
)
puts response

response = client.indices.create(
  index: 'my_index',
  body: {
    query: {
      nested: {
        path: 'user',
        query: {
          bool: {
            must: [
              {
                match: {
                  "user.first": 'Alice'
                }
              },
              {
                match: {
                  "user.last": 'White'
                }
              }
            ]
          }
        },
        inner_hits: {
          highlight: {
            fields: {
              "user.first": {
              }
            }
          }
        }
      }
    }
  }
)
puts response</pre>
</div>
<div class="pre_wrapper lang-go alternative">
<pre class="programlisting prettyprint lang-go alternative">{
	res, err := es.Indices.Create(
		"my_index",
		es.Indices.Create.WithBody(strings.NewReader(`{
	  "mappings": {
	    "properties": {
	      "user": {
	        "type": "nested"
	      }
	    }
	  }
	}`)),
	)
	fmt.Println(res, err)
}

{
	res, err := es.Index(
		"my_index",
		strings.NewReader(`{
	  "group": "fans",
	  "user": [
	    {
	      "first": "John",
	      "last": "Smith"
	    },
	    {
	      "first": "Alice",
	      "last": "White"
	    }
	  ]
	}`),
		es.Index.WithDocumentID("1"),
		es.Index.WithPretty(),
	)
	fmt.Println(res, err)
}

{
	res, err := es.Search(
		es.Search.WithIndex("my_index"),
		es.Search.WithBody(strings.NewReader(`{
	  "query": {
	    "nested": {
	      "path": "user",
	      "query": {
	        "bool": {
	          "must": [
	            {
	              "match": {
	                "user.first": "Alice"
	              }
	            },
	            {
	              "match": {
	                "user.last": "Smith"
	              }
	            }
	          ]
	        }
	      }
	    }
	  }
	}`)),
		es.Search.WithPretty(),
	)
	fmt.Println(res, err)
}

{
	res, err := es.Search(
		es.Search.WithIndex("my_index"),
		es.Search.WithBody(strings.NewReader(`{
	  "query": {
	    "nested": {
	      "path": "user",
	      "query": {
	        "bool": {
	          "must": [
	            {
	              "match": {
	                "user.first": "Alice"
	              }
	            },
	            {
	              "match": {
	                "user.last": "White"
	              }
	            }
	          ]
	        }
	      },
	      "inner_hits": {
	        "highlight": {
	          "fields": {
	            "user.first": {}
	          }
	        }
	      }
	    }
	  }
	}`)),
		es.Search.WithPretty(),
	)
	fmt.Println(res, err)
}</pre>
</div>
<div class="pre_wrapper lang-js alternative">
<pre class="programlisting prettyprint lang-js alternative">const response0 = await client.indices.create({
  index: 'my_index',
  body: {
    mappings: {
      properties: {
        user: {
          type: 'nested'
        }
      }
    }
  }
})
console.log(response0)

const response1 = await client.index({
  index: 'my_index',
  id: '1',
  body: {
    group: 'fans',
    user: [
      {
        first: 'John',
        last: 'Smith'
      },
      {
        first: 'Alice',
        last: 'White'
      }
    ]
  }
})
console.log(response1)

const response2 = await client.search({
  index: 'my_index',
  body: {
    query: {
      nested: {
        path: 'user',
        query: {
          bool: {
            must: [
              {
                match: {
                  'user.first': 'Alice'
                }
              },
              {
                match: {
                  'user.last': 'Smith'
                }
              }
            ]
          }
        }
      }
    }
  }
})
console.log(response2)

const response3 = await client.search({
  index: 'my_index',
  body: {
    query: {
      nested: {
        path: 'user',
        query: {
          bool: {
            must: [
              {
                match: {
                  'user.first': 'Alice'
                }
              },
              {
                match: {
                  'user.last': 'White'
                }
              }
            ]
          }
        },
        inner_hits: {
          highlight: {
            fields: {
              'user.first': {}
            }
          }
        }
      }
    }
  }
})
console.log(response3)</pre>
</div>
<a id="b919f88e6f47a40d5793479440a90ba6"></a>
<div class="pre_wrapper lang-console default has-csharp has-python has-ruby has-go has-js">
<pre class="programlisting prettyprint lang-console default has-csharp has-python has-ruby has-go has-js">PUT my_index
{
  "mappings": {
    "properties": {
      "user": {
        "type": "nested" <a id="CO301-1"></a><i class="conum" data-value="1"></i>
      }
    }
  }
}

PUT my_index/_doc/1
{
  "group" : "fans",
  "user" : [
    {
      "first" : "John",
      "last" :  "Smith"
    },
    {
      "first" : "Alice",
      "last" :  "White"
    }
  ]
}

GET my_index/_search
{
  "query": {
    "nested": {
      "path": "user",
      "query": {
        "bool": {
          "must": [
            { "match": { "user.first": "Alice" }},
            { "match": { "user.last":  "Smith" }} <a id="CO301-2"></a><i class="conum" data-value="2"></i>
          ]
        }
      }
    }
  }
}

GET my_index/_search
{
  "query": {
    "nested": {
      "path": "user",
      "query": {
        "bool": {
          "must": [
            { "match": { "user.first": "Alice" }},
            { "match": { "user.last":  "White" }} <a id="CO301-3"></a><i class="conum" data-value="3"></i>
          ]
        }
      },
      "inner_hits": { <a id="CO301-4"></a><i class="conum" data-value="4"></i>
        "highlight": {
          "fields": {
            "user.first": {}
          }
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget has-csharp has-python has-ruby has-go has-js" data-snippet="snippets/628.console"></div>
<div class="calloutlist default has-csharp has-python has-ruby has-go has-js lang-console">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO301-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>The <code class="literal">user</code> field is mapped as type <code class="literal">nested</code> instead of type <code class="literal">object</code>.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO301-2"><i class="conum" data-value="2"></i></a></p>
</td>
<td align="left" valign="top">
<p>This query doesn&#8217;t match because <code class="literal">Alice</code> and <code class="literal">Smith</code> are not in the same nested object.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO301-3"><i class="conum" data-value="3"></i></a></p>
</td>
<td align="left" valign="top">
<p>This query matches because <code class="literal">Alice</code> and <code class="literal">White</code> are in the same nested object.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO301-4"><i class="conum" data-value="4"></i></a></p>
</td>
<td align="left" valign="top">
<p><code class="literal">inner_hits</code> allow us to highlight the matching nested documents.</p>
</td>
</tr>
</table>
</div>
<p>Nested documents can be:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
queried with the <a class="xref" href="query-dsl-nested-query.html" title="Nested query"><code class="literal">nested</code></a> query.
</li>
<li class="listitem">
analyzed with the <a class="xref" href="search-aggregations-bucket-nested-aggregation.html" title="Nested Aggregation"><code class="literal">nested</code></a>
and <a class="xref" href="search-aggregations-bucket-reverse-nested-aggregation.html" title="Reverse nested Aggregation"><code class="literal">reverse_nested</code></a>
aggregations.
</li>
<li class="listitem">
sorted with <a class="xref" href="search-request-body.html#nested-sorting" title="Sorting within nested objects.">nested sorting</a>.
</li>
<li class="listitem">
retrieved and highlighted with <a class="xref" href="search-request-body.html#nested-inner-hits" title="Nested inner hits">nested inner hits</a>.
</li>
</ul>
</div>
<div class="important admon">
<div class="icon"></div>
<div class="admon_content">
<p>Because nested documents are indexed as separate documents, they can only be
accessed  within the scope of the <code class="literal">nested</code> query, the
<code class="literal">nested</code>/<code class="literal">reverse_nested</code> aggregations, or <a class="xref" href="search-request-body.html#nested-inner-hits" title="Nested inner hits">nested inner hits</a>.</p>
<p>For instance, if a string field within a nested document has
<a class="xref" href="index-options.html" title="index_options"><code class="literal">index_options</code></a> set to <code class="literal">offsets</code> to allow use of the postings
during the highlighting, these offsets will not be available during the main highlighting
phase.  Instead, highlighting needs to be performed via
<a class="xref" href="search-request-body.html#nested-inner-hits" title="Nested inner hits">nested inner hits</a>. The same consideration applies when loading
fields during a search through <a class="xref" href="search-request-body.html#request-body-search-docvalue-fields" title="Doc value Fields"><code class="literal">docvalue_fields</code></a>
or <a class="xref" href="search-request-body.html#request-body-search-stored-fields" title="Stored Fields"><code class="literal">stored_fields</code></a>.</p>
</div>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="nested-params"></a>Parameters for <code class="literal">nested</code> fields<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/master/docs/reference/mapping/types/nested.asciidoc">edit</a></h3>
</div></div></div>
<p>The following parameters are accepted by <code class="literal">nested</code> fields:</p>
<div class="variablelist">
<dl class="variablelist">
<dt>
<span class="term">
<a class="xref" href="dynamic.html" title="dynamic"><code class="literal">dynamic</code></a>
</span>
</dt>
<dd>
(Optional, string)
Whether or not new <code class="literal">properties</code> should be added dynamically to an existing
nested object.  Accepts <code class="literal">true</code> (default), <code class="literal">false</code> and <code class="literal">strict</code>.
</dd>
<dt>
<span class="term">
<a class="xref" href="properties.html" title="properties"><code class="literal">properties</code></a>
</span>
</dt>
<dd>
(Optional, object)
The fields within the nested object, which can be of any
<a class="xref" href="mapping-types.html" title="Field datatypes">datatype</a>, including <code class="literal">nested</code>. New properties
may be added to an existing nested object.
</dd>
<dt>
<span class="term">
<code class="literal">include_in_parent</code>
</span>
</dt>
<dd>
(Optional, boolean)
If <code class="literal">true</code>, all fields in the nested object are also added to the parent document
as standard (flat) fields. Defaults to <code class="literal">false</code>.
</dd>
<dt>
<span class="term">
<code class="literal">include_in_root</code>
</span>
</dt>
<dd>
(Optional, boolean)
If <code class="literal">true</code>, all fields in the nested object are also added to the root
document as standard (flat) fields. Defaults to <code class="literal">false</code>.
</dd>
</dl>
</div>
<h3><a id="_limits_on_nested_mappings_and_objects"></a>Limits on <code class="literal">nested</code> mappings and objects<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/master/docs/reference/mapping/types/nested.asciidoc">edit</a></h3>
<p>As described earlier, each nested object is indexed as a separate document under the hood.
Continuing with the example above, if we indexed a single document containing 100 <code class="literal">user</code> objects,
then 101 Lucene documents would be created&#8201;&#8212;&#8201;one for the parent document, and one for each
nested object. Because of the expense associated with <code class="literal">nested</code> mappings, Elasticsearch puts
settings in place to guard against performance problems:</p>
<div class="variablelist">
<dl class="variablelist">
<dt>
<span class="term">
<code class="literal">index.mapping.nested_fields.limit</code>
</span>
</dt>
<dd>
The <code class="literal">nested</code> type should only be used in special cases, when arrays of objects need to be
queried independently of each other. To safeguard against poorly designed mappings, this setting
limits the number of unique <code class="literal">nested</code> types per index. In our example, the <code class="literal">user</code> mapping would
count as only 1 towards this limit. Defaults to 50.
</dd>
<dt>
<span class="term">
<code class="literal">index.mapping.nested_objects.limit</code>
</span>
</dt>
<dd>
This setting limits the number of nested objects that a single document may contain across all
<code class="literal">nested</code> types, in order to prevent out of memory errors when a document contains too many nested
objects. To illustrate how the setting works, say we added another <code class="literal">nested</code> type called <code class="literal">comments</code>
to our example mapping above. Then for each document, the combined number of <code class="literal">user</code> and <code class="literal">comment</code>
objects it contains must be below the limit. Defaults to 10000.
</dd>
</dl>
</div>
<p>Additional background on these settings, including information on their default values, can be found
in <a class="xref" href="mapping.html#mapping-limit-settings" title="Settings to prevent mappings explosion">Settings to prevent mappings explosion</a>.</p>
</div>

</div>
<div class="navfooter">
<span class="prev">
<a href="keyword.html">« Keyword datatype</a>
</span>
<span class="next">
<a href="number.html">Numeric datatypes »</a>
</span>
</div>
</div>
</body>
</html>
