<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Terms aggregation | Elasticsearch Guide [master] | Elastic</title>
<meta class="elastic" name="content" content="Terms aggregation | Elasticsearch Guide [master]">

<link rel="home" href="index.html" title="Elasticsearch Guide [master]"/>
<link rel="up" href="search-aggregations-bucket.html" title="Bucket aggregations"/>
<link rel="prev" href="search-aggregations-bucket-significanttext-aggregation.html" title="Significant text aggregation"/>
<link rel="next" href="search-aggregations-bucket-time-series-aggregation.html" title="Time series aggregation"/>
<meta class="elastic" name="product_version" content="master"/>
<meta class="elastic" name="product_name" content="Elasticsearch"/>
<meta class="elastic" name="website_area" content="documentation"/>
<meta name="DC.type" content="Learn/Docs/Elasticsearch/Reference/master"/>
<meta name="DC.subject" content="Elasticsearch"/>
<meta name="DC.identifier" content="master"/>
<meta name="robots" content="noindex,nofollow"/>
</head>
<body>
<div class="page_header">
This documentation contains work-in-progress information for future Elastic Stack and Cloud releases. Use the version selector to view supported release docs. It also contains some Elastic Cloud serverless information. Check out our <a href="https://www.elastic.co/docs/current/serverless">serverless docs</a> for more details.
</div>
<div class="navheader">
<span class="prev">
<a href="search-aggregations-bucket-significanttext-aggregation.html">« Significant text aggregation</a>
</span>
<span class="next">
<a href="search-aggregations-bucket-time-series-aggregation.html">Time series aggregation »</a>
</span>
</div>
<div class="book" lang="en">
<div class="titlepage">
<div class="breadcrumbs">
<span class="breadcrumb-link"><a href="/guide/">Elastic Docs</a></span>
<span class="chevron-right">›</span><span class="breadcrumb-link"><a href="index.html">Elasticsearch Guide [master]</a></span>
<span class="chevron-right">›</span><span class="breadcrumb-link"><a href="search-aggregations.html">Aggregations</a></span>
<span class="chevron-right">›</span><span class="breadcrumb-link"><a href="search-aggregations-bucket.html">Bucket aggregations</a></span>
</div>
<div>
<div><h1 class="title"><a id="id-1"></a>Terms aggregation</h1><a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/main/docs/reference/aggregations/bucket/terms-aggregation.asciidoc">edit</a></div>
</div>
<!--EXTRA-->
</div>
<div id="content">
<div class="section">
<div class="titlepage"><div><div>
<h2 class="title"><a id="search-aggregations-bucket-terms-aggregation"></a>Terms aggregation<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/main/docs/reference/aggregations/bucket/terms-aggregation.asciidoc">edit</a></h2>
</div></div></div>

<p>A multi-bucket value source based aggregation where buckets are dynamically built - one per unique value.</p>
<p>Example:</p>
<div class="pre_wrapper lang-python alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-python alternative">resp = client.search(
    body={"aggs": {"genres": {"terms": {"field": "genre"}}}},
)
print(resp)</pre>
</div>
<div class="pre_wrapper lang-ruby alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-ruby alternative">response = client.search(
  body: {
    aggregations: {
      genres: {
        terms: {
          field: 'genre'
        }
      }
    }
  }
)
puts response</pre>
</div>
<div class="pre_wrapper lang-js alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-js alternative">const response = await client.search({
  aggs: {
    genres: {
      terms: {
        field: "genre",
      },
    },
  },
});
console.log(response);</pre>
</div>
<a id="8ee9521f57661a050efb614f02b4a090"></a>
<a id="terms-aggregation-example"></a><div class="pre_wrapper lang-console default has-python has-ruby has-js">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-console default has-python has-ruby has-js">GET /_search
{
  "aggs": {
    "genres": {
      "terms": { "field": "genre" }
    }
  }
}</pre>
</div>
<div class="console_widget has-python has-ruby has-js" data-snippet="snippets/1513.console"></div>
<p>Response:</p>
<a id="68aaac89471c93d7063fc99d324d6a27"></a>
<div class="pre_wrapper lang-console-result">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-console-result">{
  ...
  "aggregations": {
    "genres": {
      "doc_count_error_upper_bound": 0,   <a id="CO359-1"></a><i class="conum" data-value="1"></i>
      "sum_other_doc_count": 0,           <a id="CO359-2"></a><i class="conum" data-value="2"></i>
      "buckets": [                        <a id="CO359-3"></a><i class="conum" data-value="3"></i>
        {
          "key": "electronic",
          "doc_count": 6
        },
        {
          "key": "rock",
          "doc_count": 3
        },
        {
          "key": "jazz",
          "doc_count": 2
        }
      ]
    }
  }
}</pre>
</div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO359-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>an upper bound of the error on the document counts for each term, see <a class="xref" href="search-aggregations-bucket-terms-aggregation.html#terms-agg-doc-count-error" title="Document count error">below</a></p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO359-2"><i class="conum" data-value="2"></i></a></p>
</td>
<td align="left" valign="top">
<p>when there are lots of unique terms, Elasticsearch only returns the top terms; this number is the sum of the document counts for all buckets that are not part of the response</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO359-3"><i class="conum" data-value="3"></i></a></p>
</td>
<td align="left" valign="top">
<p>the list of the top buckets, the meaning of <code class="literal">top</code> being defined by the <a class="xref" href="search-aggregations-bucket-terms-aggregation.html#search-aggregations-bucket-terms-aggregation-order" title="Order">order</a></p>
</td>
</tr>
</table>
</div>
<p><a id="search-aggregations-bucket-terms-aggregation-types"></a>The <code class="literal">field</code> can be <a class="xref" href="keyword.html" title="Keyword type family">Keyword</a>, <a class="xref" href="number.html" title="Numeric field types">Numeric</a>, <a class="xref" href="ip.html" title="IP field type"><code class="literal">ip</code></a>, <a class="xref" href="boolean.html" title="Boolean field type"><code class="literal">boolean</code></a>,
or <a class="xref" href="binary.html" title="Binary field type"><code class="literal">binary</code></a>.</p>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p>By default, you cannot run a <code class="literal">terms</code> aggregation on a <code class="literal">text</code> field. Use a
<code class="literal">keyword</code> <a class="xref" href="multi-fields.html" title="fields">sub-field</a> instead. Alternatively, you can enable
<a class="xref" href="text.html#fielddata-mapping-param" title="fielddata mapping parameter"><code class="literal">fielddata</code></a> on the <code class="literal">text</code> field to create buckets for the field&#8217;s
<a class="xref" href="analysis.html" title="Text analysis">analyzed</a> terms. Enabling <code class="literal">fielddata</code> can significantly increase
memory usage.</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="search-aggregations-bucket-terms-aggregation-size"></a>Size<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/main/docs/reference/aggregations/bucket/terms-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>By default, the <code class="literal">terms</code> aggregation returns the top ten terms with the most
documents. Use the <code class="literal">size</code> parameter to return more terms, up to the
<a class="xref" href="search-settings.html#search-settings-max-buckets">search.max_buckets</a> limit.</p>
<p>If your data contains 100 or 1000 unique terms, you can increase the <code class="literal">size</code> of
the <code class="literal">terms</code> aggregation to return them all. If you have more unique terms and
you need them all, use the
<a class="xref" href="search-aggregations-bucket-composite-aggregation.html" title="Composite aggregation">composite aggregation</a>
instead.</p>
<p>Larger values of <code class="literal">size</code> use more memory to compute and, push the whole
aggregation close to the <code class="literal">max_buckets</code> limit. You&#8217;ll know you&#8217;ve gone too large
if the request fails with a message about <code class="literal">max_buckets</code>.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="search-aggregations-bucket-terms-aggregation-shard-size"></a>Shard size<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/main/docs/reference/aggregations/bucket/terms-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>To get more accurate results, the <code class="literal">terms</code> agg fetches more than
the top <code class="literal">size</code> terms from each shard. It fetches the top <code class="literal">shard_size</code> terms,
which defaults to <code class="literal">size * 1.5 + 10</code>.</p>
<p>This is to handle the case when one term has many documents on one shard but is
just below the <code class="literal">size</code> threshold on all other shards. If each shard only
returned <code class="literal">size</code> terms, the aggregation would return an partial doc count for
the term. So <code class="literal">terms</code> returns more terms in an attempt to catch the missing
terms. This helps, but it&#8217;s still quite possible to return a partial doc
count for a term. It just takes a term with more disparate per-shard doc counts.</p>
<p>You can increase <code class="literal">shard_size</code> to better account for these disparate doc counts
and improve the accuracy of the selection of top terms. It is much cheaper to increase
the <code class="literal">shard_size</code> than to increase the <code class="literal">size</code>. However, it still takes more
bytes over the wire and waiting in memory on the coordinating node.</p>
<div class="important admon">
<div class="icon"></div>
<div class="admon_content">
<p>This guidance only applies if you&#8217;re using the <code class="literal">terms</code> aggregation&#8217;s
default sort <code class="literal">order</code>. If you&#8217;re sorting by anything other than document count in
descending order, see <a class="xref" href="search-aggregations-bucket-terms-aggregation.html#search-aggregations-bucket-terms-aggregation-order" title="Order">Order</a>.</p>
</div>
</div>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p><code class="literal">shard_size</code> cannot be smaller than <code class="literal">size</code> (as it doesn&#8217;t make much sense). When it is, Elasticsearch will
        override it and reset it to be equal to <code class="literal">size</code>.</p>
</div>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="terms-agg-doc-count-error"></a>Document count error<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/main/docs/reference/aggregations/bucket/terms-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>Even with a larger <code class="literal">shard_size</code> value, <code class="literal">doc_count</code> values for a <code class="literal">terms</code>
aggregation may be approximate. As a result, any sub-aggregations on the <code class="literal">terms</code>
aggregation may also be approximate.</p>
<p><code class="literal">sum_other_doc_count</code> is the number of documents that didn&#8217;t make it into the
the top <code class="literal">size</code> terms. If this is greater than <code class="literal">0</code>, you can be sure that the
<code class="literal">terms</code> agg had to throw away some buckets, either because they didn&#8217;t fit into
<code class="literal">size</code> on the coordinating node or they didn&#8217;t fit into <code class="literal">shard_size</code> on the
data node.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_per_bucket_document_count_error"></a>Per bucket document count error<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/main/docs/reference/aggregations/bucket/terms-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>If you set the <code class="literal">show_term_doc_count_error</code> parameter to <code class="literal">true</code>, the <code class="literal">terms</code>
aggregation will include <code class="literal">doc_count_error_upper_bound</code>, which is an upper bound
to the error on the <code class="literal">doc_count</code> returned by each shard. It&#8217;s the
sum of the size of the largest bucket on each shard that didn&#8217;t fit into
<code class="literal">shard_size</code>.</p>
<p>In more concrete terms, imagine there is one bucket that is very large on one
shard and just outside the <code class="literal">shard_size</code> on all the other shards. In that case,
the <code class="literal">terms</code> agg will return the bucket because it is large, but it&#8217;ll be missing
data from many documents on the shards where the term fell below the <code class="literal">shard_size</code> threshold.
<code class="literal">doc_count_error_upper_bound</code> is the maximum number of those missing documents.</p>
<div class="pre_wrapper lang-python alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-python alternative">resp = client.search(
    body={
        "aggs": {
            "products": {
                "terms": {
                    "field": "product",
                    "size": 5,
                    "show_term_doc_count_error": True,
                }
            }
        }
    },
)
print(resp)</pre>
</div>
<div class="pre_wrapper lang-ruby alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-ruby alternative">response = client.search(
  body: {
    aggregations: {
      products: {
        terms: {
          field: 'product',
          size: 5,
          show_term_doc_count_error: true
        }
      }
    }
  }
)
puts response</pre>
</div>
<div class="pre_wrapper lang-go alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-go alternative">res, err := es.Search(
	es.Search.WithBody(strings.NewReader(`{
	  "aggs": {
	    "products": {
	      "terms": {
	        "field": "product",
	        "size": 5,
	        "show_term_doc_count_error": true
	      }
	    }
	  }
	}`)),
	es.Search.WithPretty(),
)
fmt.Println(res, err)</pre>
</div>
<div class="pre_wrapper lang-js alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-js alternative">const response = await client.search({
  aggs: {
    products: {
      terms: {
        field: "product",
        size: 5,
        show_term_doc_count_error: true,
      },
    },
  },
});
console.log(response);</pre>
</div>
<a id="e60ded7becfd5b2ccaef5bad2aaa93f5"></a>
<a id="terms-aggregation-doc-count-error-example"></a><div class="pre_wrapper lang-console default has-python has-ruby has-go has-js">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-console default has-python has-ruby has-go has-js">GET /_search
{
  "aggs": {
    "products": {
      "terms": {
        "field": "product",
        "size": 5,
        "show_term_doc_count_error": true
      }
    }
  }
}</pre>
</div>
<div class="console_widget has-python has-ruby has-go has-js" data-snippet="snippets/1514.console"></div>
<p>These errors can only be calculated in this way when the terms are ordered by descending document count. When the aggregation is
ordered by the terms values themselves (either ascending or descending) there is no error in the document count since if a shard
does not return a particular term which appears in the results from another shard, it must not have that term in its index. When the
aggregation is either sorted by a sub aggregation or in order of ascending document count, the error in the document counts cannot be
determined and is given a value of -1 to indicate this.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="search-aggregations-bucket-terms-aggregation-order"></a>Order<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/main/docs/reference/aggregations/bucket/terms-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>By default, the <code class="literal">terms</code> aggregation orders terms by descending document
<code class="literal">_count</code>.  This produces a bounded <a class="xref" href="search-aggregations-bucket-terms-aggregation.html#terms-agg-doc-count-error" title="Document count error">document count</a>
error that Elasticsearch can report.</p>
<p>You can use the <code class="literal">order</code> parameter to specify a different sort order, but we
don&#8217;t recommend it.  It is extremely easy to create a terms ordering that will
just return wrong results, and not obvious to see when you have done so.
Change this only with caution.</p>
<div class="warning admon">
<div class="icon"></div>
<div class="admon_content">
<p>Especially avoid using <code class="literal">"order": { "_count": "asc" }</code>. If you need to find rare
terms, use the
<a class="xref" href="search-aggregations-bucket-rare-terms-aggregation.html" title="Rare terms aggregation"><code class="literal">rare_terms</code></a> aggregation
instead. Due to the way the <code class="literal">terms</code> aggregation
<a class="xref" href="search-aggregations-bucket-terms-aggregation.html#search-aggregations-bucket-terms-aggregation-shard-size" title="Shard size">gets terms from
shards</a>, sorting by ascending doc count often produces inaccurate results.</p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="_ordering_by_the_term_value"></a>Ordering by the term value<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/main/docs/reference/aggregations/bucket/terms-aggregation.asciidoc">edit</a></h4>
</div></div></div>
<p>In this case, the buckets are ordered by the actual term values, such as
lexicographic order for keywords or numerically for numbers. This sorting is
safe in both ascending and descending directions, and produces accurate
results.</p>
<p>Example of ordering the buckets alphabetically by their terms in an ascending manner:</p>
<div class="pre_wrapper lang-python alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-python alternative">resp = client.search(
    body={
        "aggs": {
            "genres": {
                "terms": {"field": "genre", "order": {"_key": "asc"}}
            }
        }
    },
)
print(resp)</pre>
</div>
<div class="pre_wrapper lang-ruby alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-ruby alternative">response = client.search(
  body: {
    aggregations: {
      genres: {
        terms: {
          field: 'genre',
          order: {
            _key: 'asc'
          }
        }
      }
    }
  }
)
puts response</pre>
</div>
<div class="pre_wrapper lang-go alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-go alternative">res, err := es.Search(
	es.Search.WithBody(strings.NewReader(`{
	  "aggs": {
	    "genres": {
	      "terms": {
	        "field": "genre",
	        "order": {
	          "_key": "asc"
	        }
	      }
	    }
	  }
	}`)),
	es.Search.WithPretty(),
)
fmt.Println(res, err)</pre>
</div>
<div class="pre_wrapper lang-js alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-js alternative">const response = await client.search({
  aggs: {
    genres: {
      terms: {
        field: "genre",
        order: {
          _key: "asc",
        },
      },
    },
  },
});
console.log(response);</pre>
</div>
<a id="54a215d242ab65123b09e9dfb71bcbbf"></a>
<a id="terms-aggregation-asc-example"></a><div class="pre_wrapper lang-console default has-python has-ruby has-go has-js">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-console default has-python has-ruby has-go has-js">GET /_search
{
  "aggs": {
    "genres": {
      "terms": {
        "field": "genre",
        "order": { "_key": "asc" }
      }
    }
  }
}</pre>
</div>
<div class="console_widget has-python has-ruby has-go has-js" data-snippet="snippets/1515.console"></div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="_ordering_by_a_sub_aggregation"></a>Ordering by a sub aggregation<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/main/docs/reference/aggregations/bucket/terms-aggregation.asciidoc">edit</a></h4>
</div></div></div>
<div class="warning admon">
<div class="icon"></div>
<div class="admon_content">
<p>Sorting by a sub aggregation generally produces incorrect ordering, due to the way the <code class="literal">terms</code> aggregation
<a class="xref" href="search-aggregations-bucket-terms-aggregation.html#search-aggregations-bucket-terms-aggregation-shard-size" title="Shard size">gets results from
shards</a>.</p>
</div>
</div>
<p>There are two cases when sub-aggregation ordering is safe and returns correct
results: sorting by a maximum in descending order, or sorting by a minimum in
ascending order. These approaches work because they align with the behavior of
sub aggregations. That is, if you&#8217;re looking for the largest maximum or the
smallest minimum, the global answer (from combined shards) must be included in
one of the local shard answers. Conversely, the smallest maximum and largest
minimum wouldn&#8217;t be accurately computed.</p>
<p>Note also that in these cases, the ordering is correct but the doc counts and
non-ordering sub aggregations may still have errors (and Elasticsearch does not calculate a
bound for those errors).</p>
<p>Ordering the buckets by single value metrics sub-aggregation (identified by the aggregation name):</p>
<div class="pre_wrapper lang-python alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-python alternative">resp = client.search(
    body={
        "aggs": {
            "genres": {
                "terms": {
                    "field": "genre",
                    "order": {"max_play_count": "desc"},
                },
                "aggs": {
                    "max_play_count": {"max": {"field": "play_count"}}
                },
            }
        }
    },
)
print(resp)</pre>
</div>
<div class="pre_wrapper lang-ruby alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-ruby alternative">response = client.search(
  body: {
    aggregations: {
      genres: {
        terms: {
          field: 'genre',
          order: {
            max_play_count: 'desc'
          }
        },
        aggregations: {
          max_play_count: {
            max: {
              field: 'play_count'
            }
          }
        }
      }
    }
  }
)
puts response</pre>
</div>
<div class="pre_wrapper lang-go alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-go alternative">res, err := es.Search(
	es.Search.WithBody(strings.NewReader(`{
	  "aggs": {
	    "genres": {
	      "terms": {
	        "field": "genre",
	        "order": {
	          "max_play_count": "desc"
	        }
	      },
	      "aggs": {
	        "max_play_count": {
	          "max": {
	            "field": "play_count"
	          }
	        }
	      }
	    }
	  }
	}`)),
	es.Search.WithPretty(),
)
fmt.Println(res, err)</pre>
</div>
<div class="pre_wrapper lang-js alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-js alternative">const response = await client.search({
  aggs: {
    genres: {
      terms: {
        field: "genre",
        order: {
          max_play_count: "desc",
        },
      },
      aggs: {
        max_play_count: {
          max: {
            field: "play_count",
          },
        },
      },
    },
  },
});
console.log(response);</pre>
</div>
<a id="8eac28d2e9b6482b413d61817456a14f"></a>
<a id="terms-aggregation-subaggregation-example"></a><div class="pre_wrapper lang-console default has-python has-ruby has-go has-js">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-console default has-python has-ruby has-go has-js">GET /_search
{
  "aggs": {
    "genres": {
      "terms": {
        "field": "genre",
        "order": { "max_play_count": "desc" }
      },
      "aggs": {
        "max_play_count": { "max": { "field": "play_count" } }
      }
    }
  }
}</pre>
</div>
<div class="console_widget has-python has-ruby has-go has-js" data-snippet="snippets/1516.console"></div>
<p>Ordering the buckets by multi value metrics sub-aggregation (identified by the aggregation name):</p>
<div class="pre_wrapper lang-python alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-python alternative">resp = client.search(
    body={
        "aggs": {
            "genres": {
                "terms": {
                    "field": "genre",
                    "order": {"playback_stats.max": "desc"},
                },
                "aggs": {
                    "playback_stats": {"stats": {"field": "play_count"}}
                },
            }
        }
    },
)
print(resp)</pre>
</div>
<div class="pre_wrapper lang-ruby alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-ruby alternative">response = client.search(
  body: {
    aggregations: {
      genres: {
        terms: {
          field: 'genre',
          order: {
            'playback_stats.max' =&gt; 'desc'
          }
        },
        aggregations: {
          playback_stats: {
            stats: {
              field: 'play_count'
            }
          }
        }
      }
    }
  }
)
puts response</pre>
</div>
<div class="pre_wrapper lang-go alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-go alternative">res, err := es.Search(
	es.Search.WithBody(strings.NewReader(`{
	  "aggs": {
	    "genres": {
	      "terms": {
	        "field": "genre",
	        "order": {
	          "playback_stats.max": "desc"
	        }
	      },
	      "aggs": {
	        "playback_stats": {
	          "stats": {
	            "field": "play_count"
	          }
	        }
	      }
	    }
	  }
	}`)),
	es.Search.WithPretty(),
)
fmt.Println(res, err)</pre>
</div>
<div class="pre_wrapper lang-js alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-js alternative">const response = await client.search({
  aggs: {
    genres: {
      terms: {
        field: "genre",
        order: {
          "playback_stats.max": "desc",
        },
      },
      aggs: {
        playback_stats: {
          stats: {
            field: "play_count",
          },
        },
      },
    },
  },
});
console.log(response);</pre>
</div>
<a id="f495f9c99916a05e3b28166d31955fad"></a>
<a id="terms-aggregation-multivalue-subaggregation-example"></a><div class="pre_wrapper lang-console default has-python has-ruby has-go has-js">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-console default has-python has-ruby has-go has-js">GET /_search
{
  "aggs": {
    "genres": {
      "terms": {
        "field": "genre",
        "order": { "playback_stats.max": "desc" }
      },
      "aggs": {
        "playback_stats": { "stats": { "field": "play_count" } }
      }
    }
  }
}</pre>
</div>
<div class="console_widget has-python has-ruby has-go has-js" data-snippet="snippets/1517.console"></div>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<h3>Pipeline aggs cannot be used for sorting</h3>
<p><a class="xref" href="search-aggregations-pipeline.html" title="Pipeline aggregations">Pipeline aggregations</a> are run during the
reduce phase after all other aggregations have already completed. For this
reason, they cannot be used for ordering.</p>
</div>
</div>
<p>It is also possible to order the buckets based on a "deeper" aggregation in the hierarchy. This is supported as long
as the aggregations path are of a single-bucket type, where the last aggregation in the path may either be a single-bucket
one or a metrics one. If it&#8217;s a single-bucket type, the order will be defined by the number of docs in the bucket (i.e. <code class="literal">doc_count</code>),
in case it&#8217;s a metrics one, the same rules as above apply (where the path must indicate the metric name to sort by in case of
a multi-value metrics aggregation, and in case of a single-value metrics aggregation the sort will be applied on that value).</p>
<p>The path must be defined in the following form:</p>
<div class="pre_wrapper lang-ebnf">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-ebnf">AGG_SEPARATOR       =  '&gt;' ;
METRIC_SEPARATOR    =  '.' ;
AGG_NAME            =  &lt;the name of the aggregation&gt; ;
METRIC              =  &lt;the name of the metric (in case of multi-value metrics aggregation)&gt; ;
PATH                =  &lt;AGG_NAME&gt; [ &lt;AGG_SEPARATOR&gt;, &lt;AGG_NAME&gt; ]* [ &lt;METRIC_SEPARATOR&gt;, &lt;METRIC&gt; ] ;</pre>
</div>
<div class="pre_wrapper lang-python alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-python alternative">resp = client.search(
    body={
        "aggs": {
            "countries": {
                "terms": {
                    "field": "artist.country",
                    "order": {"rock&gt;playback_stats.avg": "desc"},
                },
                "aggs": {
                    "rock": {
                        "filter": {"term": {"genre": "rock"}},
                        "aggs": {
                            "playback_stats": {
                                "stats": {"field": "play_count"}
                            }
                        },
                    }
                },
            }
        }
    },
)
print(resp)</pre>
</div>
<div class="pre_wrapper lang-ruby alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-ruby alternative">response = client.search(
  body: {
    aggregations: {
      countries: {
        terms: {
          field: 'artist.country',
          order: {
            "rock&gt;playback_stats.avg": 'desc'
          }
        },
        aggregations: {
          rock: {
            filter: {
              term: {
                genre: 'rock'
              }
            },
            aggregations: {
              playback_stats: {
                stats: {
                  field: 'play_count'
                }
              }
            }
          }
        }
      }
    }
  }
)
puts response</pre>
</div>
<div class="pre_wrapper lang-go alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-go alternative">res, err := es.Search(
	es.Search.WithBody(strings.NewReader(`{
	  "aggs": {
	    "countries": {
	      "terms": {
	        "field": "artist.country",
	        "order": {
	          "rock&gt;playback_stats.avg": "desc"
	        }
	      },
	      "aggs": {
	        "rock": {
	          "filter": {
	            "term": {
	              "genre": "rock"
	            }
	          },
	          "aggs": {
	            "playback_stats": {
	              "stats": {
	                "field": "play_count"
	              }
	            }
	          }
	        }
	      }
	    }
	  }
	}`)),
	es.Search.WithPretty(),
)
fmt.Println(res, err)</pre>
</div>
<div class="pre_wrapper lang-js alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-js alternative">const response = await client.search({
  aggs: {
    countries: {
      terms: {
        field: "artist.country",
        order: {
          "rock&gt;playback_stats.avg": "desc",
        },
      },
      aggs: {
        rock: {
          filter: {
            term: {
              genre: "rock",
            },
          },
          aggs: {
            playback_stats: {
              stats: {
                field: "play_count",
              },
            },
          },
        },
      },
    },
  },
});
console.log(response);</pre>
</div>
<a id="1e871f060dbe1a5c316ed205278804a8"></a>
<a id="terms-aggregation-hierarchy-example"></a><div class="pre_wrapper lang-console default has-python has-ruby has-go has-js">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-console default has-python has-ruby has-go has-js">GET /_search
{
  "aggs": {
    "countries": {
      "terms": {
        "field": "artist.country",
        "order": { "rock&gt;playback_stats.avg": "desc" }
      },
      "aggs": {
        "rock": {
          "filter": { "term": { "genre": "rock" } },
          "aggs": {
            "playback_stats": { "stats": { "field": "play_count" } }
          }
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget has-python has-ruby has-go has-js" data-snippet="snippets/1518.console"></div>
<p>The above will sort the artist&#8217;s countries buckets based on the average play count among the rock songs.</p>
<p>Multiple criteria can be used to order the buckets by providing an array of order criteria such as the following:</p>
<div class="pre_wrapper lang-python alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-python alternative">resp = client.search(
    body={
        "aggs": {
            "countries": {
                "terms": {
                    "field": "artist.country",
                    "order": [
                        {"rock&gt;playback_stats.avg": "desc"},
                        {"_count": "desc"},
                    ],
                },
                "aggs": {
                    "rock": {
                        "filter": {"term": {"genre": "rock"}},
                        "aggs": {
                            "playback_stats": {
                                "stats": {"field": "play_count"}
                            }
                        },
                    }
                },
            }
        }
    },
)
print(resp)</pre>
</div>
<div class="pre_wrapper lang-ruby alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-ruby alternative">response = client.search(
  body: {
    aggregations: {
      countries: {
        terms: {
          field: 'artist.country',
          order: [
            {
              "rock&gt;playback_stats.avg": 'desc'
            },
            {
              _count: 'desc'
            }
          ]
        },
        aggregations: {
          rock: {
            filter: {
              term: {
                genre: 'rock'
              }
            },
            aggregations: {
              playback_stats: {
                stats: {
                  field: 'play_count'
                }
              }
            }
          }
        }
      }
    }
  }
)
puts response</pre>
</div>
<div class="pre_wrapper lang-go alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-go alternative">res, err := es.Search(
	es.Search.WithBody(strings.NewReader(`{
	  "aggs": {
	    "countries": {
	      "terms": {
	        "field": "artist.country",
	        "order": [
	          {
	            "rock&gt;playback_stats.avg": "desc"
	          },
	          {
	            "_count": "desc"
	          }
	        ]
	      },
	      "aggs": {
	        "rock": {
	          "filter": {
	            "term": {
	              "genre": "rock"
	            }
	          },
	          "aggs": {
	            "playback_stats": {
	              "stats": {
	                "field": "play_count"
	              }
	            }
	          }
	        }
	      }
	    }
	  }
	}`)),
	es.Search.WithPretty(),
)
fmt.Println(res, err)</pre>
</div>
<div class="pre_wrapper lang-js alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-js alternative">const response = await client.search({
  aggs: {
    countries: {
      terms: {
        field: "artist.country",
        order: [
          {
            "rock&gt;playback_stats.avg": "desc",
          },
          {
            _count: "desc",
          },
        ],
      },
      aggs: {
        rock: {
          filter: {
            term: {
              genre: "rock",
            },
          },
          aggs: {
            playback_stats: {
              stats: {
                field: "play_count",
              },
            },
          },
        },
      },
    },
  },
});
console.log(response);</pre>
</div>
<a id="4ba86373e13e106de044f190343be328"></a>
<a id="terms-aggregation-multicriteria-example"></a><div class="pre_wrapper lang-console default has-python has-ruby has-go has-js">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-console default has-python has-ruby has-go has-js">GET /_search
{
  "aggs": {
    "countries": {
      "terms": {
        "field": "artist.country",
        "order": [ { "rock&gt;playback_stats.avg": "desc" }, { "_count": "desc" } ]
      },
      "aggs": {
        "rock": {
          "filter": { "term": { "genre": "rock" } },
          "aggs": {
            "playback_stats": { "stats": { "field": "play_count" } }
          }
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget has-python has-ruby has-go has-js" data-snippet="snippets/1519.console"></div>
<p>The above will sort the artist&#8217;s countries buckets based on the average play count among the rock songs and then by
their <code class="literal">doc_count</code> in descending order.</p>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p>In the event that two buckets share the same values for all order criteria the bucket&#8217;s term value is used as a
tie-breaker in ascending alphabetical order to prevent non-deterministic ordering of buckets.</p>
</div>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="_ordering_by_count_ascending"></a>Ordering by count ascending<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/main/docs/reference/aggregations/bucket/terms-aggregation.asciidoc">edit</a></h4>
</div></div></div>
<p>Ordering terms by ascending document <code class="literal">_count</code> produces an unbounded error that
Elasticsearch can&#8217;t accurately report. We therefore strongly recommend against using
<code class="literal">"order": { "_count": "asc" }</code> as shown in the following example:</p>
<div class="pre_wrapper lang-python alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-python alternative">resp = client.search(
    body={
        "aggs": {
            "genres": {
                "terms": {"field": "genre", "order": {"_count": "asc"}}
            }
        }
    },
)
print(resp)</pre>
</div>
<div class="pre_wrapper lang-ruby alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-ruby alternative">response = client.search(
  body: {
    aggregations: {
      genres: {
        terms: {
          field: 'genre',
          order: {
            _count: 'asc'
          }
        }
      }
    }
  }
)
puts response</pre>
</div>
<div class="pre_wrapper lang-go alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-go alternative">res, err := es.Search(
	es.Search.WithBody(strings.NewReader(`{
	  "aggs": {
	    "genres": {
	      "terms": {
	        "field": "genre",
	        "order": {
	          "_count": "asc"
	        }
	      }
	    }
	  }
	}`)),
	es.Search.WithPretty(),
)
fmt.Println(res, err)</pre>
</div>
<div class="pre_wrapper lang-js alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-js alternative">const response = await client.search({
  aggs: {
    genres: {
      terms: {
        field: "genre",
        order: {
          _count: "asc",
        },
      },
    },
  },
});
console.log(response);</pre>
</div>
<a id="c5802e9f3f4068fcecb6937b867b270d"></a>
<a id="terms-aggregation-count-example"></a><div class="pre_wrapper lang-console default has-python has-ruby has-go has-js">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-console default has-python has-ruby has-go has-js">GET /_search
{
  "aggs": {
    "genres": {
      "terms": {
        "field": "genre",
        "order": { "_count": "asc" }
      }
    }
  }
}</pre>
</div>
<div class="console_widget has-python has-ruby has-go has-js" data-snippet="snippets/1520.console"></div>
</div>

</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_minimum_document_count_4"></a>Minimum document count<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/main/docs/reference/aggregations/bucket/terms-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>It is possible to only return terms that match more than a configured number of hits using the <code class="literal">min_doc_count</code> option:</p>
<div class="pre_wrapper lang-python alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-python alternative">resp = client.search(
    body={
        "aggs": {"tags": {"terms": {"field": "tags", "min_doc_count": 10}}}
    },
)
print(resp)</pre>
</div>
<div class="pre_wrapper lang-ruby alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-ruby alternative">response = client.search(
  body: {
    aggregations: {
      tags: {
        terms: {
          field: 'tags',
          min_doc_count: 10
        }
      }
    }
  }
)
puts response</pre>
</div>
<div class="pre_wrapper lang-go alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-go alternative">res, err := es.Search(
	es.Search.WithBody(strings.NewReader(`{
	  "aggs": {
	    "tags": {
	      "terms": {
	        "field": "tags",
	        "min_doc_count": 10
	      }
	    }
	  }
	}`)),
	es.Search.WithPretty(),
)
fmt.Println(res, err)</pre>
</div>
<div class="pre_wrapper lang-js alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-js alternative">const response = await client.search({
  aggs: {
    tags: {
      terms: {
        field: "tags",
        min_doc_count: 10,
      },
    },
  },
});
console.log(response);</pre>
</div>
<a id="b6c872d04eabb39d1947cde6b29d4ae1"></a>
<a id="terms-aggregation-min-doc-count-example"></a><div class="pre_wrapper lang-console default has-python has-ruby has-go has-js">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-console default has-python has-ruby has-go has-js">GET /_search
{
  "aggs": {
    "tags": {
      "terms": {
        "field": "tags",
        "min_doc_count": 10
      }
    }
  }
}</pre>
</div>
<div class="console_widget has-python has-ruby has-go has-js" data-snippet="snippets/1521.console"></div>
<p>The above aggregation would only return tags which have been found in 10 hits or more. Default value is <code class="literal">1</code>.</p>
<p>Terms are collected and ordered on a shard level and merged with the terms collected from other shards in a second step. However, the shard does not have the information about the global document count available. The decision if a term is added to a candidate list depends only on the order computed on the shard using local shard frequencies. The <code class="literal">min_doc_count</code> criterion is only applied after merging local terms statistics of all shards. In a way the decision to add the term as a candidate is made without being very <em>certain</em> about if the term will actually reach the required <code class="literal">min_doc_count</code>. This might cause many (globally) high frequent terms to be missing in the final result if low frequent terms populated the candidate lists. To avoid this, the <code class="literal">shard_size</code> parameter can be increased to allow more candidate terms on the shards. However, this increases memory consumption and network traffic.</p>
<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="search-aggregations-bucket-terms-shard-min-doc-count"></a><code class="literal">shard_min_doc_count</code><a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/main/docs/reference/aggregations/bucket/terms-aggregation.asciidoc">edit</a></h4>
</div></div></div>
<p>The parameter <code class="literal">shard_min_doc_count</code> regulates the <em>certainty</em> a shard has if the term should actually be added to the candidate list or not with respect to the <code class="literal">min_doc_count</code>. Terms will only be considered if their local shard frequency within the set is higher than the <code class="literal">shard_min_doc_count</code>. If your dictionary contains many low frequent terms and you are not interested in those (for example misspellings), then you can set the <code class="literal">shard_min_doc_count</code> parameter to filter out candidate terms on a shard level that will with a reasonable certainty not reach the required <code class="literal">min_doc_count</code> even after merging the local counts. <code class="literal">shard_min_doc_count</code> is set to <code class="literal">0</code> per default and has no effect unless you explicitly set it.</p>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p>Setting <code class="literal">min_doc_count</code>=<code class="literal">0</code> will also return buckets for terms that didn&#8217;t match any hit. However, some of
         the returned terms which have a document count of zero might only belong to deleted documents or documents
         from other types, so there is no warranty that a <code class="literal">match_all</code> query would find a positive document count for
         those terms.</p>
</div>
</div>
<div class="warning admon">
<div class="icon"></div>
<div class="admon_content">
<p>When NOT sorting on <code class="literal">doc_count</code> descending, high values of <code class="literal">min_doc_count</code> may return a number of buckets
         which is less than <code class="literal">size</code> because not enough data was gathered from the shards. Missing buckets can be
         back by increasing <code class="literal">shard_size</code>.
         Setting <code class="literal">shard_min_doc_count</code> too high will cause terms to be filtered out on a shard level. This value should be set much lower than <code class="literal">min_doc_count/#shards</code>.</p>
</div>
</div>
</div>

</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="search-aggregations-bucket-terms-aggregation-script"></a>Script<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/main/docs/reference/aggregations/bucket/terms-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>Use a <a class="xref" href="runtime.html" title="Runtime fields">runtime field</a> if the data in your documents doesn&#8217;t
exactly match what you&#8217;d like to aggregate. If, for example, "anthologies"
need to be in a special category then you could run this:</p>
<div class="pre_wrapper lang-python alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-python alternative">resp = client.search(
    body={
        "size": 0,
        "runtime_mappings": {
            "normalized_genre": {
                "type": "keyword",
                "script": "\n        String genre = doc['genre'].value;\n        if (doc['product'].value.startsWith('Anthology')) {\n          emit(genre + ' anthology');\n        } else {\n          emit(genre);\n        }\n      ",
            }
        },
        "aggs": {"genres": {"terms": {"field": "normalized_genre"}}},
    },
)
print(resp)</pre>
</div>
<div class="pre_wrapper lang-ruby alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-ruby alternative">response = client.search(
  body: {
    size: 0,
    runtime_mappings: {
      normalized_genre: {
        type: 'keyword',
        script: "\n        String genre = doc['genre'].value;\n        if (doc['product'].value.startsWith('Anthology')) {\n          emit(genre + ' anthology');\n        } else {\n          emit(genre);\n        }\n      "
      }
    },
    aggregations: {
      genres: {
        terms: {
          field: 'normalized_genre'
        }
      }
    }
  }
)
puts response</pre>
</div>
<div class="pre_wrapper lang-js alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-js alternative">const response = await client.search({
  size: 0,
  runtime_mappings: {
    normalized_genre: {
      type: "keyword",
      script:
        "\n        String genre = doc['genre'].value;\n        if (doc['product'].value.startsWith('Anthology')) {\n          emit(genre + ' anthology');\n        } else {\n          emit(genre);\n        }\n      ",
    },
  },
  aggs: {
    genres: {
      terms: {
        field: "normalized_genre",
      },
    },
  },
});
console.log(response);</pre>
</div>
<a id="e891e1d4805172da45a81f62b6b44aca"></a>
<a id="terms-aggregation-script-example"></a><div class="pre_wrapper lang-console default has-python has-ruby has-js">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-console default has-python has-ruby has-js">GET /_search
{
  "size": 0,
  "runtime_mappings": {
    "normalized_genre": {
      "type": "keyword",
      "script": """
        String genre = doc['genre'].value;
        if (doc['product'].value.startsWith('Anthology')) {
          emit(genre + ' anthology');
        } else {
          emit(genre);
        }
      """
    }
  },
  "aggs": {
    "genres": {
      "terms": {
        "field": "normalized_genre"
      }
    }
  }
}</pre>
</div>
<div class="console_widget has-python has-ruby has-js" data-snippet="snippets/1522.console"></div>
<p>Which will look like:</p>
<a id="a8603ae35e3c01f87fb9f5e7f302f3b5"></a>
<div class="pre_wrapper lang-console-result">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-console-result">{
  "aggregations": {
    "genres": {
      "doc_count_error_upper_bound": 0,
      "sum_other_doc_count": 0,
      "buckets": [
        {
          "key": "electronic",
          "doc_count": 4
        },
        {
          "key": "rock",
          "doc_count": 3
        },
        {
          "key": "electronic anthology",
          "doc_count": 2
        },
        {
          "key": "jazz",
          "doc_count": 2
        }
      ]
    }
  },
  ...
}</pre>
</div>
<p>This is a little slower because the runtime field has to access two fields
instead of one and because there are some optimizations that work on
non-runtime <code class="literal">keyword</code> fields that we have to give up for for runtime
<code class="literal">keyword</code> fields. If you need the speed, you can index the
<code class="literal">normalized_genre</code> field.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_filtering_values_4"></a>Filtering Values<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/main/docs/reference/aggregations/bucket/terms-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>It is possible to filter the values for which buckets will be created. This can be done using the <code class="literal">include</code> and
<code class="literal">exclude</code> parameters which are based on regular expression strings or arrays of exact values. Additionally,
<code class="literal">include</code> clauses can filter using <code class="literal">partition</code> expressions.</p>
<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="_filtering_values_with_regular_expressions_2"></a>Filtering Values with regular expressions<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/main/docs/reference/aggregations/bucket/terms-aggregation.asciidoc">edit</a></h4>
</div></div></div>
<div class="pre_wrapper lang-python alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-python alternative">resp = client.search(
    body={
        "aggs": {
            "tags": {
                "terms": {
                    "field": "tags",
                    "include": ".*sport.*",
                    "exclude": "water_.*",
                }
            }
        }
    },
)
print(resp)</pre>
</div>
<div class="pre_wrapper lang-ruby alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-ruby alternative">response = client.search(
  body: {
    aggregations: {
      tags: {
        terms: {
          field: 'tags',
          include: '.*sport.*',
          exclude: 'water_.*'
        }
      }
    }
  }
)
puts response</pre>
</div>
<div class="pre_wrapper lang-go alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-go alternative">res, err := es.Search(
	es.Search.WithBody(strings.NewReader(`{
	  "aggs": {
	    "tags": {
	      "terms": {
	        "field": "tags",
	        "include": ".*sport.*",
	        "exclude": "water_.*"
	      }
	    }
	  }
	}`)),
	es.Search.WithPretty(),
)
fmt.Println(res, err)</pre>
</div>
<div class="pre_wrapper lang-js alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-js alternative">const response = await client.search({
  aggs: {
    tags: {
      terms: {
        field: "tags",
        include: ".*sport.*",
        exclude: "water_.*",
      },
    },
  },
});
console.log(response);</pre>
</div>
<a id="9403764e6eccad7b321b65e9a10c5727"></a>
<a id="terms-aggregation-regex-example"></a><div class="pre_wrapper lang-console default has-python has-ruby has-go has-js">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-console default has-python has-ruby has-go has-js">GET /_search
{
  "aggs": {
    "tags": {
      "terms": {
        "field": "tags",
        "include": ".*sport.*",
        "exclude": "water_.*"
      }
    }
  }
}</pre>
</div>
<div class="console_widget has-python has-ruby has-go has-js" data-snippet="snippets/1523.console"></div>
<p>In the above example, buckets will be created for all the tags that has the word <code class="literal">sport</code> in them, except those starting
with <code class="literal">water_</code> (so the tag <code class="literal">water_sports</code> will not be aggregated). The <code class="literal">include</code> regular expression will determine what
values are "allowed" to be aggregated, while the <code class="literal">exclude</code> determines the values that should not be aggregated. When
both are defined, the <code class="literal">exclude</code> has precedence, meaning, the <code class="literal">include</code> is evaluated first and only then the <code class="literal">exclude</code>.</p>
<p>The syntax is the same as <a class="xref" href="regexp-syntax.html" title="Regular expression syntax">regexp queries</a>.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="_filtering_values_with_exact_values_2"></a>Filtering Values with exact values<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/main/docs/reference/aggregations/bucket/terms-aggregation.asciidoc">edit</a></h4>
</div></div></div>
<p>For matching based on exact values the <code class="literal">include</code> and <code class="literal">exclude</code> parameters can simply take an array of
strings that represent the terms as they are found in the index:</p>
<div class="pre_wrapper lang-python alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-python alternative">resp = client.search(
    body={
        "aggs": {
            "JapaneseCars": {
                "terms": {"field": "make", "include": ["mazda", "honda"]}
            },
            "ActiveCarManufacturers": {
                "terms": {"field": "make", "exclude": ["rover", "jensen"]}
            },
        }
    },
)
print(resp)</pre>
</div>
<div class="pre_wrapper lang-ruby alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-ruby alternative">response = client.search(
  body: {
    aggregations: {
      "JapaneseCars": {
        terms: {
          field: 'make',
          include: [
            'mazda',
            'honda'
          ]
        }
      },
      "ActiveCarManufacturers": {
        terms: {
          field: 'make',
          exclude: [
            'rover',
            'jensen'
          ]
        }
      }
    }
  }
)
puts response</pre>
</div>
<div class="pre_wrapper lang-go alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-go alternative">res, err := es.Search(
	es.Search.WithBody(strings.NewReader(`{
	  "aggs": {
	    "JapaneseCars": {
	      "terms": {
	        "field": "make",
	        "include": [
	          "mazda",
	          "honda"
	        ]
	      }
	    },
	    "ActiveCarManufacturers": {
	      "terms": {
	        "field": "make",
	        "exclude": [
	          "rover",
	          "jensen"
	        ]
	      }
	    }
	  }
	}`)),
	es.Search.WithPretty(),
)
fmt.Println(res, err)</pre>
</div>
<div class="pre_wrapper lang-js alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-js alternative">const response = await client.search({
  aggs: {
    JapaneseCars: {
      terms: {
        field: "make",
        include: ["mazda", "honda"],
      },
    },
    ActiveCarManufacturers: {
      terms: {
        field: "make",
        exclude: ["rover", "jensen"],
      },
    },
  },
});
console.log(response);</pre>
</div>
<a id="0264e994a7e68561e2ca6be0f0d90ee9"></a>
<a id="terms-aggregation-exact-example"></a><div class="pre_wrapper lang-console default has-python has-ruby has-go has-js">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-console default has-python has-ruby has-go has-js">GET /_search
{
  "aggs": {
    "JapaneseCars": {
      "terms": {
        "field": "make",
        "include": [ "mazda", "honda" ]
      }
    },
    "ActiveCarManufacturers": {
      "terms": {
        "field": "make",
        "exclude": [ "rover", "jensen" ]
      }
    }
  }
}</pre>
</div>
<div class="console_widget has-python has-ruby has-go has-js" data-snippet="snippets/1524.console"></div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="_filtering_values_with_partitions"></a>Filtering Values with partitions<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/main/docs/reference/aggregations/bucket/terms-aggregation.asciidoc">edit</a></h4>
</div></div></div>
<p>Sometimes there are too many unique terms to process in a single request/response pair so
it can be useful to break the analysis up into multiple requests.
This can be achieved by grouping the field&#8217;s values into a number of partitions at query-time and processing
only one partition in each request.
Consider this request which is looking for accounts that have not logged any access recently:</p>
<div class="pre_wrapper lang-php alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-php alternative">$params = [
    'body' =&gt; [
        'size' =&gt; 0,
        'aggs' =&gt; [
            'expired_sessions' =&gt; [
                'terms' =&gt; [
                    'field' =&gt; 'account_id',
                    'include' =&gt; [
                        'partition' =&gt; 0,
                        'num_partitions' =&gt; 20,
                    ],
                    'size' =&gt; 10000,
                    'order' =&gt; [
                        'last_access' =&gt; 'asc',
                    ],
                ],
                'aggs' =&gt; [
                    'last_access' =&gt; [
                        'max' =&gt; [
                            'field' =&gt; 'access_date',
                        ],
                    ],
                ],
            ],
        ],
    ],
];
$response = $client-&gt;search($params);</pre>
</div>
<div class="pre_wrapper lang-python alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-python alternative">resp = client.search(
    body={
        "size": 0,
        "aggs": {
            "expired_sessions": {
                "terms": {
                    "field": "account_id",
                    "include": {"partition": 0, "num_partitions": 20},
                    "size": 10000,
                    "order": {"last_access": "asc"},
                },
                "aggs": {"last_access": {"max": {"field": "access_date"}}},
            }
        },
    },
)
print(resp)</pre>
</div>
<div class="pre_wrapper lang-ruby alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-ruby alternative">response = client.search(
  body: {
    size: 0,
    aggregations: {
      expired_sessions: {
        terms: {
          field: 'account_id',
          include: {
            partition: 0,
            num_partitions: 20
          },
          size: 10_000,
          order: {
            last_access: 'asc'
          }
        },
        aggregations: {
          last_access: {
            max: {
              field: 'access_date'
            }
          }
        }
      }
    }
  }
)
puts response</pre>
</div>
<div class="pre_wrapper lang-go alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-go alternative">res, err := es.Search(
	es.Search.WithBody(strings.NewReader(`{
	  "size": 0,
	  "aggs": {
	    "expired_sessions": {
	      "terms": {
	        "field": "account_id",
	        "include": {
	          "partition": 0,
	          "num_partitions": 20
	        },
	        "size": 10000,
	        "order": {
	          "last_access": "asc"
	        }
	      },
	      "aggs": {
	        "last_access": {
	          "max": {
	            "field": "access_date"
	          }
	        }
	      }
	    }
	  }
	}`)),
	es.Search.WithPretty(),
)
fmt.Println(res, err)</pre>
</div>
<div class="pre_wrapper lang-js alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-js alternative">const response = await client.search({
  size: 0,
  aggs: {
    expired_sessions: {
      terms: {
        field: "account_id",
        include: {
          partition: 0,
          num_partitions: 20,
        },
        size: 10000,
        order: {
          last_access: "asc",
        },
      },
      aggs: {
        last_access: {
          max: {
            field: "access_date",
          },
        },
      },
    },
  },
});
console.log(response);</pre>
</div>
<a id="5d9d7b84e2fec7ecd832145cbb951cf1"></a>
<a id="terms-aggregation-partitions-example"></a><div class="pre_wrapper lang-console default has-php has-python has-ruby has-go has-js">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-console default has-php has-python has-ruby has-go has-js">GET /_search
{
   "size": 0,
   "aggs": {
      "expired_sessions": {
         "terms": {
            "field": "account_id",
            "include": {
               "partition": 0,
               "num_partitions": 20
            },
            "size": 10000,
            "order": {
               "last_access": "asc"
            }
         },
         "aggs": {
            "last_access": {
               "max": {
                  "field": "access_date"
               }
            }
         }
      }
   }
}</pre>
</div>
<div class="console_widget has-php has-python has-ruby has-go has-js" data-snippet="snippets/1525.console"></div>
<p>This request is finding the last logged access date for a subset of customer accounts because we
might want to expire some customer accounts who haven&#8217;t been seen for a long while.
The <code class="literal">num_partitions</code> setting has requested that the unique account_ids are organized evenly into twenty
partitions (0 to 19). and the <code class="literal">partition</code> setting in this request filters to only consider account_ids falling
into partition 0. Subsequent requests should ask for partitions 1 then 2 etc to complete the expired-account analysis.</p>
<p>Note that the <code class="literal">size</code> setting for the number of results returned needs to be tuned with the <code class="literal">num_partitions</code>.
For this particular account-expiration example the process for balancing values for <code class="literal">size</code> and <code class="literal">num_partitions</code> would be as follows:</p>
<div class="olist orderedlist">
<ol class="orderedlist">
<li class="listitem">
Use the <code class="literal">cardinality</code> aggregation to estimate the total number of unique account_id values
</li>
<li class="listitem">
Pick a value for <code class="literal">num_partitions</code> to break the number from 1) up into more manageable chunks
</li>
<li class="listitem">
Pick a <code class="literal">size</code> value for the number of responses we want from each partition
</li>
<li class="listitem">
Run a test request
</li>
</ol>
</div>
<p>If we have a circuit-breaker error we are trying to do too much in one request and must increase <code class="literal">num_partitions</code>.
If the request was successful but the last account ID in the date-sorted test response was still an account we might want to
expire then we may be missing accounts of interest and have set our numbers too low. We must either</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
increase the <code class="literal">size</code> parameter to return more results per partition (could be heavy on memory) or
</li>
<li class="listitem">
increase the <code class="literal">num_partitions</code> to consider less accounts per request (could increase overall processing time as we need to make more requests)
</li>
</ul>
</div>
<p>Ultimately this is a balancing act between managing the Elasticsearch resources required to process a single request and the volume
of requests that the client application must issue to complete a task.</p>
<div class="warning admon">
<div class="icon"></div>
<div class="admon_content">
<p>Partitions cannot be used together with an <code class="literal">exclude</code> parameter.</p>
</div>
</div>
</div>

</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_multi_field_terms_aggregation"></a>Multi-field terms aggregation<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/main/docs/reference/aggregations/bucket/terms-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>The <code class="literal">terms</code> aggregation does not support collecting terms from multiple fields
in the same document. The reason is that the <code class="literal">terms</code> agg doesn&#8217;t collect the
string term values themselves, but rather uses
<a class="xref" href="search-aggregations-bucket-terms-aggregation.html#search-aggregations-bucket-terms-aggregation-execution-hint" title="Execution hint">global ordinals</a>
to produce a list of all of the unique values in the field. Global ordinals
results in an important performance boost which would not be possible across
multiple fields.</p>
<p>There are three approaches that you can use to perform a <code class="literal">terms</code> agg across
multiple fields:</p>
<div class="variablelist">
<dl class="variablelist">
<dt>
<span class="term">
<a class="xref" href="search-aggregations-bucket-terms-aggregation.html#search-aggregations-bucket-terms-aggregation-script" title="Script">Script</a>
</span>
</dt>
<dd>
Use a script to retrieve terms from multiple fields. This disables the global
ordinals optimization and will be slower than collecting terms from a single
field, but it gives you the flexibility to implement this option at search
time.
</dd>
<dt>
<span class="term">
<a class="xref" href="copy-to.html" title="copy_to"><code class="literal">copy_to</code> field</a>
</span>
</dt>
<dd>
If you know ahead of time that you want to collect the terms from two or more
fields, then use <code class="literal">copy_to</code> in your mapping to create a new dedicated field at
index time which contains the values from both fields. You can aggregate on
this single field, which will benefit from the global ordinals optimization.
</dd>
<dt>
<span class="term">
<a class="xref" href="search-aggregations-bucket-multi-terms-aggregation.html" title="Multi Terms aggregation"><code class="literal">multi_terms</code> aggregation</a>
</span>
</dt>
<dd>
Use multi_terms aggregation to combine terms from multiple fields into a compound key. This
also disables the global ordinals and will be slower than collecting terms from a single field.
It is faster but less flexible than using a script.
</dd>
</dl>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="search-aggregations-bucket-terms-aggregation-collect"></a>Collect mode<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/main/docs/reference/aggregations/bucket/terms-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>Deferring calculation of child aggregations</p>
<p>For fields with many unique terms and a small number of required results it can be more efficient to delay the calculation
of child aggregations until the top parent-level aggs have been pruned. Ordinarily, all branches of the aggregation tree
are expanded in one depth-first pass and only then any pruning occurs.
In some scenarios this can be very wasteful and can hit memory constraints.
An example problem scenario is querying a movie database for the 10 most popular actors and their 5 most common co-stars:</p>
<div class="pre_wrapper lang-python alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-python alternative">resp = client.search(
    body={
        "aggs": {
            "actors": {
                "terms": {"field": "actors", "size": 10},
                "aggs": {
                    "costars": {"terms": {"field": "actors", "size": 5}}
                },
            }
        }
    },
)
print(resp)</pre>
</div>
<div class="pre_wrapper lang-ruby alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-ruby alternative">response = client.search(
  body: {
    aggregations: {
      actors: {
        terms: {
          field: 'actors',
          size: 10
        },
        aggregations: {
          costars: {
            terms: {
              field: 'actors',
              size: 5
            }
          }
        }
      }
    }
  }
)
puts response</pre>
</div>
<div class="pre_wrapper lang-go alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-go alternative">res, err := es.Search(
	es.Search.WithBody(strings.NewReader(`{
	  "aggs": {
	    "actors": {
	      "terms": {
	        "field": "actors",
	        "size": 10
	      },
	      "aggs": {
	        "costars": {
	          "terms": {
	            "field": "actors",
	            "size": 5
	          }
	        }
	      }
	    }
	  }
	}`)),
	es.Search.WithPretty(),
)
fmt.Println(res, err)</pre>
</div>
<div class="pre_wrapper lang-js alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-js alternative">const response = await client.search({
  aggs: {
    actors: {
      terms: {
        field: "actors",
        size: 10,
      },
      aggs: {
        costars: {
          terms: {
            field: "actors",
            size: 5,
          },
        },
      },
    },
  },
});
console.log(response);</pre>
</div>
<a id="653c0d0ef146c997ef6bc6450d4f5f94"></a>
<a id="terms-aggregation-collect-mode-example"></a><div class="pre_wrapper lang-console default has-python has-ruby has-go has-js">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-console default has-python has-ruby has-go has-js">GET /_search
{
  "aggs": {
    "actors": {
      "terms": {
        "field": "actors",
        "size": 10
      },
      "aggs": {
        "costars": {
          "terms": {
            "field": "actors",
            "size": 5
          }
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget has-python has-ruby has-go has-js" data-snippet="snippets/1526.console"></div>
<p>Even though the number of actors may be comparatively small and we want only 50 result buckets there is a combinatorial explosion of buckets
during calculation - a single actor can produce n² buckets where n is the number of actors. The sane option would be to first determine
the 10 most popular actors and only then examine the top co-stars for these 10 actors. This alternative strategy is what we call the <code class="literal">breadth_first</code> collection
mode as opposed to the <code class="literal">depth_first</code> mode.</p>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p>The <code class="literal">breadth_first</code> is the default mode for fields with a cardinality bigger than the requested size or when the cardinality is unknown (numeric fields or scripts for instance).
It is possible to override the default heuristic and to provide a collect mode directly in the request:</p>
</div>
</div>
<div class="pre_wrapper lang-python alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-python alternative">resp = client.search(
    body={
        "aggs": {
            "actors": {
                "terms": {
                    "field": "actors",
                    "size": 10,
                    "collect_mode": "breadth_first",
                },
                "aggs": {
                    "costars": {"terms": {"field": "actors", "size": 5}}
                },
            }
        }
    },
)
print(resp)</pre>
</div>
<div class="pre_wrapper lang-ruby alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-ruby alternative">response = client.search(
  body: {
    aggregations: {
      actors: {
        terms: {
          field: 'actors',
          size: 10,
          collect_mode: 'breadth_first'
        },
        aggregations: {
          costars: {
            terms: {
              field: 'actors',
              size: 5
            }
          }
        }
      }
    }
  }
)
puts response</pre>
</div>
<div class="pre_wrapper lang-go alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-go alternative">res, err := es.Search(
	es.Search.WithBody(strings.NewReader(`{
	  "aggs": {
	    "actors": {
	      "terms": {
	        "field": "actors",
	        "size": 10,
	        "collect_mode": "breadth_first"
	      },
	      "aggs": {
	        "costars": {
	          "terms": {
	            "field": "actors",
	            "size": 5
	          }
	        }
	      }
	    }
	  }
	}`)),
	es.Search.WithPretty(),
)
fmt.Println(res, err)</pre>
</div>
<div class="pre_wrapper lang-js alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-js alternative">const response = await client.search({
  aggs: {
    actors: {
      terms: {
        field: "actors",
        size: 10,
        collect_mode: "breadth_first",
      },
      aggs: {
        costars: {
          terms: {
            field: "actors",
            size: 5,
          },
        },
      },
    },
  },
});
console.log(response);</pre>
</div>
<a id="37530f35f315b9f35e3e6a13cf2a1ccd"></a>
<a id="terms-aggregation-breadth-first-example"></a><div class="pre_wrapper lang-console default has-python has-ruby has-go has-js">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-console default has-python has-ruby has-go has-js">GET /_search
{
  "aggs": {
    "actors": {
      "terms": {
        "field": "actors",
        "size": 10,
        "collect_mode": "breadth_first" <a id="CO360-1"></a><i class="conum" data-value="1"></i>
      },
      "aggs": {
        "costars": {
          "terms": {
            "field": "actors",
            "size": 5
          }
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget has-python has-ruby has-go has-js" data-snippet="snippets/1527.console"></div>
<div class="calloutlist default has-python has-ruby has-go has-js lang-console">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO360-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>the possible values are <code class="literal">breadth_first</code> and <code class="literal">depth_first</code></p>
</td>
</tr>
</table>
</div>
<p>When using <code class="literal">breadth_first</code> mode the set of documents that fall into the uppermost buckets are
cached for subsequent replay so there is a memory overhead in doing this which is linear with the number of matching documents.
Note that the <code class="literal">order</code> parameter can still be used to refer to data from a child aggregation when using the <code class="literal">breadth_first</code> setting - the parent
aggregation understands that this child aggregation will need to be called first before any of the other child aggregations.</p>
<div class="warning admon">
<div class="icon"></div>
<div class="admon_content">
<p>Nested aggregations such as <code class="literal">top_hits</code> which require access to score information under an aggregation that uses the <code class="literal">breadth_first</code>
collection mode need to replay the query on the second pass but only for the documents belonging to the top buckets.</p>
</div>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="search-aggregations-bucket-terms-aggregation-execution-hint"></a>Execution hint<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/main/docs/reference/aggregations/bucket/terms-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>There are different mechanisms by which terms aggregations can be executed:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
by using field values directly in order to aggregate data per-bucket (<code class="literal">map</code>)
</li>
<li class="listitem">
by using global ordinals of the field and allocating one bucket per global ordinal (<code class="literal">global_ordinals</code>)
</li>
</ul>
</div>
<p>Elasticsearch tries to have sensible defaults so this is something that generally doesn&#8217;t need to be configured.</p>
<p><code class="literal">global_ordinals</code> is the default option for <code class="literal">keyword</code> field, it uses global ordinals to allocates buckets dynamically
so memory usage is linear to the number of values of the documents that are part of the aggregation scope.</p>
<p><code class="literal">map</code> should only be considered when very few documents match a query. Otherwise the ordinals-based execution mode
is significantly faster. By default, <code class="literal">map</code> is only used when running an aggregation on scripts, since they don&#8217;t have
ordinals.</p>
<div class="pre_wrapper lang-python alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-python alternative">resp = client.search(
    body={
        "aggs": {
            "tags": {"terms": {"field": "tags", "execution_hint": "map"}}
        }
    },
)
print(resp)</pre>
</div>
<div class="pre_wrapper lang-ruby alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-ruby alternative">response = client.search(
  body: {
    aggregations: {
      tags: {
        terms: {
          field: 'tags',
          execution_hint: 'map'
        }
      }
    }
  }
)
puts response</pre>
</div>
<div class="pre_wrapper lang-go alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-go alternative">res, err := es.Search(
	es.Search.WithBody(strings.NewReader(`{
	  "aggs": {
	    "tags": {
	      "terms": {
	        "field": "tags",
	        "execution_hint": "map"
	      }
	    }
	  }
	}`)),
	es.Search.WithPretty(),
)
fmt.Println(res, err)</pre>
</div>
<div class="pre_wrapper lang-js alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-js alternative">const response = await client.search({
  aggs: {
    tags: {
      terms: {
        field: "tags",
        execution_hint: "map",
      },
    },
  },
});
console.log(response);</pre>
</div>
<a id="8f9a3fcd17a111f63caa3bef6e5f00f2"></a>
<a id="terms-aggregation-execution-hint-example"></a><div class="pre_wrapper lang-console default has-python has-ruby has-go has-js">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-console default has-python has-ruby has-go has-js">GET /_search
{
  "aggs": {
    "tags": {
      "terms": {
        "field": "tags",
        "execution_hint": "map" <a id="CO361-1"></a><i class="conum" data-value="1"></i>
      }
    }
  }
}</pre>
</div>
<div class="console_widget has-python has-ruby has-go has-js" data-snippet="snippets/1528.console"></div>
<div class="calloutlist default has-python has-ruby has-go has-js lang-console">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO361-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>The possible values are <code class="literal">map</code>, <code class="literal">global_ordinals</code></p>
</td>
</tr>
</table>
</div>
<p>Please note that Elasticsearch will ignore this execution hint if it is not applicable and that there is no backward compatibility guarantee on these hints.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_missing_value_5"></a>Missing value<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/main/docs/reference/aggregations/bucket/terms-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>The <code class="literal">missing</code> parameter defines how documents that are missing a value should be treated.
By default they will be ignored but it is also possible to treat them as if they
had a value.</p>
<div class="pre_wrapper lang-python alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-python alternative">resp = client.search(
    body={
        "aggs": {"tags": {"terms": {"field": "tags", "missing": "N/A"}}}
    },
)
print(resp)</pre>
</div>
<div class="pre_wrapper lang-ruby alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-ruby alternative">response = client.search(
  body: {
    aggregations: {
      tags: {
        terms: {
          field: 'tags',
          missing: 'N/A'
        }
      }
    }
  }
)
puts response</pre>
</div>
<div class="pre_wrapper lang-go alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-go alternative">res, err := es.Search(
	es.Search.WithBody(strings.NewReader(`{
	  "aggs": {
	    "tags": {
	      "terms": {
	        "field": "tags",
	        "missing": "N/A"
	      }
	    }
	  }
	}`)),
	es.Search.WithPretty(),
)
fmt.Println(res, err)</pre>
</div>
<div class="pre_wrapper lang-js alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-js alternative">const response = await client.search({
  aggs: {
    tags: {
      terms: {
        field: "tags",
        missing: "N/A",
      },
    },
  },
});
console.log(response);</pre>
</div>
<a id="7ca224d1a7de20a15c008e1b9dbda377"></a>
<a id="terms-aggregation-missing-example"></a><div class="pre_wrapper lang-console default has-python has-ruby has-go has-js">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-console default has-python has-ruby has-go has-js">GET /_search
{
  "aggs": {
    "tags": {
      "terms": {
        "field": "tags",
        "missing": "N/A" <a id="CO362-1"></a><i class="conum" data-value="1"></i>
      }
    }
  }
}</pre>
</div>
<div class="console_widget has-python has-ruby has-go has-js" data-snippet="snippets/1529.console"></div>
<div class="calloutlist default has-python has-ruby has-go has-js lang-console">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO362-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>Documents without a value in the <code class="literal">tags</code> field will fall into the same bucket as documents that have the value <code class="literal">N/A</code>.</p>
</td>
</tr>
</table>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_mixing_field_types_2"></a>Mixing field types<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/main/docs/reference/aggregations/bucket/terms-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<div class="warning admon">
<div class="icon"></div>
<div class="admon_content">
<p>When aggregating on multiple indices the type of the aggregated field may not be the same in all indices.
Some types are compatible with each other (<code class="literal">integer</code> and <code class="literal">long</code> or <code class="literal">float</code> and <code class="literal">double</code>) but when the types are a mix
of decimal and non-decimal number the terms aggregation will promote the non-decimal numbers to decimal numbers.
This can result in a loss of precision in the bucket values.</p>
</div>
</div>
<h4><a id="search-aggregations-bucket-terms-aggregation-troubleshooting"></a>Troubleshooting<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/main/docs/reference/aggregations/bucket/terms-aggregation.asciidoc">edit</a></h4>
<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="_failed_trying_to_format_bytes"></a>Failed Trying to Format Bytes<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/main/docs/reference/aggregations/bucket/terms-aggregation.asciidoc">edit</a></h4>
</div></div></div>
<p>When running a terms aggregation (or other aggregation, but in practice usually
terms) over multiple indices, you may get an error that starts with "Failed
trying to format bytes&#8230;&#8203;".  This is usually caused by two of the indices not
having the same mapping type for the field being aggregated.</p>
<p><span class="strong strong"><strong>Use an explicit <code class="literal">value_type</code></strong></span>
Although it&#8217;s best to correct the mappings, you can work around this issue if
the field is unmapped in one of the indices.  Setting the <code class="literal">value_type</code> parameter
can resolve the issue by coercing the unmapped field into the correct type.</p>
<div class="pre_wrapper lang-python alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-python alternative">resp = client.search(
    body={
        "aggs": {
            "ip_addresses": {
                "terms": {
                    "field": "destination_ip",
                    "missing": "0.0.0.0",
                    "value_type": "ip",
                }
            }
        }
    },
)
print(resp)</pre>
</div>
<div class="pre_wrapper lang-ruby alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-ruby alternative">response = client.search(
  body: {
    aggregations: {
      ip_addresses: {
        terms: {
          field: 'destination_ip',
          missing: '0.0.0.0',
          value_type: 'ip'
        }
      }
    }
  }
)
puts response</pre>
</div>
<div class="pre_wrapper lang-js alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-js alternative">const response = await client.search({
  aggs: {
    ip_addresses: {
      terms: {
        field: "destination_ip",
        missing: "0.0.0.0",
        value_type: "ip",
      },
    },
  },
});
console.log(response);</pre>
</div>
<a id="e316271f668c9889bf548311fb421f1e"></a>
<a id="terms-aggregation-value_type-example"></a><div class="pre_wrapper lang-console default has-python has-ruby has-js">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-console default has-python has-ruby has-js">GET /_search
{
  "aggs": {
    "ip_addresses": {
      "terms": {
        "field": "destination_ip",
        "missing": "0.0.0.0",
        "value_type": "ip"
      }
    }
  }
}</pre>
</div>
<div class="console_widget has-python has-ruby has-js" data-snippet="snippets/1530.console"></div>
</div>

</div>

</div>
</div>
</div><div class="navfooter">
<span class="prev">
<a href="search-aggregations-bucket-significanttext-aggregation.html">« Significant text aggregation</a>
</span>
<span class="next">
<a href="search-aggregations-bucket-time-series-aggregation.html">Time series aggregation »</a>
</span>
</div>
</body>
</html>
