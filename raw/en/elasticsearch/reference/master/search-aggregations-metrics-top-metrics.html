<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Top metrics aggregation | Elasticsearch Guide [master] | Elastic</title>
<meta class="elastic" name="content" content="Top metrics aggregation | Elasticsearch Guide [master]">

<link rel="home" href="index.html" title="Elasticsearch Guide [master]"/>
<link rel="up" href="search-aggregations-metrics.html" title="Metrics aggregations"/>
<link rel="prev" href="search-aggregations-metrics-top-hits-aggregation.html" title="Top hits aggregation"/>
<link rel="next" href="search-aggregations-metrics-valuecount-aggregation.html" title="Value count aggregation"/>
<meta class="elastic" name="product_version" content="master"/>
<meta class="elastic" name="product_name" content="Elasticsearch"/>
<meta class="elastic" name="website_area" content="documentation"/>
<meta name="DC.type" content="Learn/Docs/Elasticsearch/Reference/master"/>
<meta name="DC.subject" content="Elasticsearch"/>
<meta name="DC.identifier" content="master"/>
<meta name="robots" content="noindex,nofollow"/>
</head>
<body><div class="page_header">
You are looking at preliminary documentation for a future release.
Not what you want? See the
<a href="../current/index.html">current release documentation</a>.
</div>
<div id="content">
<div class="breadcrumbs">
<span class="breadcrumb-link"><a href="/guide/">Elastic Docs</a></span>
<span class="chevron-right">›</span><span class="breadcrumb-link"><a href="index.html">Elasticsearch Guide [master]</a></span>
<span class="chevron-right">›</span><span class="breadcrumb-link"><a href="search-aggregations.html">Aggregations</a></span>
<span class="chevron-right">›</span><span class="breadcrumb-link"><a href="search-aggregations-metrics.html">Metrics aggregations</a></span>
</div>
<div class="navheader">
<span class="prev">
<a href="search-aggregations-metrics-top-hits-aggregation.html">« Top hits aggregation</a>
</span>
<span class="next">
<a href="search-aggregations-metrics-valuecount-aggregation.html">Value count aggregation »</a>
</span>
</div>
<div class="section xpack">
<div class="titlepage"><div><div>
<h2 class="title"><a id="search-aggregations-metrics-top-metrics"></a>Top metrics aggregation<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch/edit/main/docs/reference/aggregations/metrics/top-metrics-aggregation.asciidoc">edit</a></h2>
</div></div></div>

<p>The <code class="literal">top_metrics</code> aggregation selects metrics from the document with the largest or smallest "sort"
value. For example, this gets the value of the <code class="literal">m</code> field on the document with the largest value of <code class="literal">s</code>:</p>
<div class="pre_wrapper lang-ruby alternative">
<pre class="programlisting prettyprint lang-ruby alternative">response = client.bulk(
  index: 'test',
  refresh: true,
  body: [
    {
      index: {}
    },
    {
      s: 1,
      m: 3.1415
    },
    {
      index: {}
    },
    {
      s: 2,
      m: 1
    },
    {
      index: {}
    },
    {
      s: 3,
      m: 2.71828
    }
  ]
)
puts response

response = client.search(
  index: 'test',
  filter_path: 'aggregations',
  body: {
    aggregations: {
      tm: {
        top_metrics: {
          metrics: {
            field: 'm'
          },
          sort: {
            s: 'desc'
          }
        }
      }
    }
  }
)
puts response</pre>
</div>
<a id="9d1fb129ac783355a20097effded1845"></a>
<a id="search-aggregations-metrics-top-metrics-simple"></a><div class="pre_wrapper lang-console default has-ruby">
<pre class="programlisting prettyprint lang-console default has-ruby">POST /test/_bulk?refresh
{"index": {}}
{"s": 1, "m": 3.1415}
{"index": {}}
{"s": 2, "m": 1.0}
{"index": {}}
{"s": 3, "m": 2.71828}
POST /test/_search?filter_path=aggregations
{
  "aggs": {
    "tm": {
      "top_metrics": {
        "metrics": {"field": "m"},
        "sort": {"s": "desc"}
      }
    }
  }
}</pre>
</div>
<div class="console_widget has-ruby" data-snippet="snippets/1434.console"></div>
<p>Which returns:</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">{
  "aggregations": {
    "tm": {
      "top": [ {"sort": [3], "metrics": {"m": 2.718280076980591 } } ]
    }
  }
}</pre>
</div>
<p><code class="literal">top_metrics</code> is fairly similar to <a class="xref" href="search-aggregations-metrics-top-hits-aggregation.html" title="Top hits aggregation"><code class="literal">top_hits</code></a>
in spirit but because it is more limited it is able to do its job using less memory and is often
faster.</p>
<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_sort"></a><code class="literal">sort</code><a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch/edit/main/docs/reference/aggregations/metrics/top-metrics-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>The <code class="literal">sort</code> field in the metric request functions exactly the same as the <code class="literal">sort</code> field in the
<a class="xref" href="sort-search-results.html" title="Sort search results">search</a> request except:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
It can&#8217;t be used on <a class="xref" href="binary.html" title="Binary field type">binary</a>, <a class="xref" href="flattened.html" title="Flattened field type">flattened</a>, <a class="xref" href="ip.html" title="IP field type">ip</a>,
<a class="xref" href="keyword.html" title="Keyword type family">keyword</a>, or <a class="xref" href="text.html" title="Text type family">text</a> fields.
</li>
<li class="listitem">
It only supports a single sort value so which document wins ties is not specified.
</li>
</ul>
</div>
<p>The metrics that the aggregation returns is the first hit that would be returned by the search
request. So,</p>
<div class="variablelist">
<dl class="variablelist">
<dt>
<span class="term">
<code class="literal">"sort": {"s": "desc"}</code>
</span>
</dt>
<dd>
gets metrics from the document with the highest <code class="literal">s</code>
</dd>
<dt>
<span class="term">
<code class="literal">"sort": {"s": "asc"}</code>
</span>
</dt>
<dd>
gets the metrics from the document with the lowest <code class="literal">s</code>
</dd>
<dt>
<span class="term">
<code class="literal">"sort": {"_geo_distance": {"location": "POINT (-78.6382 35.7796)"}}</code>
</span>
</dt>
<dd>
gets metrics from the documents with <code class="literal">location</code> <span class="strong strong"><strong>closest</strong></span> to <code class="literal">35.7796, -78.6382</code>
</dd>
<dt>
<span class="term">
<code class="literal">"sort": "_score"</code>
</span>
</dt>
<dd>
gets metrics from the document with the highest score
</dd>
</dl>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_metrics"></a><code class="literal">metrics</code><a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch/edit/main/docs/reference/aggregations/metrics/top-metrics-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p><code class="literal">metrics</code> selects the fields of the "top" document to return. You can request
a single metric with something like <code class="literal">"metrics": {"field": "m"}</code> or multiple
metrics by requesting a list of metrics like <code class="literal">"metrics": [{"field": "m"}, {"field": "i"}</code>.</p>
<p><code class="literal">metrics.field</code> supports the following field types:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
<a class="xref" href="boolean.html" title="Boolean field type"><code class="literal">boolean</code></a>
</li>
<li class="listitem">
<a class="xref" href="ip.html" title="IP field type"><code class="literal">ip</code></a>
</li>
<li class="listitem">
<a class="xref" href="keyword.html" title="Keyword type family">keywords</a>
</li>
<li class="listitem">
<a class="xref" href="number.html" title="Numeric field types">numbers</a>
</li>
</ul>
</div>
<p>Except for keywords, <a class="xref" href="runtime.html" title="Runtime fields">runtime fields</a> for corresponding types are also
supported. <code class="literal">metrics.field</code> doesn&#8217;t support fields with <a class="xref" href="array.html" title="Arrays">array values</a>. A
<code class="literal">top_metric</code> aggregation on array values may return inconsistent results.</p>
<p>The following example runs a <code class="literal">top_metrics</code> aggregation on several field types.</p>
<div class="pre_wrapper lang-ruby alternative">
<pre class="programlisting prettyprint lang-ruby alternative">response = client.indices.create(
  index: 'test',
  body: {
    mappings: {
      properties: {
        d: {
          type: 'date'
        }
      }
    }
  }
)
puts response

response = client.bulk(
  index: 'test',
  refresh: true,
  body: [
    {
      index: {}
    },
    {
      s: 1,
      m: 3.1415,
      i: 1,
      d: '2020-01-01T00:12:12Z',
      t: 'cat'
    },
    {
      index: {}
    },
    {
      s: 2,
      m: 1,
      i: 6,
      d: '2020-01-02T00:12:12Z',
      t: 'dog'
    },
    {
      index: {}
    },
    {
      s: 3,
      m: 2.71828,
      i: -12,
      d: '2019-12-31T00:12:12Z',
      t: 'chicken'
    }
  ]
)
puts response

response = client.search(
  index: 'test',
  filter_path: 'aggregations',
  body: {
    aggregations: {
      tm: {
        top_metrics: {
          metrics: [
            {
              field: 'm'
            },
            {
              field: 'i'
            },
            {
              field: 'd'
            },
            {
              field: 't.keyword'
            }
          ],
          sort: {
            s: 'desc'
          }
        }
      }
    }
  }
)
puts response</pre>
</div>
<a id="b00d74eed431a272c829c0f798e3a539"></a>
<a id="search-aggregations-metrics-top-metrics-list-of-metrics"></a><div class="pre_wrapper lang-console default has-ruby">
<pre class="programlisting prettyprint lang-console default has-ruby">PUT /test
{
  "mappings": {
    "properties": {
      "d": {"type": "date"}
    }
  }
}
POST /test/_bulk?refresh
{"index": {}}
{"s": 1, "m": 3.1415, "i": 1, "d": "2020-01-01T00:12:12Z", "t": "cat"}
{"index": {}}
{"s": 2, "m": 1.0, "i": 6, "d": "2020-01-02T00:12:12Z", "t": "dog"}
{"index": {}}
{"s": 3, "m": 2.71828, "i": -12, "d": "2019-12-31T00:12:12Z", "t": "chicken"}
POST /test/_search?filter_path=aggregations
{
  "aggs": {
    "tm": {
      "top_metrics": {
        "metrics": [
          {"field": "m"},
          {"field": "i"},
          {"field": "d"},
          {"field": "t.keyword"}
        ],
        "sort": {"s": "desc"}
      }
    }
  }
}</pre>
</div>
<div class="console_widget has-ruby" data-snippet="snippets/1435.console"></div>
<p>Which returns:</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">{
  "aggregations": {
    "tm": {
      "top": [ {
        "sort": [3],
        "metrics": {
          "m": 2.718280076980591,
          "i": -12,
          "d": "2019-12-31T00:12:12.000Z",
          "t.keyword": "chicken"
        }
      } ]
    }
  }
}</pre>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_missing"></a><code class="literal">missing</code><a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch/edit/main/docs/reference/aggregations/metrics/top-metrics-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p>The <code class="literal">missing</code> parameter defines how documents with a missing value are treated.
By default, if any of the key components are missing, the entire document is
ignored. It is possible to treat the missing components as if they had a value
by using the <code class="literal">missing</code> parameter.</p>
<a id="376ff4b2b5f657481af78a778aaab57f"></a>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">PUT /my-index
{
  "mappings": {
    "properties": {
      "nr":    { "type": "integer" },
      "state":  { "type": "keyword"  } <a id="CO332-1"></a><i class="conum" data-value="1"></i>
    }
  }
}
POST /my-index/_bulk?refresh
{"index": {}}
{"nr": 1, "state": "started"}
{"index": {}}
{"nr": 2, "state": "stopped"}
{"index": {}}
{"nr": 3, "state": "N/A"}
{"index": {}}
{"nr": 4} <a id="CO332-2"></a><i class="conum" data-value="2"></i>
POST /my-index/_search?filter_path=aggregations
{
  "aggs": {
    "my_top_metrics": {
      "top_metrics": {
        "metrics": {
          "field": "state",
          "missing": "N/A"}, <a id="CO332-3"></a><i class="conum" data-value="3"></i>
        "sort": {"nr": "desc"}
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1436.console"></div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO332-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>If you want to use an aggregation on textual content, it must be a <code class="literal">keyword</code>
type field or you must enable fielddata on that field.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO332-2"><i class="conum" data-value="2"></i></a></p>
</td>
<td align="left" valign="top">
<p>This document has a missing <code class="literal">state</code> field value.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO332-3"><i class="conum" data-value="3"></i></a></p>
</td>
<td align="left" valign="top">
<p>The <code class="literal">missing</code> parameter defines that if <code class="literal">state</code> field has a missing value,
it should be treated as if it had the <code class="literal">N/A</code> value.</p>
</td>
</tr>
</table>
</div>
<p>The request results in the following response:</p>
<a id="4a134149b563eb2613a2f6637c245f76"></a>
<div class="pre_wrapper lang-console-result">
<pre class="programlisting prettyprint lang-console-result">{
  "aggregations": {
    "my_top_metrics": {
      "top": [
        {
          "sort": [
            4
          ],
          "metrics": {
            "state": "N/A"
          }
        }
      ]
    }
  }
}</pre>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_size_2"></a><code class="literal">size</code><a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch/edit/main/docs/reference/aggregations/metrics/top-metrics-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<p><code class="literal">top_metrics</code> can return the top few document&#8217;s worth of metrics using the size parameter:</p>
<div class="pre_wrapper lang-ruby alternative">
<pre class="programlisting prettyprint lang-ruby alternative">response = client.bulk(
  index: 'test',
  refresh: true,
  body: [
    {
      index: {}
    },
    {
      s: 1,
      m: 3.1415
    },
    {
      index: {}
    },
    {
      s: 2,
      m: 1
    },
    {
      index: {}
    },
    {
      s: 3,
      m: 2.71828
    }
  ]
)
puts response

response = client.search(
  index: 'test',
  filter_path: 'aggregations',
  body: {
    aggregations: {
      tm: {
        top_metrics: {
          metrics: {
            field: 'm'
          },
          sort: {
            s: 'desc'
          },
          size: 3
        }
      }
    }
  }
)
puts response</pre>
</div>
<a id="6013ed65d2058da5ce704b47a504b60a"></a>
<a id="search-aggregations-metrics-top-metrics-size"></a><div class="pre_wrapper lang-console default has-ruby">
<pre class="programlisting prettyprint lang-console default has-ruby">POST /test/_bulk?refresh
{"index": {}}
{"s": 1, "m": 3.1415}
{"index": {}}
{"s": 2, "m": 1.0}
{"index": {}}
{"s": 3, "m": 2.71828}
POST /test/_search?filter_path=aggregations
{
  "aggs": {
    "tm": {
      "top_metrics": {
        "metrics": {"field": "m"},
        "sort": {"s": "desc"},
        "size": 3
      }
    }
  }
}</pre>
</div>
<div class="console_widget has-ruby" data-snippet="snippets/1437.console"></div>
<p>Which returns:</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">{
  "aggregations": {
    "tm": {
      "top": [
        {"sort": [3], "metrics": {"m": 2.718280076980591 } },
        {"sort": [2], "metrics": {"m": 1.0 } },
        {"sort": [1], "metrics": {"m": 3.1414999961853027 } }
      ]
    }
  }
}</pre>
</div>
<p>The default <code class="literal">size</code> is 1. The maximum default size is <code class="literal">10</code> because the aggregation&#8217;s
working storage is "dense", meaning we allocate <code class="literal">size</code> slots for every bucket. <code class="literal">10</code>
is a <span class="strong strong"><strong>very</strong></span> conservative default maximum and you can raise it if you need to by
changing the <code class="literal">top_metrics_max_size</code> index setting. But know that large sizes can
take a fair bit of memory, especially if they are inside of an aggregation which
makes many buckes like a large
<a class="xref" href="search-aggregations-metrics-top-metrics.html#search-aggregations-metrics-top-metrics-example-terms" title="Use with terms">terms aggregation</a>. If
you till want to raise it, use something like:</p>
<div class="pre_wrapper lang-ruby alternative">
<pre class="programlisting prettyprint lang-ruby alternative">response = client.indices.put_settings(
  index: 'test',
  body: {
    top_metrics_max_size: 100
  }
)
puts response</pre>
</div>
<a id="b63ce79ce4fa1bb9b99a789f4dcfef4e"></a>
<div class="pre_wrapper lang-console default has-ruby">
<pre class="programlisting prettyprint lang-console default has-ruby">PUT /test/_settings
{
  "top_metrics_max_size": 100
}</pre>
</div>
<div class="console_widget has-ruby" data-snippet="snippets/1438.console"></div>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p>If <code class="literal">size</code> is more than <code class="literal">1</code> the <code class="literal">top_metrics</code> aggregation can&#8217;t be the <span class="strong strong"><strong>target</strong></span> of a sort.</p>
</div>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_examples"></a>Examples<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch/edit/main/docs/reference/aggregations/metrics/top-metrics-aggregation.asciidoc">edit</a></h3>
</div></div></div>
<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="search-aggregations-metrics-top-metrics-example-terms"></a>Use with terms<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch/edit/main/docs/reference/aggregations/metrics/top-metrics-aggregation.asciidoc">edit</a></h4>
</div></div></div>
<p>This aggregation should be quite useful inside of <a class="xref" href="search-aggregations-bucket-terms-aggregation.html" title="Terms aggregation"><code class="literal">terms</code></a>
aggregation, to, say, find the last value reported by each server.</p>
<div class="pre_wrapper lang-ruby alternative">
<pre class="programlisting prettyprint lang-ruby alternative">response = client.indices.create(
  index: 'node',
  body: {
    mappings: {
      properties: {
        ip: {
          type: 'ip'
        },
        date: {
          type: 'date'
        }
      }
    }
  }
)
puts response

response = client.bulk(
  index: 'node',
  refresh: true,
  body: [
    {
      index: {}
    },
    {
      ip: '192.168.0.1',
      date: '2020-01-01T01:01:01',
      m: 1
    },
    {
      index: {}
    },
    {
      ip: '192.168.0.1',
      date: '2020-01-01T02:01:01',
      m: 2
    },
    {
      index: {}
    },
    {
      ip: '192.168.0.2',
      date: '2020-01-01T02:01:01',
      m: 3
    }
  ]
)
puts response

response = client.search(
  index: 'node',
  filter_path: 'aggregations',
  body: {
    aggregations: {
      ip: {
        terms: {
          field: 'ip'
        },
        aggregations: {
          tm: {
            top_metrics: {
              metrics: {
                field: 'm'
              },
              sort: {
                date: 'desc'
              }
            }
          }
        }
      }
    }
  }
)
puts response</pre>
</div>
<a id="5b3384992c398ea8a3064d2e08725e2b"></a>
<a id="search-aggregations-metrics-top-metrics-terms"></a><div class="pre_wrapper lang-console default has-ruby">
<pre class="programlisting prettyprint lang-console default has-ruby">PUT /node
{
  "mappings": {
    "properties": {
      "ip": {"type": "ip"},
      "date": {"type": "date"}
    }
  }
}
POST /node/_bulk?refresh
{"index": {}}
{"ip": "192.168.0.1", "date": "2020-01-01T01:01:01", "m": 1}
{"index": {}}
{"ip": "192.168.0.1", "date": "2020-01-01T02:01:01", "m": 2}
{"index": {}}
{"ip": "192.168.0.2", "date": "2020-01-01T02:01:01", "m": 3}
POST /node/_search?filter_path=aggregations
{
  "aggs": {
    "ip": {
      "terms": {
        "field": "ip"
      },
      "aggs": {
        "tm": {
          "top_metrics": {
            "metrics": {"field": "m"},
            "sort": {"date": "desc"}
          }
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget has-ruby" data-snippet="snippets/1439.console"></div>
<p>Which returns:</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">{
  "aggregations": {
    "ip": {
      "buckets": [
        {
          "key": "192.168.0.1",
          "doc_count": 2,
          "tm": {
            "top": [ {"sort": ["2020-01-01T02:01:01.000Z"], "metrics": {"m": 2 } } ]
          }
        },
        {
          "key": "192.168.0.2",
          "doc_count": 1,
          "tm": {
            "top": [ {"sort": ["2020-01-01T02:01:01.000Z"], "metrics": {"m": 3 } } ]
          }
        }
      ],
      "doc_count_error_upper_bound": 0,
      "sum_other_doc_count": 0
    }
  }
}</pre>
</div>
<p>Unlike <code class="literal">top_hits</code>, you can sort buckets by the results of this metric:</p>
<div class="pre_wrapper lang-ruby alternative">
<pre class="programlisting prettyprint lang-ruby alternative">response = client.search(
  index: 'node',
  filter_path: 'aggregations',
  body: {
    aggregations: {
      ip: {
        terms: {
          field: 'ip',
          order: {
            "tm.m": 'desc'
          }
        },
        aggregations: {
          tm: {
            top_metrics: {
              metrics: {
                field: 'm'
              },
              sort: {
                date: 'desc'
              }
            }
          }
        }
      }
    }
  }
)
puts response</pre>
</div>
<a id="4af15c4f26ddefb9c350e7a246a66a15"></a>
<div class="pre_wrapper lang-console default has-ruby">
<pre class="programlisting prettyprint lang-console default has-ruby">POST /node/_search?filter_path=aggregations
{
  "aggs": {
    "ip": {
      "terms": {
        "field": "ip",
        "order": {"tm.m": "desc"}
      },
      "aggs": {
        "tm": {
          "top_metrics": {
            "metrics": {"field": "m"},
            "sort": {"date": "desc"}
          }
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget has-ruby" data-snippet="snippets/1440.console"></div>
<p>Which returns:</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">{
  "aggregations": {
    "ip": {
      "buckets": [
        {
          "key": "192.168.0.2",
          "doc_count": 1,
          "tm": {
            "top": [ {"sort": ["2020-01-01T02:01:01.000Z"], "metrics": {"m": 3 } } ]
          }
        },
        {
          "key": "192.168.0.1",
          "doc_count": 2,
          "tm": {
            "top": [ {"sort": ["2020-01-01T02:01:01.000Z"], "metrics": {"m": 2 } } ]
          }
        }
      ],
      "doc_count_error_upper_bound": 0,
      "sum_other_doc_count": 0
    }
  }
}</pre>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="_mixed_sort_types"></a>Mixed sort types<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch/edit/main/docs/reference/aggregations/metrics/top-metrics-aggregation.asciidoc">edit</a></h4>
</div></div></div>
<p>Sorting <code class="literal">top_metrics</code> by a field that has different types across different
indices producs somewhat surprising results: floating point fields are
always sorted independently of whole numbered fields.</p>
<div class="pre_wrapper lang-ruby alternative">
<pre class="programlisting prettyprint lang-ruby alternative">response = client.bulk(
  index: 'test',
  refresh: true,
  body: [
    {
      index: {
        _index: 'test1'
      }
    },
    {
      s: 1,
      m: 3.1415
    },
    {
      index: {
        _index: 'test1'
      }
    },
    {
      s: 2,
      m: 1
    },
    {
      index: {
        _index: 'test2'
      }
    },
    {
      s: 3.1,
      m: 2.71828
    }
  ]
)
puts response

response = client.search(
  index: 'test*',
  filter_path: 'aggregations',
  body: {
    aggregations: {
      tm: {
        top_metrics: {
          metrics: {
            field: 'm'
          },
          sort: {
            s: 'asc'
          }
        }
      }
    }
  }
)
puts response</pre>
</div>
<a id="2d2f5ec97aa34ff7822a6a1ed08ef335"></a>
<a id="search-aggregations-metrics-top-metrics-mixed-sort"></a><div class="pre_wrapper lang-console default has-ruby">
<pre class="programlisting prettyprint lang-console default has-ruby">POST /test/_bulk?refresh
{"index": {"_index": "test1"}}
{"s": 1, "m": 3.1415}
{"index": {"_index": "test1"}}
{"s": 2, "m": 1}
{"index": {"_index": "test2"}}
{"s": 3.1, "m": 2.71828}
POST /test*/_search?filter_path=aggregations
{
  "aggs": {
    "tm": {
      "top_metrics": {
        "metrics": {"field": "m"},
        "sort": {"s": "asc"}
      }
    }
  }
}</pre>
</div>
<div class="console_widget has-ruby" data-snippet="snippets/1441.console"></div>
<p>Which returns:</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">{
  "aggregations": {
    "tm": {
      "top": [ {"sort": [3.0999999046325684], "metrics": {"m": 2.718280076980591 } } ]
    }
  }
}</pre>
</div>
<p>While this is better than an error it <span class="strong strong"><strong>probably</strong></span> isn&#8217;t what you were going for.
While it does lose some precision, you can explicitly cast the whole number
fields to floating points with something like:</p>
<div class="pre_wrapper lang-ruby alternative">
<pre class="programlisting prettyprint lang-ruby alternative">response = client.search(
  index: 'test*',
  filter_path: 'aggregations',
  body: {
    aggregations: {
      tm: {
        top_metrics: {
          metrics: {
            field: 'm'
          },
          sort: {
            s: {
              order: 'asc',
              numeric_type: 'double'
            }
          }
        }
      }
    }
  }
)
puts response</pre>
</div>
<a id="56da9c55774f4c2e8eadde0579bdc60c"></a>
<div class="pre_wrapper lang-console default has-ruby">
<pre class="programlisting prettyprint lang-console default has-ruby">POST /test*/_search?filter_path=aggregations
{
  "aggs": {
    "tm": {
      "top_metrics": {
        "metrics": {"field": "m"},
        "sort": {"s": {"order": "asc", "numeric_type": "double"}}
      }
    }
  }
}</pre>
</div>
<div class="console_widget has-ruby" data-snippet="snippets/1442.console"></div>
<p>Which returns the much more expected:</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">{
  "aggregations": {
    "tm": {
      "top": [ {"sort": [1.0], "metrics": {"m": 3.1414999961853027 } } ]
    }
  }
}</pre>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="_use_in_pipeline_aggregations_2"></a>Use in pipeline aggregations<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/elasticsearch/edit/main/docs/reference/aggregations/metrics/top-metrics-aggregation.asciidoc">edit</a></h4>
</div></div></div>
<p><code class="literal">top_metrics</code> can be used in pipeline aggregations that consume a single value per bucket, such as <code class="literal">bucket_selector</code>
that applies per bucket filtering, similar to using a HAVING clause in SQL. This requires setting <code class="literal">size</code> to 1, and
specifying the right path for the (single) metric to be passed to the wrapping aggregator. For example:</p>
<a id="bdfb86cdfffb9d2ee6e3d399f00a57b0"></a>
<div class="pre_wrapper lang-console">
<pre class="programlisting prettyprint lang-console">POST /test*/_search?filter_path=aggregations
{
  "aggs": {
    "ip": {
      "terms": {
        "field": "ip"
      },
      "aggs": {
        "tm": {
          "top_metrics": {
            "metrics": {"field": "m"},
            "sort": {"s": "desc"},
            "size": 1
          }
        },
        "having_tm": {
          "bucket_selector": {
            "buckets_path": {
              "top_m": "tm[m]"
            },
            "script": "params.top_m &lt; 1000"
          }
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget" data-snippet="snippets/1443.console"></div>
<p>The <code class="literal">bucket_path</code> uses the <code class="literal">top_metrics</code> name <code class="literal">tm</code> and a keyword for the metric providing the aggregate value,
namely <code class="literal">m</code>.</p>
</div>

</div>

</div>
<div class="navfooter">
<span class="prev">
<a href="search-aggregations-metrics-top-hits-aggregation.html">« Top hits aggregation</a>
</span>
<span class="next">
<a href="search-aggregations-metrics-valuecount-aggregation.html">Value count aggregation »</a>
</span>
</div>
</div>
</body>
</html>
