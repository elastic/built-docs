<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Semantic reranking | Elasticsearch Guide [master] | Elastic</title>
<meta class="elastic" name="content" content="Semantic reranking | Elasticsearch Guide [master]">

<link rel="home" href="index.html" title="Elasticsearch Guide [master]"/>
<link rel="up" href="retrievers-reranking-overview.html" title="Retrievers and reranking"/>
<link rel="prev" href="retrievers-overview.html" title="Retrievers"/>
<link rel="next" href="learning-to-rank.html" title="Learning To Rank"/>
<meta class="elastic" name="product_version" content="master"/>
<meta class="elastic" name="product_name" content="Elasticsearch"/>
<meta class="elastic" name="website_area" content="documentation"/>
<meta name="DC.type" content="Learn/Docs/Elasticsearch/Reference/master"/>
<meta name="DC.subject" content="Elasticsearch"/>
<meta name="DC.identifier" content="master"/>
<meta name="robots" content="noindex,nofollow"/>
</head>
<body>
<div class="page_header">
This documentation contains work-in-progress information for future Elastic Stack and Cloud releases. Use the version selector to view supported release docs. It also contains some Elastic Cloud serverless information. Check out our <a href="https://www.elastic.co/docs/current/serverless">serverless docs</a> for more details.
</div>
<div class="navheader">
<span class="prev">
<a href="retrievers-overview.html">« Retrievers</a>
</span>
<span class="next">
<a href="learning-to-rank.html">Learning To Rank »</a>
</span>
</div>
<div class="book" lang="en">
<div class="titlepage">
<div class="breadcrumbs">
<span class="breadcrumb-link"><a href="/guide/">Elastic Docs</a></span>
<span class="chevron-right">›</span><span class="breadcrumb-link"><a href="index.html">Elasticsearch Guide [master]</a></span>
<span class="chevron-right">›</span><span class="breadcrumb-link"><a href="search-with-elasticsearch.html">Search your data</a></span>
<span class="chevron-right">›</span><span class="breadcrumb-link"><a href="retrievers-reranking-overview.html">Retrievers and reranking</a></span>
</div>
<div>
<div><h1 class="title"><a id="id-1"></a>Semantic reranking</h1><a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/main/docs/reference/search/search-your-data/retrievers-reranking/semantic-reranking.asciidoc">edit</a></div>
</div>
<!--EXTRA-->
</div>
<div id="content">
<div class="section">
<div class="titlepage"><div><div>
<div class="position-relative"><h2 class="title"><a id="semantic-reranking"></a>Semantic reranking</h2><a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/main/docs/reference/search/search-your-data/retrievers-reranking/semantic-reranking.asciidoc">edit</a></div>
</div></div></div>
<div class="warning admon">
<div class="icon"></div>
<div class="admon_content">
<p>This functionality is in technical preview and may be changed or removed in a future release. Elastic will work to fix any issues, but features in technical preview are not subject to the support SLA of official GA features.</p>
</div>
</div>
<div class="tip admon">
<div class="icon"></div>
<div class="admon_content">
<p>This overview focuses more on the high-level concepts and use cases for semantic reranking. For full implementation details on how to set up and use semantic reranking in Elasticsearch, see the <a class="xref" href="retriever.html#text-similarity-reranker-retriever" title="Text Similarity Re-ranker Retriever">reference documentation</a> in the Search API docs.</p>
</div>
</div>
<p>Rerankers improve the relevance of results from earlier-stage retrieval mechanisms.
<em>Semantic</em> rerankers use machine learning models to reorder search results based on their semantic similarity to a query.</p>
<p>First-stage retrievers and rankers must be very fast and efficient because they process either the entire corpus, or all matching documents.
In a multi-stage pipeline, you can progressively use more computationally intensive ranking functions and techniques, as they will operate on smaller result sets at each step.
This helps avoid query latency degradation and keeps costs manageable.</p>
<p>Semantic reranking requires relatively large and complex machine learning models and operates in real-time in response to queries.
This technique makes sense on a small <em>top-k</em> result set, as one the of the final steps in a pipeline.
This is a powerful technique for improving search relevance that works equally well with keyword, semantic, or hybrid retrieval algorithms.</p>
<p>The next sections provide more details on the benefits, use cases, and model types used for semantic reranking.
The final sections include a practical, high-level overview of how to implement <a class="xref" href="semantic-reranking.html#semantic-reranking-in-es" title="Semantic reranking in Elasticsearch">semantic reranking in Elasticsearch</a> and links to the full reference documentation.</p>
<div class="position-relative"><h4><a id="semantic-reranking-use-cases"></a>Use cases</h4><a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/main/docs/reference/search/search-your-data/retrievers-reranking/semantic-reranking.asciidoc">edit</a></div>
<p>Semantic reranking enables a variety of use cases:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
<p><span class="strong strong"><strong>Lexical (BM25) retrieval results reranking</strong></span></p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
Out-of-the-box semantic search by adding a simple API call to any lexical/BM25 retrieval pipeline.
</li>
<li class="listitem">
Adds semantic search capabilities on top of existing indices without reindexing, perfect for quick improvements.
</li>
<li class="listitem">
Ideal for environments with complex existing indices.
</li>
</ul>
</div>
</li>
<li class="listitem">
<p><span class="strong strong"><strong>Semantic retrieval results reranking</strong></span></p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
Improves results from semantic retrievers using ELSER sparse vector embeddings or dense vector embeddings by using more powerful models.
</li>
<li class="listitem">
Adds a refinement layer on top of hybrid retrieval with <a class="xref" href="rrf.html" title="Reciprocal rank fusion">reciprocal rank fusion (RRF)</a>.
</li>
</ul>
</div>
</li>
<li class="listitem">
<p><span class="strong strong"><strong>General applications</strong></span></p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
Supports automatic and transparent chunking, eliminating the need for pre-chunking at index time.
</li>
<li class="listitem">
Provides explicit control over document relevance in retrieval-augmented generation (RAG) uses cases or other scenarios involving language model (LLM) inputs.
</li>
</ul>
</div>
</li>
</ul>
</div>
<p>Now that we&#8217;ve outlined the value of semantic reranking, we&#8217;ll explore the specific models that power this process and how they differ.</p>
<div class="position-relative"><h4><a id="semantic-reranking-models"></a>Cross-encoder and bi-encoder models</h4><a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/main/docs/reference/search/search-your-data/retrievers-reranking/semantic-reranking.asciidoc">edit</a></div>
<p>At a high level, two model types are used for semantic reranking: cross-encoders and bi-encoders.</p>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p>In this version, Elasticsearch <span class="strong strong"><strong>only supports cross-encoders</strong></span> for semantic reranking.</p>
</div>
</div>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
A <span class="strong strong"><strong>cross-encoder model</strong></span> can be thought of as a more powerful, all-in-one solution, because it generates query-aware document representations.
It takes the query and document texts as a single, concatenated input.
</li>
<li class="listitem">
<p>A <span class="strong strong"><strong>bi-encoder model</strong></span> takes as input either document or query text.
Documents and query embeddings are computed separately, so they aren&#8217;t aware of each other.</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
To compute a ranking score, an external operation is required. This typically involves computing dot-product or cosine similarity between the query and document embeddings.
</li>
</ul>
</div>
</li>
</ul>
</div>
<p>In brief, cross-encoders provide high accuracy but are more resource-intensive.
Bi-encoders are faster and more cost-effective but less precise.</p>
<p>In future versions, Elasticsearch will also support bi-encoders.
If you&#8217;re interested in a more detailed analysis of the practical differences between cross-encoders and bi-encoders, untoggle the next section.</p>
<details>
<summary class="title">Comparisons between cross-encoder and bi-encoder</summary>
<div class="content">
<p>The following is a non-exhaustive list of considerations when choosing between cross-encoders and bi-encoders for semantic reranking:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
Because a cross-encoder model simultaneously processes both query and document texts, it can better infer their relevance, making it more effective as a reranker than a bi-encoder.
</li>
<li class="listitem">
Cross-encoder models are generally larger and more computationally intensive, resulting in higher latencies and increased computational costs.
</li>
<li class="listitem">
There are significantly fewer open-source cross-encoders, while bi-encoders offer a wide variety of sizes, languages, and other trade-offs.
</li>
<li class="listitem">
The effectiveness of cross-encoders can also improve the relevance of semantic retrievers.
For example, their ability to take word order into account can improve on dense or sparse embedding retrieval.
</li>
<li class="listitem">
When trained in tandem with specific retrievers (like lexical/BM25), cross-encoders can “correct” typical errors made by those retrievers.
</li>
<li class="listitem">
Cross-encoders output scores that are consistent across queries.
This enables you to maintain high relevance in result sets, by setting a minimum score threshold for all queries.
For example, this is important when using results in a RAG workflow or if you&#8217;re otherwise feeding results to LLMs.
Note that similarity scores from bi-encoders/embedding similarities are <em>query-dependent</em>, meaning you cannot set universal cut-offs.
</li>
<li class="listitem">
Bi-encoders rerank using embeddings. You can improve your reranking latency by creating embeddings at ingest-time. These embeddings can be stored for reranking without being indexed for retrieval, reducing your memory footprint.
</li>
</ul>
</div>
</div>
</details>
<div class="position-relative"><h4><a id="semantic-reranking-in-es"></a>Semantic reranking in Elasticsearch</h4><a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/main/docs/reference/search/search-your-data/retrievers-reranking/semantic-reranking.asciidoc">edit</a></div>
<p>In Elasticsearch, semantic rerankers are implemented using the Elasticsearch <a class="xref" href="inference-apis.html" title="Inference APIs">Inference API</a> and a <a class="xref" href="retriever.html" title="Retriever">retriever</a>.</p>
<p>To use semantic reranking in Elasticsearch, you need to:</p>
<div class="olist orderedlist">
<ol class="orderedlist">
<li class="listitem">
<p><span class="strong strong"><strong>Choose a reranking model</strong></span>.
Currently you can:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
Integrate directly with the <a class="xref" href="infer-service-cohere.html" title="Cohere inference service">Cohere Rerank inference endpoint</a> using the <code class="literal">rerank</code> task type
</li>
<li class="listitem">
Integrate directly with the <a class="xref" href="infer-service-google-vertex-ai.html" title="Google Vertex AI inference service">Google Vertex AI inference endpoint</a> using the <code class="literal">rerank</code> task type
</li>
<li class="listitem">
<p>Upload a model to Elasticsearch from Hugging Face with <a href="/guide/en/elasticsearch/client/eland/current/machine-learning.html#ml-nlp-pytorch" class="ulink" target="_top">Eland</a>. You&#8217;ll need to use the <code class="literal">text_similarity</code> NLP task type when loading the model using Eland. Refer to <a href="/guide/en/machine-learning/master/ml-nlp-model-ref.html#ml-nlp-model-ref-text-similarity" class="ulink" target="_top">the Elastic NLP model reference</a> for a list of third party text similarity models supported by Elasticsearch for semantic reranking.</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
Then set up an <a class="xref" href="infer-service-elasticsearch.html#inference-example-eland" title="Models uploaded by Eland via the elasticsearch service">Elasticsearch service inference endpoint</a> with the <code class="literal">rerank</code> task type
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li class="listitem">
<span class="strong strong"><strong>Create a <code class="literal">rerank</code> task using the <a class="xref" href="put-inference-api.html" title="Create inference API">Elasticsearch Inference API</a></strong></span>.
The Inference API creates an inference endpoint and configures your chosen machine learning model to perform the reranking task.
</li>
<li class="listitem">
<span class="strong strong"><strong>Define a <code class="literal">text_similarity_reranker</code> retriever in your search request</strong></span>.
The retriever syntax makes it simple to configure both the retrieval and reranking of search results in a single API call.
</li>
</ol>
</div>
<details>
<summary class="title"><span class="strong strong"><strong>Example search request</strong></span> with semantic reranker</summary>
<div class="content">
<p>The following example shows a search request that uses a semantic reranker to reorder the top-k documents based on their semantic similarity to the query.</p>
<div class="pre_wrapper lang-python alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-python alternative">resp = client.search(
    retriever={
        "text_similarity_reranker": {
            "retriever": {
                "standard": {
                    "query": {
                        "match": {
                            "text": "How often does the moon hide the sun?"
                        }
                    }
                }
            },
            "field": "text",
            "inference_id": "my-cohere-rerank-model",
            "inference_text": "How often does the moon hide the sun?",
            "rank_window_size": 100,
            "min_score": 0.5
        }
    },
)
print(resp)</pre>
</div>
<div class="pre_wrapper lang-js alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-js alternative">const response = await client.search({
  retriever: {
    text_similarity_reranker: {
      retriever: {
        standard: {
          query: {
            match: {
              text: "How often does the moon hide the sun?",
            },
          },
        },
      },
      field: "text",
      inference_id: "my-cohere-rerank-model",
      inference_text: "How often does the moon hide the sun?",
      rank_window_size: 100,
      min_score: 0.5,
    },
  },
});
console.log(response);</pre>
</div>
<a id="c02c2916b97b6fa7db82dbc7f0378310"></a>
<div class="pre_wrapper lang-console default has-python has-js">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-console default has-python has-js">POST _search
{
  "retriever": {
    "text_similarity_reranker": {
      "retriever": {
        "standard": {
          "query": {
            "match": {
              "text": "How often does the moon hide the sun?"
            }
          }
        }
      },
      "field": "text",
      "inference_id": "my-cohere-rerank-model",
      "inference_text": "How often does the moon hide the sun?",
      "rank_window_size": 100,
      "min_score": 0.5
    }
  }
}</pre>
</div>
<div class="console_widget has-python has-js" data-snippet="snippets/1086.console"></div>
</div>
</details>
<div class="position-relative"><h4><a id="semantic-reranking-learn-more"></a>Learn more</h4><a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/main/docs/reference/search/search-your-data/retrievers-reranking/semantic-reranking.asciidoc">edit</a></div>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
Read the <a class="xref" href="retriever.html" title="Retriever">retriever reference documentation</a> for syntax and implementation details
</li>
<li class="listitem">
Learn more about the <a class="xref" href="retrievers-overview.html" title="Retrievers">retrievers</a> abstraction
</li>
<li class="listitem">
Learn more about the Elastic <a class="xref" href="inference-apis.html" title="Inference APIs">Inference APIs</a>
</li>
<li class="listitem">
Check out our <a href="https://github.com/elastic/elasticsearch-labs/blob/main/notebooks/integrations/cohere/cohere-elasticsearch.ipynb" class="ulink" target="_top">Python notebook</a> for using Cohere with Elasticsearch
</li>
</ul>
</div>
</div>
</div>
</div><div class="navfooter">
<span class="prev">
<a href="retrievers-overview.html">« Retrievers</a>
</span>
<span class="next">
<a href="learning-to-rank.html">Learning To Rank »</a>
</span>
</div>
</body>
</html>
