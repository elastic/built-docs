<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Painless examples for transforms | Elasticsearch Guide [master] | Elastic</title>
<meta class="elastic" name="content" content="Painless examples for transforms | Elasticsearch Guide [master]">

<link rel="home" href="index.html" title="Elasticsearch Guide [master]"/>
<link rel="up" href="transforms.html" title="Transforming data"/>
<link rel="prev" href="transform-examples.html" title="Transform examples"/>
<link rel="next" href="transform-limitations.html" title="Transform limitations"/>
<meta class="elastic" name="product_version" content="master"/>
<meta class="elastic" name="product_name" content="Elasticsearch"/>
<meta class="elastic" name="website_area" content="documentation"/>
<meta name="DC.type" content="Learn/Docs/Elasticsearch/Reference/master"/>
<meta name="DC.subject" content="Elasticsearch"/>
<meta name="DC.identifier" content="master"/>
<meta name="robots" content="noindex,nofollow"/>
</head>
<body>
<div class="page_header">
This documentation contains work-in-progress information for future Elastic Stack and Cloud releases. Use the version selector to view supported release docs. It also contains some Elastic Cloud serverless information. Check out our <a href="https://www.elastic.co/docs/current/serverless">serverless docs</a> for more details.
</div>
<div class="navheader">
<span class="prev">
<a href="transform-examples.html">« Transform examples</a>
</span>
<span class="next">
<a href="transform-limitations.html">Transform limitations »</a>
</span>
</div>
<div class="book" lang="en">
<div class="titlepage">
<div class="breadcrumbs">
<span class="breadcrumb-link"><a href="/guide/">Elastic Docs</a></span>
<span class="chevron-right">›</span><span class="breadcrumb-link"><a href="index.html">Elasticsearch Guide [master]</a></span>
<span class="chevron-right">›</span><span class="breadcrumb-link"><a href="data-rollup-transform.html">Roll up or transform your data</a></span>
<span class="chevron-right">›</span><span class="breadcrumb-link"><a href="transforms.html">Transforming data</a></span>
</div>
<div>
<div><h1 class="title"><a id="id-1"></a>Painless examples for transforms</h1><a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/main/docs/reference/transform/painless-examples.asciidoc">edit</a></div>
</div>
<!--EXTRA-->
</div>
<div id="content">
<div class="section xpack">
<div class="titlepage"><div><div>
<h2 class="title"><a id="transform-painless-examples"></a>Painless examples for transforms<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/main/docs/reference/transform/painless-examples.asciidoc">edit</a></h2>
</div></div></div>

<p>These examples demonstrate how to use Painless in transforms. You can learn
more about the Painless scripting language in the
<a href="/guide/en/elasticsearch/painless/master/painless-guide.html" class="ulink" target="_top">Painless guide</a>.</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
<a class="xref" href="transform-painless-examples.html#painless-top-hits" title="Getting top hits by using scripted metric aggregation">Getting top hits by using scripted metric aggregation</a>
</li>
<li class="listitem">
<a class="xref" href="transform-painless-examples.html#painless-time-features" title="Getting time features by using aggregations">Getting time features by using aggregations</a>
</li>
<li class="listitem">
<a class="xref" href="transform-painless-examples.html#painless-bucket-script" title="Getting duration by using bucket script">Getting duration by using bucket script</a>
</li>
<li class="listitem">
<a class="xref" href="transform-painless-examples.html#painless-count-http" title="Counting HTTP responses by using scripted metric aggregation">Counting HTTP responses by using scripted metric aggregation</a>
</li>
<li class="listitem">
<a class="xref" href="transform-painless-examples.html#painless-compare" title="Comparing indices by using scripted metric aggregations">Comparing indices by using scripted metric aggregations</a>
</li>
<li class="listitem">
<a class="xref" href="transform-painless-examples.html#painless-web-session" title="Getting web session details by using scripted metric aggregation">Getting web session details by using scripted metric aggregation</a>
</li>
</ul>
</div>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
While the context of the following examples is the transform use case,
the Painless scripts in the snippets below can be used in other Elasticsearch search
aggregations, too.
</li>
<li class="listitem">
All the following examples use scripts, transforms cannot deduce mappings of
output fields when the fields are created by a script. Transforms don&#8217;t
create any mappings in the destination index for these fields, which means they
get dynamically mapped. Create the destination index prior to starting the
transform in case you want explicit mappings.
</li>
</ul>
</div>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="painless-top-hits"></a>Getting top hits by using scripted metric aggregation<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/main/docs/reference/transform/painless-examples.asciidoc">edit</a></h3>
</div></div></div>
<p>This snippet shows how to find the latest document, in other words the document
with the latest timestamp. From a technical perspective, it helps to achieve
the function of a <a class="xref" href="search-aggregations-metrics-top-hits-aggregation.html" title="Top hits aggregation">Top hits</a> by using
scripted metric aggregation in a transform, which provides a metric output.</p>
<div class="pre_wrapper lang-js">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-js">"aggregations": {
  "latest_doc": {
    "scripted_metric": {
      "init_script": "state.timestamp_latest = 0L; state.last_doc = ''", <a id="CO615-1"></a><i class="conum" data-value="1"></i>
      "map_script": """ <a id="CO615-2"></a><i class="conum" data-value="2"></i>
        def current_date = doc['@timestamp'].getValue().toInstant().toEpochMilli();
        if (current_date &gt; state.timestamp_latest)
        {state.timestamp_latest = current_date;
        state.last_doc = new HashMap(params['_source']);}
      """,
      "combine_script": "return state", <a id="CO615-3"></a><i class="conum" data-value="3"></i>
      "reduce_script": """ <a id="CO615-4"></a><i class="conum" data-value="4"></i>
        def last_doc = '';
        def timestamp_latest = 0L;
        for (s in states) {if (s.timestamp_latest &gt; (timestamp_latest))
        {timestamp_latest = s.timestamp_latest; last_doc = s.last_doc;}}
        return last_doc
      """
    }
  }
}</pre>
</div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO615-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>The <code class="literal">init_script</code> creates a long type <code class="literal">timestamp_latest</code> and a string type
<code class="literal">last_doc</code> in the <code class="literal">state</code> object.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO615-2"><i class="conum" data-value="2"></i></a></p>
</td>
<td align="left" valign="top">
<p>The <code class="literal">map_script</code> defines <code class="literal">current_date</code> based on the timestamp of the
document, then compares <code class="literal">current_date</code> with <code class="literal">state.timestamp_latest</code>, finally
returns <code class="literal">state.last_doc</code> from the shard. By using <code class="literal">new HashMap(...)</code> you copy
the source document, this is important whenever you want to pass the full source
object from one phase to the next.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO615-3"><i class="conum" data-value="3"></i></a></p>
</td>
<td align="left" valign="top">
<p>The <code class="literal">combine_script</code> returns <code class="literal">state</code> from each shard.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO615-4"><i class="conum" data-value="4"></i></a></p>
</td>
<td align="left" valign="top">
<p>The <code class="literal">reduce_script</code> iterates through the value of <code class="literal">s.timestamp_latest</code>
returned by each shard and returns the document with the latest timestamp
(<code class="literal">last_doc</code>). In the response, the top hit (in other words, the <code class="literal">latest_doc</code>) is
nested below the <code class="literal">latest_doc</code> field.</p>
</td>
</tr>
</table>
</div>
<p>Check the <a class="xref" href="search-aggregations-metrics-scripted-metric-aggregation.html#scripted-metric-aggregation-scope" title="Scope of scripts">scope of scripts</a> for detailed
explanation on the respective scripts.</p>
<p>You can retrieve the last value in a similar way:</p>
<div class="pre_wrapper lang-js">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-js">"aggregations": {
  "latest_value": {
    "scripted_metric": {
      "init_script": "state.timestamp_latest = 0L; state.last_value = ''",
      "map_script": """
        def current_date = doc['@timestamp'].getValue().toInstant().toEpochMilli();
        if (current_date &gt; state.timestamp_latest)
        {state.timestamp_latest = current_date;
        state.last_value = params['_source']['value'];}
      """,
      "combine_script": "return state",
      "reduce_script": """
        def last_value = '';
        def timestamp_latest = 0L;
        for (s in states) {if (s.timestamp_latest &gt; (timestamp_latest))
        {timestamp_latest = s.timestamp_latest; last_value = s.last_value;}}
        return last_value
      """
    }
  }
}</pre>
</div>
<h5><a id="top-hits-stored-scripts"></a>Getting top hits by using stored scripts<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/main/docs/reference/transform/painless-examples.asciidoc">edit</a></h5>
<p>You can also use the power of
<a href="/guide/en/elasticsearch/reference/master/create-stored-script-api.html" class="ulink" target="_top">stored scripts</a> to get the latest value.
Stored scripts reduce compilation time,  make searches faster, and are
updatable.</p>
<div class="olist orderedlist">
<ol class="orderedlist">
<li class="listitem">
<p>Create the stored scripts:</p>
<div class="pre_wrapper lang-js">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-js">POST _scripts/last-value-map-init
{
  "script": {
    "lang": "painless",
    "source": """
        state.timestamp_latest = 0L; state.last_value = ''
    """
  }
}

POST _scripts/last-value-map
{
  "script": {
    "lang": "painless",
    "source": """
      def current_date = doc['@timestamp'].getValue().toInstant().toEpochMilli();
        if (current_date &gt; state.timestamp_latest)
        {state.timestamp_latest = current_date;
        state.last_value = doc[params['key']].value;}
    """
  }
}

POST _scripts/last-value-combine
{
  "script": {
    "lang": "painless",
    "source": """
        return state
    """
  }
}

POST _scripts/last-value-reduce
{
  "script": {
    "lang": "painless",
    "source": """
        def last_value = '';
        def timestamp_latest = 0L;
        for (s in states) {if (s.timestamp_latest &gt; (timestamp_latest))
        {timestamp_latest = s.timestamp_latest; last_value = s.last_value;}}
        return last_value
    """
  }
}</pre>
</div>
</li>
<li class="listitem">
<p>Use the stored scripts in a scripted metric aggregation.</p>
<div class="pre_wrapper lang-js">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-js">"aggregations":{
   "latest_value":{
      "scripted_metric":{
         "init_script":{
            "id":"last-value-map-init"
         },
         "map_script":{
            "id":"last-value-map",
            "params":{
               "key":"field_with_last_value" <a id="CO616-1"></a><i class="conum" data-value="1"></i>
            }
         },
         "combine_script":{
            "id":"last-value-combine"
         },
         "reduce_script":{
            "id":"last-value-reduce"
         }</pre>
</div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO616-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>The parameter <code class="literal">field_with_last_value</code> can be set any field that you want the
latest value for.</p>
</td>
</tr>
</table>
</div>
</li>
</ol>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="painless-time-features"></a>Getting time features by using aggregations<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/main/docs/reference/transform/painless-examples.asciidoc">edit</a></h3>
</div></div></div>
<p>This snippet shows how to extract time based features by using Painless in a
transform. The snippet uses an index where <code class="literal">@timestamp</code> is defined as a <code class="literal">date</code>
type field.</p>
<div class="pre_wrapper lang-js">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-js">"aggregations": {
  "avg_hour_of_day": { <a id="CO617-1"></a><i class="conum" data-value="1"></i>
    "avg":{
      "script": { <a id="CO617-2"></a><i class="conum" data-value="2"></i>
        "source": """
          ZonedDateTime date =  doc['@timestamp'].value; <a id="CO617-3"></a><i class="conum" data-value="3"></i>
          return date.getHour(); <a id="CO617-4"></a><i class="conum" data-value="4"></i>
        """
      }
    }
  },
  "avg_month_of_year": { <a id="CO617-5"></a><i class="conum" data-value="5"></i>
    "avg":{
      "script": { <a id="CO617-6"></a><i class="conum" data-value="6"></i>
        "source": """
          ZonedDateTime date =  doc['@timestamp'].value; <a id="CO617-7"></a><i class="conum" data-value="7"></i>
          return date.getMonthValue(); <a id="CO617-8"></a><i class="conum" data-value="8"></i>
        """
      }
    }
  },
 ...
}</pre>
</div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO617-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>Name of the aggregation.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO617-2"><i class="conum" data-value="2"></i></a></p>
</td>
<td align="left" valign="top">
<p>Contains the Painless script that returns the hour of the day.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO617-3"><i class="conum" data-value="3"></i></a></p>
</td>
<td align="left" valign="top">
<p>Sets <code class="literal">date</code> based on the timestamp of the document.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO617-4"><i class="conum" data-value="4"></i></a></p>
</td>
<td align="left" valign="top">
<p>Returns the hour value from <code class="literal">date</code>.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO617-5"><i class="conum" data-value="5"></i></a></p>
</td>
<td align="left" valign="top">
<p>Name of the aggregation.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO617-6"><i class="conum" data-value="6"></i></a></p>
</td>
<td align="left" valign="top">
<p>Contains the Painless script that returns the month of the year.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO617-7"><i class="conum" data-value="7"></i></a></p>
</td>
<td align="left" valign="top">
<p>Sets <code class="literal">date</code> based on the timestamp of the document.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO617-8"><i class="conum" data-value="8"></i></a></p>
</td>
<td align="left" valign="top">
<p>Returns the month value from <code class="literal">date</code>.</p>
</td>
</tr>
</table>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="painless-bucket-script"></a>Getting duration by using bucket script<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/main/docs/reference/transform/painless-examples.asciidoc">edit</a></h3>
</div></div></div>
<p>This example shows you how to get the duration of a session by client IP from a
data log by using
<a class="xref" href="search-aggregations-pipeline-bucket-script-aggregation.html" title="Bucket script aggregation">bucket script</a>.
The example uses the Kibana sample web logs dataset.</p>
<div class="pre_wrapper lang-js alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-js alternative">const response = await client.transform.putTransform({
  transform_id: "data_log",
  source: {
    index: "kibana_sample_data_logs",
  },
  dest: {
    index: "data-logs-by-client",
  },
  pivot: {
    group_by: {
      "machine.os": {
        terms: {
          field: "machine.os.keyword",
        },
      },
      "machine.ip": {
        terms: {
          field: "clientip",
        },
      },
    },
    aggregations: {
      "time_frame.lte": {
        max: {
          field: "timestamp",
        },
      },
      "time_frame.gte": {
        min: {
          field: "timestamp",
        },
      },
      time_length: {
        bucket_script: {
          buckets_path: {
            min: "time_frame.gte.value",
            max: "time_frame.lte.value",
          },
          script: "params.max - params.min",
        },
      },
    },
  },
});
console.log(response);</pre>
</div>
<a id="e4b64b8277af259a52c8d3940157b5fa"></a>
<div class="pre_wrapper lang-console default has-js">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-console default has-js">PUT _transform/data_log
{
  "source": {
    "index": "kibana_sample_data_logs"
  },
  "dest": {
    "index": "data-logs-by-client"
  },
  "pivot": {
    "group_by": {
      "machine.os": {"terms": {"field": "machine.os.keyword"}},
      "machine.ip": {"terms": {"field": "clientip"}}
    },
    "aggregations": {
      "time_frame.lte": {
        "max": {
          "field": "timestamp"
        }
      },
      "time_frame.gte": {
        "min": {
          "field": "timestamp"
        }
      },
      "time_length": { <a id="CO618-1"></a><i class="conum" data-value="1"></i>
        "bucket_script": {
          "buckets_path": { <a id="CO618-2"></a><i class="conum" data-value="2"></i>
            "min": "time_frame.gte.value",
            "max": "time_frame.lte.value"
          },
          "script": "params.max - params.min" <a id="CO618-3"></a><i class="conum" data-value="3"></i>
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget has-js" data-snippet="snippets/1907.console"></div>
<div class="calloutlist default has-js lang-console">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO618-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>To define the length of the sessions, we use a bucket script.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO618-2"><i class="conum" data-value="2"></i></a></p>
</td>
<td align="left" valign="top">
<p>The bucket path is a map of script variables and their associated path to
the buckets you want to use for the variable. In this particular case, <code class="literal">min</code> and
<code class="literal">max</code> are variables mapped to <code class="literal">time_frame.gte.value</code> and <code class="literal">time_frame.lte.value</code>.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO618-3"><i class="conum" data-value="3"></i></a></p>
</td>
<td align="left" valign="top">
<p>Finally, the script substracts the start date of the session from the end
date which results in the duration of the session.</p>
</td>
</tr>
</table>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="painless-count-http"></a>Counting HTTP responses by using scripted metric aggregation<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/main/docs/reference/transform/painless-examples.asciidoc">edit</a></h3>
</div></div></div>
<p>You can count the different HTTP response types in a web log data set by using
scripted metric aggregation as part of the transform. You can achieve a
similar function with filter aggregations, check the
<a href="/guide/en/elasticsearch/reference/master/transform-examples.html#example-clientips" class="ulink" target="_top">Finding suspicious client IPs</a>
example for details.</p>
<p>The example below assumes that the HTTP response codes are stored as keywords in
the <code class="literal">response</code> field of the documents.</p>
<div class="pre_wrapper lang-js">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-js">"aggregations": { <a id="CO619-1"></a><i class="conum" data-value="1"></i>
  "responses.counts": { <a id="CO619-2"></a><i class="conum" data-value="2"></i>
    "scripted_metric": { <a id="CO619-3"></a><i class="conum" data-value="3"></i>
      "init_script": "state.responses = ['error':0L,'success':0L,'other':0L]", <a id="CO619-4"></a><i class="conum" data-value="4"></i>
      "map_script": """ <a id="CO619-5"></a><i class="conum" data-value="5"></i>
        def code = doc['response.keyword'].value;
        if (code.startsWith('5') || code.startsWith('4')) {
          state.responses.error += 1 ;
        } else if(code.startsWith('2')) {
          state.responses.success += 1;
        } else {
          state.responses.other += 1;
        }
        """,
      "combine_script": "state.responses", <a id="CO619-6"></a><i class="conum" data-value="6"></i>
      "reduce_script": """ <a id="CO619-7"></a><i class="conum" data-value="7"></i>
        def counts = ['error': 0L, 'success': 0L, 'other': 0L];
        for (responses in states) {
          counts.error += responses['error'];
          counts.success += responses['success'];
          counts.other += responses['other'];
        }
        return counts;
        """
      }
    },
  ...
}</pre>
</div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO619-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>The <code class="literal">aggregations</code> object of the transform that contains all aggregations.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO619-2"><i class="conum" data-value="2"></i></a></p>
</td>
<td align="left" valign="top">
<p>Object of the <code class="literal">scripted_metric</code> aggregation.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO619-3"><i class="conum" data-value="3"></i></a></p>
</td>
<td align="left" valign="top">
<p>This <code class="literal">scripted_metric</code> performs a distributed operation on the web log data
to count specific types of HTTP responses (error, success, and other).</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO619-4"><i class="conum" data-value="4"></i></a></p>
</td>
<td align="left" valign="top">
<p>The <code class="literal">init_script</code> creates a <code class="literal">responses</code> array in the <code class="literal">state</code> object with
three properties (<code class="literal">error</code>, <code class="literal">success</code>, <code class="literal">other</code>) with long data type.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO619-5"><i class="conum" data-value="5"></i></a></p>
</td>
<td align="left" valign="top">
<p>The <code class="literal">map_script</code> defines <code class="literal">code</code> based on the <code class="literal">response.keyword</code> value of the
document, then it counts the errors, successes, and other responses based on the
first digit of the responses.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO619-6"><i class="conum" data-value="6"></i></a></p>
</td>
<td align="left" valign="top">
<p>The <code class="literal">combine_script</code> returns <code class="literal">state.responses</code> from each shard.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO619-7"><i class="conum" data-value="7"></i></a></p>
</td>
<td align="left" valign="top">
<p>The <code class="literal">reduce_script</code> creates a <code class="literal">counts</code> array with the <code class="literal">error</code>, <code class="literal">success</code>,
and <code class="literal">other</code> properties, then iterates through the value of <code class="literal">responses</code> returned
by each shard and assigns the different response types to the appropriate
properties of the <code class="literal">counts</code> object; error responses to the error counts, success
responses to the success counts, and other responses to the other counts.
Finally, returns the <code class="literal">counts</code> array with the response counts.</p>
</td>
</tr>
</table>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="painless-compare"></a>Comparing indices by using scripted metric aggregations<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/main/docs/reference/transform/painless-examples.asciidoc">edit</a></h3>
</div></div></div>
<p>This example shows how to compare the content of two indices by a transform
that uses a scripted metric aggregation.</p>
<div class="pre_wrapper lang-js alternative">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-js alternative">const response = await client.transform.previewTransform({
  id: "index_compare",
  source: {
    index: ["index1", "index2"],
    query: {
      match_all: {},
    },
  },
  dest: {
    index: "compare",
  },
  pivot: {
    group_by: {
      "unique-id": {
        terms: {
          field: "&lt;unique-id-field&gt;",
        },
      },
    },
    aggregations: {
      compare: {
        scripted_metric: {
          map_script: "state.doc = new HashMap(params['_source'])",
          combine_script: "return state",
          reduce_script:
            ' \n            if (states.size() != 2) {\n              return "count_mismatch"\n            }\n            if (states.get(0).equals(states.get(1))) {\n              return "match"\n            } else {\n              return "mismatch"\n            }\n            ',
        },
      },
    },
  },
});
console.log(response);</pre>
</div>
<a id="2a5f7e7d6b92c66e52616845146d2820"></a>
<div class="pre_wrapper lang-console default has-js">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-console default has-js">POST _transform/_preview
{
  "id" : "index_compare",
  "source" : { <a id="CO620-1"></a><i class="conum" data-value="1"></i>
    "index" : [
      "index1",
      "index2"
    ],
    "query" : {
      "match_all" : { }
    }
  },
  "dest" : { <a id="CO620-2"></a><i class="conum" data-value="2"></i>
    "index" : "compare"
  },
  "pivot" : {
    "group_by" : {
      "unique-id" : {
        "terms" : {
          "field" : "&lt;unique-id-field&gt;" <a id="CO620-3"></a><i class="conum" data-value="3"></i>
        }
      }
    },
    "aggregations" : {
      "compare" : { <a id="CO620-4"></a><i class="conum" data-value="4"></i>
        "scripted_metric" : {
          "map_script" : "state.doc = new HashMap(params['_source'])", <a id="CO620-5"></a><i class="conum" data-value="5"></i>
          "combine_script" : "return state", <a id="CO620-6"></a><i class="conum" data-value="6"></i>
          "reduce_script" : """ <a id="CO620-7"></a><i class="conum" data-value="7"></i>
            if (states.size() != 2) {
              return "count_mismatch"
            }
            if (states.get(0).equals(states.get(1))) {
              return "match"
            } else {
              return "mismatch"
            }
            """
        }
      }
    }
  }
}</pre>
</div>
<div class="console_widget has-js" data-snippet="snippets/1908.console"></div>
<div class="calloutlist default has-js lang-console">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO620-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>The indices referenced in the <code class="literal">source</code> object are compared to each other.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO620-2"><i class="conum" data-value="2"></i></a></p>
</td>
<td align="left" valign="top">
<p>The <code class="literal">dest</code> index contains the results of the comparison.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO620-3"><i class="conum" data-value="3"></i></a></p>
</td>
<td align="left" valign="top">
<p>The <code class="literal">group_by</code> field needs to be a unique identifier for each document.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO620-4"><i class="conum" data-value="4"></i></a></p>
</td>
<td align="left" valign="top">
<p>Object of the <code class="literal">scripted_metric</code> aggregation.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO620-5"><i class="conum" data-value="5"></i></a></p>
</td>
<td align="left" valign="top">
<p>The <code class="literal">map_script</code> defines <code class="literal">doc</code> in the state object. By using
<code class="literal">new HashMap(...)</code> you copy the source document, this is important whenever you
want to pass the full source object from one phase to the next.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO620-6"><i class="conum" data-value="6"></i></a></p>
</td>
<td align="left" valign="top">
<p>The <code class="literal">combine_script</code> returns <code class="literal">state</code> from each shard.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO620-7"><i class="conum" data-value="7"></i></a></p>
</td>
<td align="left" valign="top">
<p>The <code class="literal">reduce_script</code> checks if the size of the indices are equal. If they are
not equal, than it reports back a <code class="literal">count_mismatch</code>. Then it iterates through all
the values of the two indices and compare them. If the values are equal, then it
returns a <code class="literal">match</code>, otherwise returns a <code class="literal">mismatch</code>.</p>
</td>
</tr>
</table>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="painless-web-session"></a>Getting web session details by using scripted metric aggregation<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/elasticsearch/edit/main/docs/reference/transform/painless-examples.asciidoc">edit</a></h3>
</div></div></div>
<p>This example shows how to derive multiple features from a single transaction.
Let&#8217;s take a look on the example source document from the data:</p>
<details open>
<summary class="title">Source document</summary>
<div class="content">
<div class="pre_wrapper lang-js">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-js">{
  "_index":"apache-sessions",
  "_type":"_doc",
  "_id":"KvzSeGoB4bgw0KGbE3wP",
  "_score":1.0,
  "_source":{
    "@timestamp":1484053499256,
    "apache":{
      "access":{
        "sessionid":"571604f2b2b0c7b346dc685eeb0e2306774a63c2",
        "url":"http://www.leroymerlin.fr/v3/search/search.do?keyword=Carrelage%20salle%20de%20bain",
        "path":"/v3/search/search.do",
        "query":"keyword=Carrelage%20salle%20de%20bain",
        "referrer":"http://www.leroymerlin.fr/v3/p/produits/carrelage-parquet-sol-souple/carrelage-sol-et-mur/decor-listel-et-accessoires-carrelage-mural-l1308217717?resultOffset=0&amp;resultLimit=51&amp;resultListShape=MOSAIC&amp;priceStyle=SALEUNIT_PRICE",
        "user_agent":{
          "original":"Mobile Safari 10.0 Mac OS X (iPad) Apple Inc.",
          "os_name":"Mac OS X (iPad)"
        },
        "remote_ip":"0337b1fa-5ed4-af81-9ef4-0ec53be0f45d",
        "geoip":{
          "country_iso_code":"FR",
          "location":{
            "lat":48.86,
            "lon":2.35
          }
        },
        "response_code":200,
        "method":"GET"
      }
    }
  }
}
...</pre>
</div>
</div>
</details>
<p>By using the <code class="literal">sessionid</code> as a group-by field, you are able to enumerate events
through the session and get more details of the session by using scripted metric
aggregation.</p>
<div class="pre_wrapper lang-js">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-js">POST _transform/_preview
{
  "source": {
    "index": "apache-sessions"
  },
  "pivot": {
    "group_by": {
      "sessionid": { <a id="CO621-1"></a><i class="conum" data-value="1"></i>
        "terms": {
          "field": "apache.access.sessionid"
        }
      }
    },
    "aggregations": { <a id="CO621-2"></a><i class="conum" data-value="2"></i>
      "distinct_paths": {
        "cardinality": {
          "field": "apache.access.path"
        }
      },
      "num_pages_viewed": {
        "value_count": {
          "field": "apache.access.url"
        }
      },
      "session_details": {
        "scripted_metric": {
          "init_script": "state.docs = []", <a id="CO621-3"></a><i class="conum" data-value="3"></i>
          "map_script": """ <a id="CO621-4"></a><i class="conum" data-value="4"></i>
            Map span = [
              '@timestamp':doc['@timestamp'].value,
              'url':doc['apache.access.url'].value,
              'referrer':doc['apache.access.referrer'].value
            ];
            state.docs.add(span)
          """,
          "combine_script": "return state.docs;", <a id="CO621-5"></a><i class="conum" data-value="5"></i>
          "reduce_script": """ <a id="CO621-6"></a><i class="conum" data-value="6"></i>
            def all_docs = [];
            for (s in states) {
              for (span in s) {
                all_docs.add(span);
              }
            }
            all_docs.sort((HashMap o1, HashMap o2)-&gt;o1['@timestamp'].toEpochMilli().compareTo(o2['@timestamp'].toEpochMilli()));
            def size = all_docs.size();
            def min_time = all_docs[0]['@timestamp'];
            def max_time = all_docs[size-1]['@timestamp'];
            def duration = max_time.toEpochMilli() - min_time.toEpochMilli();
            def entry_page = all_docs[0]['url'];
            def exit_path = all_docs[size-1]['url'];
            def first_referrer = all_docs[0]['referrer'];
            def ret = new HashMap();
            ret['first_time'] = min_time;
            ret['last_time'] = max_time;
            ret['duration'] = duration;
            ret['entry_page'] = entry_page;
            ret['exit_path'] = exit_path;
            ret['first_referrer'] = first_referrer;
            return ret;
          """
        }
      }
    }
  }
}</pre>
</div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO621-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>The data is grouped by <code class="literal">sessionid</code>.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO621-2"><i class="conum" data-value="2"></i></a></p>
</td>
<td align="left" valign="top">
<p>The aggregations counts the number of paths and enumerate the viewed pages
during the session.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO621-3"><i class="conum" data-value="3"></i></a></p>
</td>
<td align="left" valign="top">
<p>The <code class="literal">init_script</code> creates an array type <code class="literal">doc</code> in the <code class="literal">state</code> object.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO621-4"><i class="conum" data-value="4"></i></a></p>
</td>
<td align="left" valign="top">
<p>The <code class="literal">map_script</code> defines a <code class="literal">span</code> array with a timestamp, a URL, and a
referrer value which are based on the corresponding values of the document, then
adds the value of the <code class="literal">span</code> array to the <code class="literal">doc</code> object.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO621-5"><i class="conum" data-value="5"></i></a></p>
</td>
<td align="left" valign="top">
<p>The <code class="literal">combine_script</code> returns <code class="literal">state.docs</code> from each shard.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO621-6"><i class="conum" data-value="6"></i></a></p>
</td>
<td align="left" valign="top">
<p>The <code class="literal">reduce_script</code> defines various objects like <code class="literal">min_time</code>, <code class="literal">max_time</code>, and
<code class="literal">duration</code> based on the document fields, then declares a <code class="literal">ret</code> object, and
copies the source document by using <code class="literal">new HashMap ()</code>. Next, the script defines
<code class="literal">first_time</code>, <code class="literal">last_time</code>, <code class="literal">duration</code> and other fields inside the <code class="literal">ret</code> object
based on the corresponding object defined earlier, finally returns <code class="literal">ret</code>.</p>
</td>
</tr>
</table>
</div>
<p>The API call results in a similar response:</p>
<div class="pre_wrapper lang-js">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-js">{
  "num_pages_viewed" : 2.0,
  "session_details" : {
    "duration" : 100300001,
    "first_referrer" : "https://www.bing.com/",
    "entry_page" : "http://www.leroymerlin.fr/v3/p/produits/materiaux-menuiserie/porte-coulissante-porte-interieure-escalier-et-rambarde/barriere-de-securite-l1308218463",
    "first_time" : "2017-01-10T21:22:52.982Z",
    "last_time" : "2017-01-10T21:25:04.356Z",
    "exit_path" : "http://www.leroymerlin.fr/v3/p/produits/materiaux-menuiserie/porte-coulissante-porte-interieure-escalier-et-rambarde/barriere-de-securite-l1308218463?__result-wrapper?pageTemplate=Famille%2FMat%C3%A9riaux+et+menuiserie&amp;resultOffset=0&amp;resultLimit=50&amp;resultListShape=PLAIN&amp;nomenclatureId=17942&amp;priceStyle=SALEUNIT_PRICE&amp;fcr=1&amp;*4294718806=4294718806&amp;*14072=14072&amp;*4294718593=4294718593&amp;*17942=17942"
  },
  "distinct_paths" : 1.0,
  "sessionid" : "000046f8154a80fd89849369c984b8cc9d795814"
},
{
  "num_pages_viewed" : 10.0,
  "session_details" : {
    "duration" : 343100405,
    "first_referrer" : "https://www.google.fr/",
    "entry_page" : "http://www.leroymerlin.fr/",
    "first_time" : "2017-01-10T16:57:39.937Z",
    "last_time" : "2017-01-10T17:03:23.049Z",
    "exit_path" : "http://www.leroymerlin.fr/v3/p/produits/porte-de-douche-coulissante-adena-e168578"
  },
  "distinct_paths" : 8.0,
  "sessionid" : "000087e825da1d87a332b8f15fa76116c7467da6"
}
...</pre>
</div>
</div>

</div>
</div>
</div><div class="navfooter">
<span class="prev">
<a href="transform-examples.html">« Transform examples</a>
</span>
<span class="next">
<a href="transform-limitations.html">Transform limitations »</a>
</span>
</div>
</body>
</html>
