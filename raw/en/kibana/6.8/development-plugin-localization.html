<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Localization for plugins | Kibana Guide [6.8] | Elastic</title>
<meta class="elastic" name="content" content="Localization for plugins | Kibana Guide [6.8]">

<link rel="home" href="index.html" title="Kibana Guide [6.8]"/>
<link rel="up" href="plugin-development.html" title="Plugin Development"/>
<link rel="prev" href="development-plugin-functional-tests.html" title="Functional Tests for Plugins"/>
<link rel="next" href="add-data-guide.html" title="Add Data Guide"/>
<meta class="elastic" name="product_version" content="6.8"/>
<meta class="elastic" name="product_name" content="Kibana"/>
<meta class="elastic" name="website_area" content="documentation"/>
<meta name="DC.type" content="Learn/Docs/Kibana/Reference/6.8"/>
<meta name="DC.subject" content="Kibana"/>
<meta name="DC.identifier" content="6.8"/>
<meta name="robots" content="noindex,nofollow"/>
</head>
<body>
<div class="page_header">
<p>
  <strong>NOTE</strong>: You are looking at documentation for an older release. 
  For the latest information, see the 
  <a href="../current/index.html">current release documentation</a>. 
</p>
</div>
<div class="navheader">
<span class="prev">
<a href="development-plugin-functional-tests.html">« Functional Tests for Plugins</a>
</span>
<span class="next">
<a href="add-data-guide.html">Add Data Guide »</a>
</span>
</div>
<div class="book" lang="en">
<div class="titlepage">
<div class="breadcrumbs">
<span class="breadcrumb-link"><a href="/guide/">Elastic Docs</a></span>
<span class="chevron-right">›</span><span class="breadcrumb-link"><a href="index.html">Kibana Guide [6.8]</a></span>
<span class="chevron-right">›</span><span class="breadcrumb-link"><a href="development.html">Developer guide</a></span>
<span class="chevron-right">›</span><span class="breadcrumb-link"><a href="plugin-development.html">Plugin Development</a></span>
</div>
<div>
<div><h1 class="title"><a id="id-1"></a>Localization for plugins</h1><a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/kibana/edit/6.8/docs/developer/plugin/development-plugin-localization.asciidoc">edit</a></div>
</div>
<!--EXTRA-->
</div>
<div id="content">
<div class="section">
<div class="titlepage"><div><div>
<h2 class="title"><a id="development-plugin-localization"></a>Localization for plugins<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/kibana/edit/6.8/docs/developer/plugin/development-plugin-localization.asciidoc">edit</a></h2>
</div></div></div>
<p>To introduce localization for your plugin, use our i18n tool to create IDs and default messages. You can then extract these IDs with respective default messages into localization JSON files for Kibana to use when running your plugin.</p>
<h4><a id="_adding_localization_to_your_plugin"></a>Adding localization to your plugin<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/kibana/edit/6.8/docs/developer/plugin/development-plugin-localization.asciidoc">edit</a></h4>
<p>You must add a <code class="literal">translations</code> directory at the root of your plugin. This directory will contain the translation files that Kibana uses.</p>
<div class="pre_wrapper lang-shell">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-shell">.
├── translations
│   ├── en.json
│   └── zh-CN.json
└── .i18nrc.json</pre>
</div>
<h4><a id="_using_kibana_i18n_tooling"></a>Using Kibana i18n tooling<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/kibana/edit/6.8/docs/developer/plugin/development-plugin-localization.asciidoc">edit</a></h4>
<p>To simplify the localization process, Kibana provides tools for the following functions:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
Verify all translations have translatable strings and extract default messages from templates
</li>
<li class="listitem">
Verify translation files and integrate them into Kibana
</li>
</ul>
</div>
<p>To use Kibana i18n tooling, create a <code class="literal">.i18nrc.json</code> file with the following configs:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
<code class="literal">paths</code>.  The directory from which the i18n translation IDs are extracted.
</li>
<li class="listitem">
<code class="literal">exclude</code>. The list of files to exclude while parsing paths.
</li>
<li class="listitem">
<code class="literal">translations</code>. The list of translations where JSON localizations are found.
</li>
</ul>
</div>
<div class="pre_wrapper lang-json">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-json">{
  "paths": {
    "myPlugin": "src/ui",
  },
  "exclude": [
  ],
  "translations": [
    "translations/zh-CN.json"
  ]
}</pre>
</div>
<p>An example Kibana <code class="literal">.i18nrc.json</code> is {kib-repo}blob/6.8/.i18nrc.json[here].</p>
<p>Full documentation about i18n tooling is {kib-repo}blob/6.8/src/dev/i18n/README.md[here].</p>
<h4><a id="_extracting_default_messages"></a>Extracting default messages<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/kibana/edit/6.8/docs/developer/plugin/development-plugin-localization.asciidoc">edit</a></h4>
<p>To extract the default messages from your plugin, run the following command:</p>
<div class="pre_wrapper lang-shell">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-shell">node scripts/i18n_extract --output-dir ./translations --include-config ../kibana-extra/myPlugin/.i18nrc.json</pre>
</div>
<p>This outputs a <code class="literal">en.json</code> file inside the <code class="literal">translations</code> directory. To localize other languages, clone the file and translate each string.</p>
<h4><a id="_checking_i18n_messages"></a>Checking i18n messages<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/kibana/edit/6.8/docs/developer/plugin/development-plugin-localization.asciidoc">edit</a></h4>
<p>Checking i18n does the following:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
Checks all existing labels for violations.
</li>
<li class="listitem">
<p>Takes translations from <code class="literal">.i18nrc.json</code> and compares them to the messages extracted and validated at the step above and:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
Checks for unused translations. If you remove a label that has a corresponding translation, you must also remove the label from the translations file.
</li>
<li class="listitem">
Checks for incompatible translations.  If you add or remove a new parameter from an existing string, you must also remove the label from the translations file.
</li>
</ul>
</div>
</li>
</ul>
</div>
<p>To check your i18n translations, run the following command:</p>
<div class="pre_wrapper lang-shell">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-shell">node scripts/i18n_check --fix --include-config ../kibana-extra/myPlugin/.i18nrc.json</pre>
</div>
<h4><a id="_implementing_i18n_in_the_ui"></a>Implementing i18n in the UI<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/kibana/edit/6.8/docs/developer/plugin/development-plugin-localization.asciidoc">edit</a></h4>
<p>Kibana relies on several UI frameworks (ReactJS and AngularJS) and
requires localization in different environments (browser and NodeJS).
The internationalization engine is framework agnostic and consumable in
all parts of Kibana (ReactJS, AngularJS and NodeJS).</p>
<p>To simplify
internationalization in UI frameworks, additional abstractions are
built around the I18n engine: <code class="literal">react-intl</code> for React and custom
components for AngularJS. <a href="https://github.com/yahoo/react-intl" class="ulink" target="_top">React-intl</a>
is built around <a href="https://github.com/yahoo/intl-messageformat" class="ulink" target="_top">intl-messageformat</a>,
so both React and AngularJS frameworks use the same engine and the same
message syntax.</p>
<h5><a id="_i18n_for_vanilla_javascript"></a>i18n for vanilla JavaScript<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/kibana/edit/6.8/docs/developer/plugin/development-plugin-localization.asciidoc">edit</a></h5>
<div class="pre_wrapper lang-js">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-js">import { i18n } from '@kbn/i18n';

export const HELLO_WORLD = i18n.translate('hello.wonderful.world', {
  defaultMessage: 'Greetings, planet Earth!',
});</pre>
</div>
<p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
Full details are {repo}tree/6.7/packages/kbn-i18n#vanilla-js[here].</p>
<div class="exampleblock">
<div class="content">
<p>Full details are <a href="https://github.com/elastic/kibana/tree/master/packages/kbn-i18n#vanilla-js" class="ulink" target="_top">here</a>.
&gt;&gt;&gt;&gt;&gt;&gt;&gt; d26cbef389&#8230;&#8203; [DOCS] Adds kibana-pull attribute for release docs (#69554)</p>
<h5><a id="_i18n_for_react"></a>i18n for React<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/kibana/edit/6.8/docs/developer/plugin/development-plugin-localization.asciidoc">edit</a></h5>
<p>To localize strings in React, use either <code class="literal">FormattedMessage</code> or <code class="literal">i18n.translate</code>.</p>
<div class="pre_wrapper lang-js">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-js">import { i18n } from '@kbn/i18n';
import { FormattedMessage } from '@kbn/i18n/react';

export const Component = () =&gt; {
  return (
    &lt;div&gt;
      {i18n.translate('xpack.someText', { defaultMessage: 'Some text' })}
      &lt;FormattedMessage id="xpack.someOtherText" defaultMessage="Some other text"&gt;
      &lt;/FormattedMessage&gt;
    &lt;/div&gt;
  );
};</pre>
</div>
<p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
Full details are {repo}tree/6.7/packages/kbn-i18n#react[here].</p>
</div>
</div>
<p>Full details are <a href="https://github.com/elastic/kibana/tree/master/packages/kbn-i18n#react" class="ulink" target="_top">here</a>.
&gt;&gt;&gt;&gt;&gt;&gt;&gt; d26cbef389&#8230;&#8203; [DOCS] Adds kibana-pull attribute for release docs (#69554)</p>
<h5><a id="_i18n_for_angular"></a>i18n for Angular<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/kibana/edit/6.8/docs/developer/plugin/development-plugin-localization.asciidoc">edit</a></h5>
<p>AngularJS wrapper has 4 entities: translation <code class="literal">provider</code>, <code class="literal">service</code>, <code class="literal">directive</code> and <code class="literal">filter</code>. Both the directive and the filter use the translation <code class="literal">service</code> with i18n engine under the hood.</p>
<p>The translation directive has the following syntax:</p>
<div class="pre_wrapper lang-js">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-js">&lt;ANY
  i18n-id="{string}"
  i18n-default-message="{string}"
  [i18n-values="{object}"]
  [i18n-description="{string}"]
&gt;&lt;/ANY&gt;</pre>
</div>
<p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
Full details are {repo}tree/6.7/packages/kbn-i18n#angularjs[here].</p>
<div class="exampleblock">
<div class="content">
<p>Full details are <a href="https://github.com/elastic/kibana/tree/master/packages/kbn-i18n#angularjs" class="ulink" target="_top">here</a>.
&gt;&gt;&gt;&gt;&gt;&gt;&gt; d26cbef389&#8230;&#8203; [DOCS] Adds kibana-pull attribute for release docs (#69554)</p>
<h4><a id="_resources"></a>Resources<a class="edit_me edit_me_private" rel="nofollow" title="Editing on GitHub is available to Elastic" href="https://github.com/elastic/kibana/edit/6.8/docs/developer/plugin/development-plugin-localization.asciidoc">edit</a></h4>
<p>To learn more about i18n tooling, see {kib-repo}blob/6.8/src/dev/i18n/README.md[i18n dev tooling].</p>
<p>To learn more about implementing i18n in the UI, follow the links below:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
{kib-repo}blob/6.8/packages/kbn-i18n/README.md[i18n plugin]
</li>
<li class="listitem">
{kib-repo}blob/6.8/packages/kbn-i18n/GUIDELINE.md[i18n guidelines]
</li>
</ul>
</div>
<p><a id="development-visualize-index"></a>== Developing Visualizations</p>
<p>Kibana Visualizations are the easiest way to add additional functionality to Kibana.
This part of documentation is split into two parts.
The first part tells you all you need to know on how to embed existing Kibana Visualizations in your plugin.
The second step explains how to create your own custom visualization.</p>
<div class="important admon">
<div class="icon"></div>
<div class="admon_content">
<p>These pages document internal APIs and are not guaranteed to be supported across future versions of Kibana.
However, these docs will be kept up-to-date to reflect the current implementation of Visualization plugins in Kibana.</p>
</div>
</div>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
<a class="xref" href="development-plugin-localization.html#development-embedding-visualizations">Localization for plugins</a>
</li>
<li class="listitem">
<a class="xref" href="development-plugin-localization.html#development-create-visualization">Localization for plugins</a>
</li>
</ul>
</div>
<p><a id="development-embedding-visualizations"></a>=== Embedding Visualizations</p>
<p>To embed visualization use the <code class="literal">VisualizeLoader</code>.</p>
<p>==== VisualizeLoader</p>
<p>The <code class="literal">VisualizeLoader</code> class is the easiest way to embed a visualization into your plugin.
It will take care of loading the data and rendering the visualization.</p>
<p>To get an instance of the loader, do the following:</p>
<div class="pre_wrapper lang-js">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-js">import { getVisualizeLoader } from 'ui/visualize/loader';

getVisualizeLoader().then((loader) =&gt; {
  // You now have access to the loader
});</pre>
</div>
<p>The loader exposes the following methods:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
<code class="literal">getVisualizationList()</code>: which returns promise which gets resolved with a list of saved visualizations
</li>
<li class="listitem">
<code class="literal">embedVisualizationWithId(container, savedId, params)</code>: which embeds visualization by id
</li>
<li class="listitem">
<code class="literal">embedVisualizationWithSavedObject(container, savedObject, params)</code>: which embeds visualization from saved object
</li>
</ul>
</div>
<p>Depending on which embed method you are using, you either pass in the id of the
saved object for the visualization, or a <code class="literal">savedObject</code>, that you can retrieve via
the <code class="literal">savedVisualizations</code> Angular service by its id. The <code class="literal">savedObject</code> give you access
to the filter and query logic and allows you to attach listeners to the visualizations.
For a more complex use-case you usually want to use that method.</p>
<p><code class="literal">container</code> should be a DOM element (jQuery wrapped or regular DOM element) into which the visualization should be embedded
<code class="literal">params</code> is a parameter object specifying several parameters, that influence rendering.</p>
<p>You will find a detailed description of all the parameters in the inline docs
in the {repo}blob/6.8/src/ui/public/visualize/loader/types.ts[loader source code].</p>
<p>Both methods return an <code class="literal">EmbeddedVisualizeHandler</code>, that gives you some access
to the visualization. The <code class="literal">embedVisualizationWithSavedObject</code> method will return
the handler immediately from the method call, whereas the <code class="literal">embedVisualizationWithId</code>
will return a promise, that resolves with the handler, as soon as the <code class="literal">id</code> could be
found. It will reject, if the <code class="literal">id</code> is invalid.</p>
<p>The returned <code class="literal">EmbeddedVisualizeHandler</code> itself has the following methods and properties:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
<code class="literal">destroy()</code>: destroys the embedded visualization. You MUST call that method when navigating away
or destroying the DOM node you have embedded into.
</li>
<li class="listitem">
<code class="literal">getElement()</code>: a reference to the jQuery wrapped DOM element, that renders the visualization
</li>
<li class="listitem">
<code class="literal">whenFirstRenderComplete()</code>: will return a promise, that resolves as soon as the visualization has
finished rendering for the first time
</li>
<li class="listitem">
<code class="literal">addRenderCompleteListener(listener)</code>: will register a listener to be called whenever
a rendering of this visualization finished (not just the first one)
</li>
<li class="listitem">
<code class="literal">removeRenderCompleteListener(listener)</code>: removes an event listener from the handler again
</li>
</ul>
</div>
<p>You can find the detailed <code class="literal">EmbeddedVisualizeHandler</code> documentation in its
{repo}blob/6.8/src/ui/public/visualize/loader/embedded_visualize_handler.ts[source code].</p>
<p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</p>
<p><a id="development-create-visualization"></a>=== Developing Visualizations</p>
<p>This is a short description of functions and interfaces provided. For more information you should check the kibana
source code and the existing visualizations provided with it.</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
<p><a class="xref" href="development-plugin-localization.html#development-visualization-factory">Localization for plugins</a></p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
<a class="xref" href="development-plugin-localization.html#development-base-visualization-type">Localization for plugins</a>
</li>
<li class="listitem">
<a class="xref" href="development-plugin-localization.html#development-react-visualization-type">Localization for plugins</a>
</li>
</ul>
</div>
</li>
<li class="listitem">
<p><a class="xref" href="development-plugin-localization.html#development-vis-editors">Localization for plugins</a></p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
<a class="xref" href="development-plugin-localization.html#development-default-editor">Localization for plugins</a>
</li>
<li class="listitem">
<a class="xref" href="development-plugin-localization.html#development-custom-editor">Localization for plugins</a>
</li>
</ul>
</div>
</li>
<li class="listitem">
<p><a class="xref" href="development-plugin-localization.html#development-visualization-request-handlers">Localization for plugins</a></p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
<a class="xref" href="development-plugin-localization.html#development-default-request-handler">Localization for plugins</a>
</li>
<li class="listitem">
<a class="xref" href="development-plugin-localization.html#development-none-request-handler">Localization for plugins</a>
</li>
<li class="listitem">
<a class="xref" href="development-plugin-localization.html#development-custom-request-handler">Localization for plugins</a>
</li>
</ul>
</div>
</li>
<li class="listitem">
<p><a class="xref" href="development-plugin-localization.html#development-visualization-response-handlers">Localization for plugins</a></p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
<a class="xref" href="development-plugin-localization.html#development-default-response-handler">Localization for plugins</a>
</li>
<li class="listitem">
<a class="xref" href="development-plugin-localization.html#development-none-response-handler">Localization for plugins</a>
</li>
<li class="listitem">
<a class="xref" href="development-plugin-localization.html#development-custom-response-handler">Localization for plugins</a>
</li>
</ul>
</div>
</li>
<li class="listitem">
<p><a class="xref" href="development-plugin-localization.html#development-vis-object">Localization for plugins</a></p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
<a class="xref" href="development-plugin-localization.html#development-vis-timefilter">Localization for plugins</a>
</li>
</ul>
</div>
</li>
<li class="listitem">
<a class="xref" href="development-plugin-localization.html#development-aggconfig">Localization for plugins</a>
</li>
</ul>
</div>
<p><a id="development-visualization-factory"></a>=== Visualization Factory</p>
<p>Use the <code class="literal">VisualizationFactory</code> to create a new visualization.
The creation-methods create a new visualization tied to the underlying rendering technology.
You should also register the visualization with <code class="literal">VisTypesRegistryProvider</code>.</p>
<div class="pre_wrapper lang-js">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-js">import { VisFactoryProvider } from 'ui/vis/vis_factory';
import { VisTypesRegistryProvider } from 'ui/registry/vis_types';

const MyNewVisType = (Private) =&gt; {
  const VisFactory = Private(VisFactoryProvider);

  return  VisFactory.createBaseVisualization({
    name: 'my_new_vis',
    title: 'My New Vis',
    icon: 'my_icon',
    description: 'Cool new chart',
    ...
  });
}

VisTypesRegistryProvider.register(MyNewVisType);</pre>
</div>
<p>The list of common parameters:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
<span class="strong strong"><strong>name</strong></span>: unique visualization name, only lowercase letters and underscore
</li>
<li class="listitem">
<span class="strong strong"><strong>title</strong></span>: title of your visualization as displayed in kibana
</li>
<li class="listitem">
<span class="strong strong"><strong>icon</strong></span>: &lt;string&gt; the <a href="https://elastic.github.io/eui/#/display/icons" class="ulink" target="_top">EUI icon</a> type to use for this visualization
</li>
<li class="listitem">
<span class="strong strong"><strong>image</strong></span>: instead of an icon you can provide a SVG image (imported)
</li>
<li class="listitem">
<span class="strong strong"><strong>legacyIcon</strong></span>: (DEPRECATED) &lt;string&gt; provide a class name (e.g. for a font awesome icon)
</li>
<li class="listitem">
<span class="strong strong"><strong>description</strong></span>: description of your visualization as shown in kibana
</li>
<li class="listitem">
<span class="strong strong"><strong>hidden</strong></span>: &lt;bool&gt; if set to true, will hide the type from showing up in the visualization wizard
</li>
<li class="listitem">
<span class="strong strong"><strong>visConfig</strong></span>: object holding visualization parameters
</li>
<li class="listitem">
<span class="strong strong"><strong>visConfig.defaults</strong></span>: object holding default visualization configuration
</li>
<li class="listitem">
<span class="strong strong"><strong>visualization</strong></span>: A constructor function for a Visualization.
</li>
<li class="listitem">
<span class="strong strong"><strong>requestHandler</strong></span>: &lt;string&gt; one of the available request handlers or a &lt;function&gt; for a custom request handler
</li>
<li class="listitem">
<span class="strong strong"><strong>responseHandler</strong></span>: &lt;string&gt; one of the available response handlers or a &lt;function&gt; for a custom response handler
</li>
<li class="listitem">
<span class="strong strong"><strong>editor</strong></span>: &lt;string&gt; one of the available editors or Editor class for custom one
</li>
<li class="listitem">
<span class="strong strong"><strong>editorConfig</strong></span>: object holding editor parameters
</li>
<li class="listitem">
<span class="strong strong"><strong>options.showTimePicker</strong></span>: &lt;bool&gt; show or hide time picker (defaults to true)
</li>
<li class="listitem">
<span class="strong strong"><strong>options.showQueryBar</strong></span>: &lt;bool&gt; show or hide query bar (defaults to true)
</li>
<li class="listitem">
<span class="strong strong"><strong>options.showFilterBar</strong></span>: &lt;bool&gt; show or hide filter bar (defaults to true)
</li>
<li class="listitem">
<span class="strong strong"><strong>options.showIndexSelection</strong></span>: &lt;bool&gt; show or hide index selection (defaults to true)
</li>
<li class="listitem">
<span class="strong strong"><strong>stage</strong></span>: &lt;string&gt; Set this to "experimental" to mark your visualization as experimental.
Experimental visualizations can also be disabled from the advanced settings. (defaults to "production")
</li>
<li class="listitem">
<span class="strong strong"><strong>feedbackMessage</strong></span>: &lt;string&gt; You can provide a message (which can contain HTML), that will be appended
to the experimental notification in visualize, if your visualization is experimental or in lab mode.
</li>
</ul>
</div>
<p>Each of the factories have some of the custom parameters, which will be described below.</p>
<p><a id="development-base-visualization-type"></a>==== Base Visualization Type
The base visualization type does not make any assumptions about the rendering technology you are going to use and
works with pure JavaScript. It is the visualization type we recommend to use.</p>
<p>You need to provide a type with a constructor function, a render method which will be called every time
options or data change, and a destroy method which will be called to cleanup.</p>
<p>The render function receives the data object and status object which tells what actually changed.
Render function needs to return a promise, which should be resolved once the visualization is done rendering.</p>
<p>The status object provides information about changes since the previous render call.
Due to performance reasons you need to opt-in for each status change, that you want
to be informed about by Kibana. This is done by using the <code class="literal">requiresUpdateStatus</code> key
in your visualization registration object. You pass it an array, that contains all
the status updates you want to receive. By default none of it will be calculated.</p>
<p>The following snippet shows explain all available status updates. You should only
activate those changes, that you actually use in your <code class="literal">render</code> method.</p>
<div class="pre_wrapper lang-js">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-js">import { Status } from 'ui/vis/update_status';

// ...
return  VisFactory.createBaseVisualization({
  // ...
  requiresUpdateStatus: [
    // Check for changes in the aggregation configuration for the visualization
    Status.AGGS,
    // Check for changes in the actual data returned from Elasticsearch
    Status.DATA,
    // Check for changes in the parameters (configuration) for the visualization
    Status.PARAMS,
    // Check if the visualization has changes its size
    Status.RESIZE,
    // Check if the time range for the visualization has been changed
    Status.TIME,
    // Check if the UI state of the visualization has been changed
    Status.UI_STATE
  ]
});</pre>
</div>
<p>If you activate any of these status updates, the <code class="literal">status</code> object passed as second
parameter to the <code class="literal">render</code> method will contain a key for that status (e.g. <code class="literal">status[Status.DATA]</code>),
that is either <code class="literal">true</code> if a change has been detected or <code class="literal">false</code> otherwise.</p>
<div class="imageblock">
<div class="content">
<img src="images/visualize-flow.png" alt="Main Flow">
</div>
</div>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
Your visualizations constructor will get called with <code class="literal">vis</code> object and the DOM-element to which it should render.
At this point you should prepare everything for rendering, but not render yet
</li>
<li class="listitem">
<code class="literal">&lt;visualize&gt;</code> component monitors <code class="literal">appState</code>, <code class="literal">uiState</code> and <code class="literal">vis</code> for changes
</li>
<li class="listitem">
on changes the <code class="literal">&lt;visualize&gt;</code>-directive will call your <code class="literal">requestHandler</code>.
Implementing a request handler is optional, as you might use one of the provided ones.
</li>
<li class="listitem">
response from <code class="literal">requestHandler</code> will get passed to <code class="literal">responseHandler</code>. It should convert raw data to something that
can be consumed by visualization. Implementing <code class="literal">responseHandler</code> is optional, as you might use of of the provided ones.
</li>
<li class="listitem">
On new data from the <code class="literal">responseHandler</code> or on when the size of the surrounding DOM-element has changed,
your visualization <code class="literal">render</code>-method gets called. It needs to return a promise which resolves once the visualization
is done rendering.
</li>
<li class="listitem">
the visualization should call <code class="literal">vis.updateState()</code> any time something has changed that requires to
re-render or fetch new data.
</li>
</ul>
</div>
<div class="pre_wrapper lang-js">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-js">import { VisFactoryProvider } from 'ui/vis/vis_factory';
import { VisTypesRegistryProvider } from 'ui/registry/vis_types';

class MyVisualization {
   constructor(el, vis) {
      this.el = el;
      this.vis = vis;
   }
   async render(visData, status) {
      ...
      return 'done rendering';
   }
   destroy() {
      console.log('destroying');
   }
}

const MyNewVisType = (Private) =&gt; {
  const VisFactory = Private(VisFactoryProvider);

  return VisFactory.createBaseVisualization({
    name: 'my_new_vis',
    title: 'My New Vis',
    icon: 'my_icon',
    description: 'Cool new chart',
    visualization: MyVisualization
  });
}

VisTypesRegistryProvider.register(MyNewVisType);</pre>
</div>
<p><a id="development-react-visualization-type"></a>==== React Visualization Type
React visualization type assumes you are using React as your rendering technology.
Just pass in a React component to <code class="literal">visConfig.component</code>.</p>
<p>The visualization will receive <code class="literal">vis</code>, <code class="literal">appState</code>, <code class="literal">updateStatus</code> and <code class="literal">visData</code> as props.
It also has a <code class="literal">renderComplete</code> property, which needs to be called once the rendering has completed.</p>
<div class="pre_wrapper lang-js">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-js">import { ReactComponent } from './my_react_component';

const MyNewVisType = (Private) =&gt; {
  const VisFactory = Private(VisFactoryProvider);

  return VisFactory.createReactVisualization({
    name: 'my_new_vis',
    title: 'My New Vis',
    icon: 'my_icon',
    description: 'Cool new chart',
    visConfig: {
       component: ReactComponent
    }
  });
}</pre>
</div>
<p><a id="development-vis-editors"></a>=== Visualization Editors
By default, visualizations will use the <code class="literal">default</code> editor.
This is the sidebar editor you see in many of the Kibana visualizations. You can also write your own editor.</p>
<p><a id="development-default-editor"></a>==== <code class="literal">default</code> editor controller
The default editor controller receives an <code class="literal">optionsTemplate</code> or <code class="literal">optionsTabs</code> parameter.
These can be either an AngularJS template or React component.</p>
<div class="pre_wrapper lang-js">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-js">{
    name: 'my_new_vis',
    title: 'My New Vis',
    icon: 'my_icon',
    description: 'Cool new chart',
    editor: 'default',
    editorConfig: {
       optionsTemplate: '&lt;my-custom-options-directive&gt;&lt;/my-custom-options-directive&gt;' // or
       optionsTemplate: MyReactComponent // or if multiple tabs are required:
       optionsTabs: [
           { title: 'tab 1', template: '&lt;div&gt;....&lt;/div&gt; },
           { title: 'tab 2', template: '&lt;my-custom-options-directive&gt;&lt;/my-custom-options-directive&gt;' },
           { title: 'tab 3', template: MyReactComponent }
       ]
    }
  }</pre>
</div>
<p><a id="development-custom-editor"></a>==== custom editor controller
You can create a custom editor controller. To do so pass an Editor object (the same format as VisController class).
You can make your controller take extra configuration which is passed to the editorConfig property.</p>
<div class="pre_wrapper lang-js">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-js">import { VisFactoryProvider } from 'ui/vis/vis_factory';

class MyEditorController {
    constructor(el, vis) {
      this.el = el;
      this.vis = vis;
      this.config = vis.type.editorConfig;
   }
   async render(visData) {
      console.log(this.config.my);
      ...
      return 'done rendering';
   }
   destroy() {
      console.log('destroying');
   }
}

const MyNewVisType = (Private) =&gt; {
  const VisFactory = Private(VisFactoryProvider);

  return VisFactory.createAngularVisualization({
    name: 'my_new_vis',
    title: 'My New Vis',
    icon: 'my_icon',
    description: 'Cool new chart',
    editor: MyEditorController,
    editorConfig: { my: 'custom config' }
  });
}

VisTypesRegistryProvider.register(MyNewVisType);</pre>
</div>
<p><a id="development-visualization-request-handlers"></a>=== Visualization Request Handlers
Request handler gets called when one of the following keys on AppState change:
<code class="literal">vis</code>, <code class="literal">query</code>, <code class="literal">filters</code> or <code class="literal">uiState</code> and when timepicker is updated. On top
of that it will also get called on force refresh.</p>
<p>By default visualizations will use the <code class="literal">courier</code> request handler. They can also choose to use any of the other provided
request handlers. It is also possible to define your own request handler
(which you can then register to be used by other visualizations).</p>
<p><a id="development-default-request-handler"></a>==== courier request handler
<em>courier</em> is the default request handler which works with the <em>default</em> side bar editor.</p>
<p><a id="development-none-request-handler"></a>==== <code class="literal">none</code> request handler
Using <em>none</em> as your request handles means your visualization does not require any data to be requested.</p>
<p><a id="development-custom-request-handler"></a>==== custom request handler
You can define your custom request handler by providing a function with the following signature:
<code class="literal">function (vis, { uiState, appState, timeRange }) { ... }</code></p>
<p>The <code class="literal">timeRange</code> will be an object with a <code class="literal">from</code> and <code class="literal">to</code> key, that can contain
datemath expressions, like <code class="literal">now-7d</code>. You can use the <code class="literal">datemath</code> library to parse
them.</p>
<p>This function must return a promise, which should get resolved with new data that will be passed to responseHandler.</p>
<p>It&#8217;s up to function to decide when it wants to issue a new request or return previous data
(if none of the objects relevant to the request handler changed).</p>
<div class="pre_wrapper lang-js">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-js">import { VisFactoryProvider } from 'ui/vis/vis_factory';

const myRequestHandler = async (vis, { appState, uiState, timeRange }) =&gt; {
  const data = ... parse ...
  return data;
};

const MyNewVisType = (Private) =&gt; {
  const VisFactory = Private(VisFactoryProvider);

  return VisFactory.createAngularVisualization({
    name: 'my_new_vis',
    title: 'My New Vis',
    icon: 'my_icon',
    description: 'Cool new chart',
    requestHandler: myRequestHandler
  });
}

VisTypesRegistryProvider.register(MyNewVisType);</pre>
</div>
<p><a id="development-visualization-response-handlers"></a>=== Visualization Response Handlers
The response handler is a function that receives the data from a request handler, as well as an instance of Vis object.
Its job is to convert the data to a format visualization can use. By default <em>default</em> request handler is used
which produces a table representation of the data. The data object will then be passed to visualization.
This response matches the visData property of the &lt;visualization&gt; directive.</p>
<p><a id="development-default-response-handler"></a>==== default response handler
The default response handler converts pure elasticsearch responses into a tabular format.
It is the recommended responseHandler. The response object contains a table property,
which is an array of all the tables in the response. Each of the table objects has two properties:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
<code class="literal">columns</code>: array of column objects, where each column object has a title property and an aggConfig property
</li>
<li class="listitem">
<code class="literal">rows</code>: array of rows, where each row is an array of non formatted cell values
</li>
</ul>
</div>
<p>Here is an example of a response with 1 table, 3 columns and 2 rows:</p>
<div class="pre_wrapper lang-js">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-js">{
  tables: [{
    columns: [{
      title: 'column1',
      aggConfig: ...
    },{
      title: 'column2',
      aggConfig: ...
    },{
      title: 'column3',
      aggConfig: ...
    }],
    rows: [
      [ '404', 1262, 12.5 ]
      [ '200', 343546, 60.1 ]
    ]
  }];
}</pre>
</div>
<p><a id="development-none-response-handler"></a>==== none response handler
None response handler is an identity function, which will return the same data it receives.</p>
<p><a id="development-custom-response-handler"></a>==== custom response handler
You can define your custom response handler by providing a function with the following definition:
<em>function (vis, response) { &#8230;&#8203; }</em>.</p>
<p>Function should return the transformed data object that visualization can consume.</p>
<div class="pre_wrapper lang-js">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-js">import { VisFactoryProvider } from 'ui/vis/vis_factory';

const myResponseHandler = (vis, response) =&gt; {
   // transform the response (based on vis object?)
   const response = ... transform data ...;
   return response;
};

const MyNewVisType(Private) =&gt; {
  const VisFactory = Private(VisFactoryProvider);

  return VisFactory.createAngularVisualization({
    name: 'my_new_vis',
    title: 'My New Vis',
    icon: 'my_icon',
    description: 'Cool new chart',
    responseHandler: myResponseHandler
  });
}

VisTypesRegistryProvider.register(MyNewVisType);</pre>
</div>
<p><a id="development-vis-object"></a>=== Vis object
The <code class="literal">vis</code> object holds the visualization state and is the window into kibana:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
<span class="strong strong"><strong>vis.params</strong></span>: holds the visualization parameters
</li>
<li class="listitem">
<span class="strong strong"><strong>vis.indexPattern</strong></span>: selected index pattern object
</li>
<li class="listitem">
<span class="strong strong"><strong>vis.getState()</strong></span>: gets current visualization state
</li>
<li class="listitem">
<span class="strong strong"><strong>vis.updateState()</strong></span>: updates current state with values from <code class="literal">vis.params</code>
</li>
<li class="listitem">
<span class="strong strong"><strong>vis.resetState()</strong></span>: resets <code class="literal">vis.params</code> to the values in the current state
</li>
<li class="listitem">
<span class="strong strong"><strong>vis.forceReload()</strong></span>: forces whole cycle (request handler gets called)
</li>
<li class="listitem">
<span class="strong strong"><strong>vis.getUiState()</strong></span>: gets UI state of visualization
</li>
<li class="listitem">
<span class="strong strong"><strong>vis.uiStateVal(name, val)</strong></span>: updates a property in UI state
</li>
<li class="listitem">
<span class="strong strong"><strong>vis.isEditorMode()</strong></span>: returns true if in editor mode
</li>
<li class="listitem">
<span class="strong strong"><strong>vis.API.timeFilter</strong></span>: allows you to access time picker
</li>
<li class="listitem">
<span class="strong strong"><strong>vis.API.queryFilter</strong></span>: gives you access to queryFilter
</li>
<li class="listitem">
<span class="strong strong"><strong>vis.API.events.click</strong></span>: default click handler
</li>
<li class="listitem">
<span class="strong strong"><strong>vis.API.events.brush</strong></span>: default brush handler
</li>
</ul>
</div>
<p>The visualization gets all its parameters in <code class="literal">vis.params</code>, which are default values merged with the current state.
If the visualization needs to update the current state, it should update the <code class="literal">vis.params</code> and call <code class="literal">vis.updateState()</code>
which will inform &lt;visualize&gt; about the change, which will call request and response handler and then your
visualization&#8217;s render method.</p>
<p>For the parameters that should not be saved with the visualization you should use the UI state.
These hold viewer-specific state, such as popup open/closed, custom colors applied to the series etc.</p>
<p>You can access filter bar and time picker through the objects defined on <code class="literal">vis.API</code></p>
<p><a id="development-vis-timefilter"></a>==== timeFilter</p>
<p>Update the timefilter time values and call update() method on it to update time picker</p>
<div class="pre_wrapper lang-js">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-js">   timefilter.time.from = moment(ranges.xaxis.from);
   timefilter.time.to = moment(ranges.xaxis.to);
   timefilter.time.mode = 'absolute';
   timefilter.update();</pre>
</div>
<p><a id="development-aggconfig"></a>=== AggConfig object</p>
<p>The AggConfig object represents an aggregation search to Elasticsearch,
plus some additional functionality to manage data-values that belong to this aggregation.
This is primarily used internally in Kibana, but you may find you have a need for it
when writing your own visualization. Here we provide short description of some of the methods on it,
however the best reference would be to actually check the source code.</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
<span class="strong strong"><strong>fieldFormatter(&lt;type&gt;)</strong></span> : returns a function which will format your value according to field formatters defined on
the field. The type can be either <em>text</em> or <em>html</em>.
</li>
<li class="listitem">
<span class="strong strong"><strong>makeLabel()</strong></span> : gets the label for the aggregation
</li>
<li class="listitem">
<span class="strong strong"><strong>isFilterable()</strong></span> : return true if aggregation is filterable (you can then call createFilter)
</li>
<li class="listitem">
<span class="strong strong"><strong>createFilter(bucketKey)</strong></span> : creates a filter for specific bucket key
</li>
<li class="listitem">
<span class="strong strong"><strong>getValue(bucket)</strong></span> : gets value for a specific bucket
</li>
<li class="listitem">
<span class="strong strong"><strong>getField()</strong></span> : gets the field used for this aggregation
</li>
<li class="listitem">
<span class="strong strong"><strong>getFieldDisplayName()</strong></span> : gets field display name
</li>
<li class="listitem">
<span class="strong strong"><strong>getAggParams()</strong></span> : gets the arguments to the aggregation
</li>
</ul>
</div>
</div>
</div>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
The <a class="xref" href="breaking-changes.html" title="Breaking changes">breaking changes</a> documentation, where we try to capture any changes to the APIs as they occur across minors.
</li>
<li class="listitem">
<a href="https://github.com/elastic/kibana/issues/44121" class="ulink" target="_top">Meta issue</a> which is tracking the move of the plugin to the new Kibana platform
</li>
<li class="listitem">
Our <a href="/blog/join-our-elastic-stack-workspace-on-slack" class="ulink" target="_top">Elastic Stack workspace on Slack</a>.
</li>
<li class="listitem">
The <a href="https://github.com/elastic/kibana/blob/6.8/src/plugins/visualizations" class="ulink" target="_top">source code</a>, which will continue to be
the most accurate source of information.
&gt;&gt;&gt;&gt;&gt;&gt;&gt; d26cbef389&#8230;&#8203; [DOCS] Adds kibana-pull attribute for release docs (#69554)
</li>
</ul>
</div>
</div>
</div>
</div><div class="navfooter">
<span class="prev">
<a href="development-plugin-functional-tests.html">« Functional Tests for Plugins</a>
</span>
<span class="next">
<a href="add-data-guide.html">Add Data Guide »</a>
</span>
</div>
</body>
</html>
