<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Kibana Core API | Kibana Guide [7.x] | Elastic</title>
<link rel="home" href="index.html" title="Kibana Guide [7.x]"/>
<link rel="up" href="kibana-architecture.html" title="Architecture"/>
<link rel="prev" href="kibana-platform-plugin-api.html" title="Kibana Plugin API"/>
<link rel="next" href="_patterns.html" title="Patterns"/>
<meta name="DC.type" content="Learn/Docs/Kibana/Reference/7.x"/>
<meta name="DC.subject" content="Kibana"/>
<meta name="DC.identifier" content="7.x"/>
</head>
<body><div class="page_header">
You are looking at preliminary documentation for a future release.
Not what you want? See the
<a href="../current/index.html">current release documentation</a>.
</div>
<div id="content">
<div class="breadcrumbs">
<span class="breadcrumb-link"><a href="index.html">Kibana Guide [7.x]</a></span>
»
<span class="breadcrumb-link"><a href="development.html">Developer guide</a></span>
»
<span class="breadcrumb-link"><a href="kibana-architecture.html">Architecture</a></span>
»
<span class="breadcrumb-node">Kibana Core API</span>
</div>
<div class="navheader">
<span class="prev">
<a href="kibana-platform-plugin-api.html">« Kibana Plugin API</a>
</span>
<span class="next">
<a href="_patterns.html">Patterns »</a>
</span>
</div>
<div class="section">
<div class="titlepage"><div><div>
<h2 class="title"><a id="kibana-platform-api"></a>Kibana Core API<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/kibana/edit/7.x/docs/developer/architecture/core/index.asciidoc">edit</a></h2>
</div></div></div>
<div class="warning admon">
<div class="icon"></div>
<div class="admon_content">
<p>This functionality is experimental and may be changed or removed completely in a future release. Elastic will take a best effort approach to fix any issues, but experimental features are not subject to the support SLA of official GA features.</p>
</div>
</div>
<p>Kibana Core provides a set of low-level API&#8217;s required to run all Kibana plugins.
These API&#8217;s are injected into your plugin&#8217;s lifecycle methods and may be invoked during that lifecycle only:</p>
<div class="pre_wrapper lang-typescript">
<pre class="programlisting prettyprint lang-typescript">import type { PluginInitializerContext, CoreSetup, CoreStart } from 'kibana/server';

export class MyPlugin {
  constructor(initializerContext: PluginInitializerContext) {}

  public setup(core: CoreSetup) {
    // called when plugin is setting up during Kibana's startup sequence
  }

  public start(core: CoreStart) {
    // called after all plugins are set up
  }

  public stop() {
    // called when plugin is torn down during Kibana's shutdown sequence
  }
}</pre>
</div>
<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_server_side"></a>Server-side<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/kibana/edit/7.x/docs/developer/architecture/core/index.asciidoc">edit</a></h3>
</div></div></div>
<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="configuration-service"></a>Configuration service<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/kibana/edit/7.x/docs/developer/architecture/core/index.asciidoc">edit</a></h4>
</div></div></div>
<p>Kibana provides <code class="literal">ConfigService</code> if a plugin developer may want to support
adjustable runtime behavior for their plugins.
Plugins can only read their own configuration values, it is not possible to access the configuration values from Kibana Core or other plugins directly.</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">// in Legacy platform
const basePath = config.get('server.basePath');
// in Kibana Platform 'basePath' belongs to the http service
const basePath = core.http.basePath.get(request);</pre>
</div>
<p>To have access to your plugin config, you <em>should</em>:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
Declare plugin-specific <code class="literal">configPath</code> (will fallback to plugin <code class="literal">id</code>
if not specified) in <a href="https://github.com/elastic/kibana/blob/7.10/docs/development/core/server/kibana-plugin-core-server.pluginmanifest.md" class="ulink" target="_top"><code class="literal">kibana.json</code></a> manifest file.
</li>
<li class="listitem">
Export schema validation for the config from plugin&#8217;s main file. Schema is
mandatory. If a plugin reads from the config without schema declaration,
<code class="literal">ConfigService</code> will throw an error.
</li>
</ul>
</div>
<p><span class="strong strong"><strong>my_plugin/server/index.ts</strong></span></p>
<div class="pre_wrapper lang-typescript">
<pre class="programlisting prettyprint lang-typescript">import { schema, TypeOf } from '@kbn/config-schema';
export const plugin = …
export const config = {
  schema: schema.object(…),
};
export type MyPluginConfigType = TypeOf&lt;typeof config.schema&gt;;</pre>
</div>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
Read config value exposed via <code class="literal">PluginInitializerContext</code>.
<span class="strong strong"><strong>my_plugin/server/index.ts</strong></span>
</li>
</ul>
</div>
<pre class="screen">import type { PluginInitializerContext } from 'kibana/server';
export class MyPlugin {
  constructor(initializerContext: PluginInitializerContext) {
    this.config$ = initializerContext.config.create&lt;MyPluginConfigType&gt;();
    // or if config is optional:
    this.config$ = initializerContext.config.createIfExists&lt;MyPluginConfigType&gt;();
  }</pre>
<p>If your plugin also has a client-side part, you can also expose
configuration properties to it using the configuration <code class="literal">exposeToBrowser</code>
allow-list property.</p>
<p><span class="strong strong"><strong>my_plugin/server/index.ts</strong></span></p>
<div class="pre_wrapper lang-typescript">
<pre class="programlisting prettyprint lang-typescript">import { schema, TypeOf } from '@kbn/config-schema';
import type { PluginConfigDescriptor } from 'kibana/server';

const configSchema = schema.object({
  secret: schema.string({ defaultValue: 'Only on server' }),
  uiProp: schema.string({ defaultValue: 'Accessible from client' }),
});

type ConfigType = TypeOf&lt;typeof configSchema&gt;;

export const config: PluginConfigDescriptor&lt;ConfigType&gt; = {
  exposeToBrowser: {
    uiProp: true,
  },
  schema: configSchema,
};</pre>
</div>
<p>Configuration containing only the exposed properties will be then
available on the client-side using the plugin&#8217;s <code class="literal">initializerContext</code>:</p>
<p><span class="strong strong"><strong>my_plugin/public/index.ts</strong></span></p>
<div class="pre_wrapper lang-typescript">
<pre class="programlisting prettyprint lang-typescript">interface ClientConfigType {
  uiProp: string;
}

export class MyPlugin implements Plugin&lt;PluginSetup, PluginStart&gt; {
  constructor(private readonly initializerContext: PluginInitializerContext) {}

  public async setup(core: CoreSetup, deps: {}) {
    const config = this.initializerContext.config.get&lt;ClientConfigType&gt;();
  }</pre>
</div>
<p>All plugins are considered enabled by default. If you want to disable
your plugin, you could declare the <code class="literal">enabled</code> flag in the plugin
config. This is a special Kibana Platform key. Kibana reads its
value and won’t create a plugin instance if <code class="literal">enabled: false</code>.</p>
<div class="pre_wrapper lang-js">
<pre class="programlisting prettyprint lang-js">export const config = {
  schema: schema.object({ enabled: schema.boolean({ defaultValue: false }) }),
};</pre>
</div>
<div class="section">
<div class="titlepage"><div><div>
<h5 class="title"><a id="handle-plugin-configuration-deprecations"></a>Handle plugin configuration deprecations<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/kibana/edit/7.x/docs/developer/architecture/core/index.asciidoc">edit</a></h5>
</div></div></div>
<p>If your plugin has deprecated configuration keys, you can describe them using
the <code class="literal">deprecations</code> config descriptor field.
Deprecations are managed on a per-plugin basis, meaning you don’t need to specify
the whole property path, but use the relative path from your plugin’s
configuration root.</p>
<p><span class="strong strong"><strong>my_plugin/server/index.ts</strong></span></p>
<div class="pre_wrapper lang-typescript">
<pre class="programlisting prettyprint lang-typescript">import { schema, TypeOf } from '@kbn/config-schema';
import type { PluginConfigDescriptor } from 'kibana/server';

const configSchema = schema.object({
  newProperty: schema.string({ defaultValue: 'Some string' }),
});

type ConfigType = TypeOf&lt;typeof configSchema&gt;;

export const config: PluginConfigDescriptor&lt;ConfigType&gt; = {
  schema: configSchema,
  deprecations: ({ rename, unused }) =&gt; [
    rename('oldProperty', 'newProperty'),
    unused('someUnusedProperty'),
  ],
};</pre>
</div>
<p>In some cases, accessing the whole configuration for deprecations is
necessary. For these edge cases, <code class="literal">renameFromRoot</code> and <code class="literal">unusedFromRoot</code>
are also accessible when declaring deprecations.</p>
<p><span class="strong strong"><strong>my_plugin/server/index.ts</strong></span></p>
<div class="pre_wrapper lang-typescript">
<pre class="programlisting prettyprint lang-typescript">export const config: PluginConfigDescriptor&lt;ConfigType&gt; = {
  schema: configSchema,
  deprecations: ({ renameFromRoot, unusedFromRoot }) =&gt; [
    renameFromRoot('oldplugin.property', 'myplugin.property'),
    unusedFromRoot('oldplugin.deprecated'),
  ],
};</pre>
</div>
</div>

</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="_logging_service"></a>Logging service<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/kibana/edit/7.x/docs/developer/architecture/core/index.asciidoc">edit</a></h4>
</div></div></div>
<p>Allows a plugin to provide status and diagnostic information.
For detailed instructions see the <a href="https://github.com/elastic/kibana/blob/7.10/src/core/server/logging/README.md" class="ulink" target="_top">logging service documentation</a>.</p>
<div class="pre_wrapper lang-typescript">
<pre class="programlisting prettyprint lang-typescript">import type { PluginInitializerContext, CoreSetup, Plugin, Logger } from 'kibana/server';

export class MyPlugin implements Plugin {
  private readonly logger: Logger;

  constructor(initializerContext: PluginInitializerContext) {
    this.logger = initializerContext.logger.get();
  }

  public setup(core: CoreSetup) {
    try {
      this.logger.debug('doing something...');
      // …
    } catch (e) {
      this.logger.error('failed doing something...');
    }
  }
}</pre>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="_elasticsearch_service"></a>Elasticsearch service<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/kibana/edit/7.x/docs/developer/architecture/core/index.asciidoc">edit</a></h4>
</div></div></div>
<p><code class="literal">Elasticsearch service</code> provides <code class="literal">elasticsearch.client</code> program API to communicate with Elasticsearch server REST API.
<code class="literal">elasticsearch.client</code> interacts with Elasticsearch service on behalf of:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
<code class="literal">kibana_system</code> user via <code class="literal">elasticsearch.client.asInternalUser.*</code> methods.
</li>
<li class="listitem">
a current end-user via <code class="literal">elasticsearch.client.asCurrentUser.*</code> methods. In this case Elasticsearch client should be given the current user credentials.
See <a class="xref" href="_patterns.html#scoped-services" title="Scoped services">Scoped services</a> and <a class="xref" href="development-security.html" title="Security">Security</a>.
</li>
</ul>
</div>
<p><a href="https://github.com/elastic/kibana/blob/7.10/docs/development/core/server/kibana-plugin-core-server.elasticsearchservicestart.md" class="ulink" target="_top">Elasticsearch service API docs</a></p>
<div class="pre_wrapper lang-typescript">
<pre class="programlisting prettyprint lang-typescript">import { CoreStart, Plugin } from 'kibana/public';

export class MyPlugin implements Plugin {
  public start(core: CoreStart) {
    async function asyncTask() {
      const result = await core.elasticsearch.client.asInternalUser.ping(…);
    }
    asyncTask();
  }
}</pre>
</div>
<p>For advanced use-cases, such as a search, use <a href="https://github.com/elastic/kibana/blob/7.10/docs/development/plugins/data/server/kibana-plugin-plugins-data-server.md" class="ulink" target="_top">Data plugin</a></p>
</div>

</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="saved-objects-service"></a>Saved Objects service<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/kibana/edit/7.x/docs/developer/architecture/core/saved-objects-service.asciidoc">edit</a></h3>
</div></div></div>
<p><code class="literal">Saved Objects service</code> allows Kibana plugins to use Elasticsearch like a primary
database. Think of it as an Object Document Mapper for Elasticsearch. Once a
plugin has registered one or more Saved Object types, the Saved Objects client
can be used to query or perform create, read, update and delete operations on
each type.</p>
<p>By using Saved Objects your plugin can take advantage of the following
features:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
Migrations can evolve your document&#8217;s schema by transforming documents and
ensuring that the field mappings on the index are always up to date.
</li>
<li class="listitem">
a <a class="xref" href="saved-objects-api.html" title="Saved objects APIs">HTTP API</a> is automatically exposed for each type (unless
<code class="literal">hidden=true</code> is specified).
</li>
<li class="listitem">
a Saved Objects client that can be used from both the server and the browser.
</li>
<li class="listitem">
Users can import or export Saved Objects using the Saved Objects management
UI or the Saved Objects import/export API.
</li>
<li class="listitem">
By declaring <code class="literal">references</code>, an object&#8217;s entire reference graph will be
exported. This makes it easy for users to export e.g. a <code class="literal">dashboard</code> object and
have all the <code class="literal">visualization</code> objects required to display the dashboard
included in the export.
</li>
<li class="listitem">
When the X-Pack security and spaces plugins are enabled these transparently
provide RBAC access control and the ability to organize Saved Objects into
spaces.
</li>
</ul>
</div>
<p>This document contains developer guidelines and best-practices for plugins
wanting to use Saved Objects.</p>
<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="_registering_a_saved_object_type"></a>Registering a Saved Object type<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/kibana/edit/7.x/docs/developer/architecture/core/saved-objects-service.asciidoc">edit</a></h4>
</div></div></div>
<p>Saved object type definitions should be defined in their own <code class="literal">my_plugin/server/saved_objects</code> directory.</p>
<p>The folder should contain a file per type, named after the snake_case name of the type, and an <code class="literal">index.ts</code> file exporting all the types.</p>
<p><strong>src/plugins/my_plugin/server/saved_objects/dashboard_visualization.ts.</strong></p>
<div class="pre_wrapper lang-typescript">
<pre class="programlisting prettyprint lang-typescript">import { SavedObjectsType } from 'src/core/server';

export const dashboardVisualization: SavedObjectsType = {
  name: 'dashboard_visualization', <a id="CO42-1"></a><i class="conum" data-value="1"></i>
  hidden: false,
  namespaceType: 'single',
  mappings: {
    dynamic: false,
    properties: {
      description: {
        type: 'text',
      },
      hits: {
        type: 'integer',
      },
    },
  },
  migrations: {
    '1.0.0': migratedashboardVisualizationToV1,
    '2.0.0': migratedashboardVisualizationToV2,
  },
};</pre>
</div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO42-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>Since the name of a Saved Object type forms part of the url path for the
public Saved Objects HTTP API, these should follow our API URL path convention
and always be written as snake case.</p>
</td>
</tr>
</table>
</div>
<p><strong>src/plugins/my_plugin/server/saved_objects/index.ts.</strong></p>
<div class="pre_wrapper lang-typescript">
<pre class="programlisting prettyprint lang-typescript">export { dashboardVisualization } from './dashboard_visualization';
export { dashboard } from './dashboard';</pre>
</div>
<p><strong>src/plugins/my_plugin/server/plugin.ts.</strong></p>
<div class="pre_wrapper lang-typescript">
<pre class="programlisting prettyprint lang-typescript">import { dashboard, dashboardVisualization } from './saved_objects';

export class MyPlugin implements Plugin {
  setup({ savedObjects }) {
    savedObjects.registerType(dashboard);
    savedObjects.registerType(dashboardVisualization);
  }
}</pre>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="_mappings"></a>Mappings<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/kibana/edit/7.x/docs/developer/architecture/core/saved-objects-service.asciidoc">edit</a></h4>
</div></div></div>
<p>Each Saved Object type can define it&#8217;s own Elasticsearch field mappings.
Because multiple Saved Object types can share the same index, mappings defined
by a type will be nested under a top-level field that matches the type name.</p>
<p>For example, the mappings defined by the <code class="literal">dashboard_visualization</code> Saved
Object type:</p>
<p><strong>src/plugins/my_plugin/server/saved_objects/dashboard_visualization.ts.</strong></p>
<div class="pre_wrapper lang-typescript">
<pre class="programlisting prettyprint lang-typescript">import { SavedObjectsType } from 'src/core/server';

export const dashboardVisualization: SavedObjectsType = {
  name: 'dashboard_visualization',
  ...
  mappings: {
    properties: {
      dynamic: false,
      description: {
        type: 'text',
      },
      hits: {
        type: 'integer',
      },
    },
  },
  migrations: { ... },
};</pre>
</div>
<p>Will result in the following mappings being applied to the <code class="literal">.kibana</code> index:</p>
<div class="pre_wrapper lang-json">
<pre class="programlisting prettyprint lang-json">{
  "mappings": {
    "dynamic": "strict",
    "properties": {
      ...
      "dashboard_vizualization": {
        "dynamic": false,
        "properties": {
          "description": {
            "type": "text",
          },
          "hits": {
            "type": "integer",
          },
        },
      }
    }
  }
}</pre>
</div>
<p>Do not use field mappings like you would use data types for the columns of a
SQL database. Instead, field mappings are analogous to a SQL index. Only
specify field mappings for the fields you wish to search on or query. By
specifying <code class="literal">dynamic: false</code> in any level of your mappings, Elasticsearch will
accept and store any other fields even if they are not specified in your mappings.</p>
<p>Since Elasticsearch has a default limit of 1000 fields per index, plugins
should carefully consider the fields they add to the mappings. Similarly,
Saved Object types should never use <code class="literal">dynamic: true</code> as this can cause an
arbitrary amount of fields to be added to the <code class="literal">.kibana</code> index.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="_references"></a>References<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/kibana/edit/7.x/docs/developer/architecture/core/saved-objects-service.asciidoc">edit</a></h4>
</div></div></div>
<p>When a Saved Object declares <code class="literal">references</code> to other Saved Objects, the
Saved Objects Export API will automatically export the target object with all
of it&#8217;s references. This makes it easy for users to export the entire
reference graph of an object.</p>
<p>If a Saved Object can&#8217;t be used on it&#8217;s own, that is, it needs other objects
to exist for a feature to function correctly, that Saved Object should declare
references to all the objects it requires. For example, a <code class="literal">dashboard</code>
object might have panels for several <code class="literal">visualization</code> objects. When these
<code class="literal">visualization</code> objects don&#8217;t exist, the dashboard cannot be rendered
correctly. The <code class="literal">dashboard</code> object should declare references to all it&#8217;s
visualizations.</p>
<p>However, <code class="literal">visualization</code> objects can continue to be rendered or embedded into
other dashboards even if the <code class="literal">dashboard</code> it was originally embedded into
doesn&#8217;t exist. As a result, <code class="literal">visualization</code> objects should not declare
references to <code class="literal">dashboard</code> objects.</p>
<p>For each referenced object, an <code class="literal">id</code>, <code class="literal">type</code> and <code class="literal">name</code> are added to the
<code class="literal">references</code> array:</p>
<div class="pre_wrapper lang-typescript">
<pre class="programlisting prettyprint lang-typescript">router.get(
  { path: '/some-path', validate: false },
  async (context, req, res) =&gt; {
    const object = await context.core.savedObjects.client.create(
      'dashboard',
      {
        title: 'my dashboard',
        panels: [
          { visualization: 'vis1' }, <a id="CO43-1"></a><i class="conum" data-value="1"></i>
        ],
        indexPattern: 'indexPattern1'
      },
      { references: [
          { id: '...', type: 'visualization', name: 'vis1' },
          { id: '...', type: 'index_pattern', name: 'indexPattern1' },
        ]
      }
    )
    ...
  }
);</pre>
</div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO43-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>Note how <code class="literal">dashboard.panels[0].visualization</code> stores the <code class="literal">name</code> property of
the reference (not the <code class="literal">id</code> directly) to be able to uniquely identify this
reference. This guarantees that the id the reference points to always remains
up to date. If a visualization <code class="literal">id</code> was directly stored in
<code class="literal">dashboard.panels[0].visualization</code> there is a risk that this <code class="literal">id</code> gets
updated without updating the reference in the references array.</p>
</td>
</tr>
</table>
</div>
<div class="section">
<div class="titlepage"><div><div>
<h5 class="title"><a id="_writing_migrations"></a>Writing Migrations<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/kibana/edit/7.x/docs/developer/architecture/core/saved-objects-service.asciidoc">edit</a></h5>
</div></div></div>
<p>Saved Objects support schema changes between Kibana versions, which we call
migrations. Migrations are applied when a Kibana installation is upgraded from
one version to the next, when exports are imported via the Saved Objects
Management UI, or when a new object is created via the HTTP API.</p>
<p>Each Saved Object type may define migrations for its schema. Migrations are
specified by the Kibana version number, receive an input document, and must
return the fully migrated document to be persisted to Elasticsearch.</p>
<p>Let&#8217;s say we want to define two migrations:
- In version 1.1.0, we want to drop the <code class="literal">subtitle</code> field and append it to the
  title
- In version 1.4.0, we want to add a new <code class="literal">id</code> field to every panel with a newly
  generated UUID.</p>
<p>First, the current <code class="literal">mappings</code> should always reflect the latest or "target"
schema. Next, we should define a migration function for each step in the schema
evolution:</p>
<p>src/plugins/my_plugin/server/saved_objects/dashboard_visualization.ts</p>
<div class="pre_wrapper lang-typescript">
<pre class="programlisting prettyprint lang-typescript">import { SavedObjectsType, SavedObjectMigrationFn } from 'src/core/server';
import uuid from 'uuid';

interface DashboardVisualizationPre110 {
  title: string;
  subtitle: string;
  panels: Array&lt;{}&gt;;
}
interface DashboardVisualization110 {
  title: string;
  panels: Array&lt;{}&gt;;
}

interface DashboardVisualization140 {
  title: string;
  panels: Array&lt;{ id: string }&gt;;
}

const migrateDashboardVisualization110: SavedObjectMigrationFn&lt;
  DashboardVisualizationPre110, <a id="CO44-1"></a><i class="conum" data-value="1"></i>
  DashboardVisualization110
&gt; = (doc) =&gt; {
  const { subtitle, ...attributesWithoutSubtitle } = doc.attributes;
  return {
    ...doc, <a id="CO44-2"></a><i class="conum" data-value="2"></i>
    attributes: {
      ...attributesWithoutSubtitle,
      title: `${doc.attributes.title} - ${doc.attributes.subtitle}`,
    },
  };
};

const migrateDashboardVisualization140: SavedObjectMigrationFn&lt;
  DashboardVisualization110,
  DashboardVisualization140
&gt; = (doc) =&gt; {
  const outPanels = doc.attributes.panels?.map((panel) =&gt; {
    return { ...panel, id: uuid.v4() };
  });
  return {
    ...doc,
    attributes: {
      ...doc.attributes,
      panels: outPanels,
    },
  };
};

export const dashboardVisualization: SavedObjectsType = {
  name: 'dashboard_visualization', <a id="CO44-3"></a><i class="conum" data-value="1"></i>
  /** ... */
  migrations: {
    // Takes a pre 1.1.0 doc, and converts it to 1.1.0
    '1.1.0': migrateDashboardVisualization110,

    // Takes a 1.1.0 doc, and converts it to 1.4.0
    '1.4.0': migrateDashboardVisualization140,  <a id="CO44-4"></a><i class="conum" data-value="3"></i>
  },
};</pre>
</div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO44-1"><i class="conum" data-value="1"></i></a><a href="#CO44-3"></a></p>
</td>
<td align="left" valign="top">
<p>It is useful to define an interface for each version of the schema. This
allows TypeScript to ensure that you are properly handling the input and output
types correctly as the schema evolves.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO44-2"><i class="conum" data-value="2"></i></a></p>
</td>
<td align="left" valign="top">
<p>Returning a shallow copy is necessary to avoid type errors when using
different types for the input and output shape.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO44-4"><i class="conum" data-value="3"></i></a></p>
</td>
<td align="left" valign="top">
<p>Migrations do not have to be defined for every version. The version number
of a migration must always be the earliest Kibana version in which this
migration was released. So if you are creating a migration which will be
part of the v7.10.0 release, but will also be backported and released as
v7.9.3, the migration version should be: 7.9.3.</p>
</td>
</tr>
</table>
</div>
<p>Migrations should be written defensively, an exception in a migration function
will prevent a Kibana upgrade from succeeding and will cause downtime for our
users. Having said that, if a document is encountered that is not in the
expected shape, migrations are encouraged to throw an exception to abort the
upgrade. In most scenarios, it is better to fail an upgrade than to silently
ignore a corrupt document which can cause unexpected behaviour at some future
point in time.</p>
<p>It is critical that you have extensive tests to ensure that migrations behave
as expected with all possible input documents. Given how simple it is to test
all the branch conditions in a migration function and the high impact of a bug
in this code, there&#8217;s really no reason not to aim for 100% test code coverage.</p>
</div>

</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="_http_service"></a>HTTP service<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/kibana/edit/7.x/docs/developer/architecture/core/index.asciidoc">edit</a></h4>
</div></div></div>
<p>Allows plugins:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
to extend the Kibana server with custom REST API.
</li>
<li class="listitem">
to execute custom logic on an incoming request or server response.
</li>
<li class="listitem">
implement custom authentication and authorization strategy.
</li>
</ul>
</div>
<p>See <a href="https://github.com/elastic/kibana/blob/7.10/docs/development/core/server/kibana-plugin-core-server.httpservicesetup.md" class="ulink" target="_top">HTTP service API docs</a></p>
<div class="pre_wrapper lang-typescript">
<pre class="programlisting prettyprint lang-typescript">import { schema } from '@kbn/config-schema';
import type { CoreSetup, Plugin } from 'kibana/server';

export class MyPlugin implements Plugin {
  public setup(core: CoreSetup) {
    const router = core.http.createRouter();

    const validate = {
      params: schema.object({
        id: schema.string(),
      }),
    };

    router.get({
      path: 'my_plugin/{id}',
      validate
    },
    async (context, request, response) =&gt; {
      const data = await findObject(request.params.id);
      if (!data) return response.notFound();
      return response.ok({
        body: data,
        headers: {
          'content-type': 'application/json'
        }
      });
    });
  }
}</pre>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="_ui_settings_service"></a>UI settings service<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/kibana/edit/7.x/docs/developer/architecture/core/index.asciidoc">edit</a></h4>
</div></div></div>
<p>The program interface to <a class="xref" href="advanced-options.html" title="Advanced Settings">UI settings</a>.
It makes it possible for Kibana plugins to extend Kibana UI Settings Management with custom settings.</p>
<p>See:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
<a href="https://github.com/elastic/kibana/blob/7.10/docs/development/core/server/kibana-plugin-core-server.uisettingsservicesetup.register.md" class="ulink" target="_top">UI settings service Setup API docs</a>
</li>
<li class="listitem">
<a href="https://github.com/elastic/kibana/blob/7.10/docs/development/core/server/kibana-plugin-core-server.uisettingsservicestart.register.md" class="ulink" target="_top">UI settings service Start API docs</a>
</li>
</ul>
</div>
<div class="pre_wrapper lang-typescript">
<pre class="programlisting prettyprint lang-typescript">import { schema } from '@kbn/config-schema';
import type { CoreSetup,Plugin } from 'kibana/server';

export class MyPlugin implements Plugin {
  public setup(core: CoreSetup) {
    core.uiSettings.register({
      custom: {
        value: '42',
        schema: schema.string(),
      },
    });
    const router = core.http.createRouter();
    router.get({
      path: 'my_plugin/{id}',
      validate: …,
    },
    async (context, request, response) =&gt; {
      const customSetting = await context.uiSettings.client.get('custom');
      …
    });
  }
}</pre>
</div>
</div>

</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="_client_side"></a>Client-side<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/kibana/edit/7.x/docs/developer/architecture/core/index.asciidoc">edit</a></h3>
</div></div></div>
<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="_application_service"></a>Application service<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/kibana/edit/7.x/docs/developer/architecture/core/index.asciidoc">edit</a></h4>
</div></div></div>
<p>Kibana has migrated to be a Single Page Application. Plugins should use <code class="literal">Application service</code> API to instruct Kibana what an application should be loaded &amp; rendered in the UI in response to user interactions.</p>
<div class="pre_wrapper lang-typescript">
<pre class="programlisting prettyprint lang-typescript">import { AppMountParameters, CoreSetup, Plugin, DEFAULT_APP_CATEGORIES } from 'kibana/public';

export class MyPlugin implements Plugin {
  public setup(core: CoreSetup) {
    core.application.register({ <a id="CO45-1"></a><i class="conum" data-value="1"></i>
      category: DEFAULT_APP_CATEGORIES.kibana,
      id: 'my-plugin',
      title: 'my plugin title',
      euiIconType: '/path/to/some.svg',
      order: 100,
      appRoute: '/app/my_plugin', <a id="CO45-2"></a><i class="conum" data-value="2"></i>
      async mount(params: AppMountParameters) { <a id="CO45-3"></a><i class="conum" data-value="3"></i>
        // Load application bundle
        const { renderApp } = await import('./application');
        // Get start services
        const [coreStart, depsStart] = await core.getStartServices(); <a id="CO45-4"></a><i class="conum" data-value="4"></i>
        // Render the application
        return renderApp(coreStart, depsStart, params); <a id="CO45-5"></a><i class="conum" data-value="5"></i>
      },
    });
  }
}</pre>
</div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO45-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>See <a href="https://github.com/elastic/kibana/blob/7.10/docs/development/core/public/kibana-plugin-core-public.applicationsetup.register.md" class="ulink" target="_top">application.register interface</a></p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO45-2"><i class="conum" data-value="2"></i></a></p>
</td>
<td align="left" valign="top">
<p>Application specific URL.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO45-3"><i class="conum" data-value="3"></i></a></p>
</td>
<td align="left" valign="top">
<p><code class="literal">mount</code> callback is invoked when a user navigates to the application-specific URL.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO45-4"><i class="conum" data-value="4"></i></a></p>
</td>
<td align="left" valign="top">
<p><code class="literal">core.getStartServices</code> method provides API available during <code class="literal">start</code> lifecycle.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO45-5"><i class="conum" data-value="5"></i></a></p>
</td>
<td align="left" valign="top">
<p><code class="literal">mount</code> method must return a function that will be called to unmount the application.</p>
<div class="variablelist">
<dl class="variablelist">
<dt>
<span class="term">
NOTE
</span>
</dt>
<dd>
you are free to use any UI library to render a plugin application in DOM.
However, we recommend using React and <a href="https://elastic.github.io/eui" class="ulink" target="_top">EUI</a> for all your basic UI
components to create a consistent UI experience.
</dd>
</dl>
</div>
</td>
</tr>
</table>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="_http_service_2"></a>HTTP service<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/kibana/edit/7.x/docs/developer/architecture/core/index.asciidoc">edit</a></h4>
</div></div></div>
<p>Provides API to communicate with the Kibana server. Feel free to use another HTTP client library to request 3rd party services.</p>
<div class="pre_wrapper lang-typescript">
<pre class="programlisting prettyprint lang-typescript">import { CoreStart } from 'kibana/public';
interface ResponseType {…};
async function fetchData&lt;ResponseType&gt;(core: CoreStart) {
  return await core.http.get&lt;&gt;(
    '/api/my_plugin/',
    { query: … },
  );
}</pre>
</div>
<p>See <a href="https://github.com/elastic/kibana/blob/7.10/docs/development/core/public/kibana-plugin-core-public.httpsetup.md" class="ulink" target="_top">for all available API</a>.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="_elasticsearch_service_2"></a>Elasticsearch service<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/kibana/edit/7.x/docs/developer/architecture/core/index.asciidoc">edit</a></h4>
</div></div></div>
<p>Not available in the browser. Use <a href="https://github.com/elastic/kibana/blob/7.10/docs/development/plugins/data/public/kibana-plugin-plugins-data-public.md" class="ulink" target="_top">Data plugin</a> instead.</p>
</div>

</div>

</div>
<div class="navfooter">
<span class="prev">
<a href="kibana-platform-plugin-api.html">« Kibana Plugin API</a>
</span>
<span class="next">
<a href="_patterns.html">Patterns »</a>
</span>
</div>
</div>
</body>
</html>
