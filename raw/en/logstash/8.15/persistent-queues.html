<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Persistent queues (PQ) | Logstash Reference [8.15] | Elastic</title>
<meta class="elastic" name="content" content="Persistent queues (PQ) | Logstash Reference [8.15]">

<link rel="home" href="index.html" title="Logstash Reference [8.15]"/>
<link rel="up" href="resiliency.html" title="Queues and data resiliency"/>
<link rel="prev" href="memory-queue.html" title="Memory queue"/>
<link rel="next" href="dead-letter-queues.html" title="Dead letter queues (DLQ)"/>
<meta class="elastic" name="product_version" content="8.15"/>
<meta class="elastic" name="product_name" content="Logstash"/>
<meta class="elastic" name="website_area" content="documentation"/>
<meta name="DC.type" content="Learn/Docs/Logstash/Reference/8.15"/>
<meta name="DC.subject" content="Logstash"/>
<meta name="DC.identifier" content="8.15"/>
</head>
<body>
<div class="navheader">
<span class="prev">
<a href="memory-queue.html">« Memory queue</a>
</span>
<span class="next">
<a href="dead-letter-queues.html">Dead letter queues (DLQ) »</a>
</span>
</div>
<div class="book" lang="en">
<div class="titlepage">
<div class="breadcrumbs">
<span class="breadcrumb-link"><a href="/guide/">Elastic Docs</a></span>
<span class="chevron-right">›</span><span class="breadcrumb-link"><a href="index.html">Logstash Reference [8.15]</a></span>
<span class="chevron-right">›</span><span class="breadcrumb-link"><a href="resiliency.html">Queues and data resiliency</a></span>
</div>
<div>
<div><h1 class="title"><a id="id-1"></a>Persistent queues (PQ)</h1><a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/logstash/edit/8.15/docs/static/persistent-queues.asciidoc">edit</a></div>
</div>
<!--EXTRA-->
</div>
<div id="content">
<div class="section">
<div class="titlepage"><div><div>
<h2 class="title"><a id="persistent-queues"></a>Persistent queues (PQ)<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/logstash/edit/8.15/docs/static/persistent-queues.asciidoc">edit</a></h2>
</div></div></div>
<p>A Logstash persistent queue helps protect against data loss during abnormal termination by storing the in-flight message queue to disk.</p>
<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="persistent-queues-benefits"></a>Benefits of persistent queues<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/logstash/edit/8.15/docs/static/persistent-queues.asciidoc">edit</a></h3>
</div></div></div>
<p>A persistent queue (PQ):</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
Helps protect against message loss during a normal shutdown and when Logstash
is terminated abnormally.
If Logstash is restarted while events are in-flight,
Logstash attempts to deliver messages stored in the persistent queue until
delivery succeeds at least once.
</li>
<li class="listitem">
Can absorb bursts of events without needing an external buffering mechanism like Redis or Apache Kafka.
</li>
</ul>
</div>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p>Persistent queues are disabled by default.
To enable them, check out <a class="xref" href="persistent-queues.html#configuring-persistent-queues" title="Configuring persistent queues">Configuring persistent queues</a>.</p>
</div>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="persistent-queues-limitations"></a>Limitations of persistent queues<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/logstash/edit/8.15/docs/static/persistent-queues.asciidoc">edit</a></h3>
</div></div></div>
<p>Persistent queues do not solve these problems:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
Input plugins that do not use a request-response protocol cannot be protected from data loss. Tcp, udp, zeromq push+pull, and many other inputs do not have a mechanism to acknowledge receipt to the sender.
(Plugins such as beats and http, which <span class="strong strong"><strong>do</strong></span> have an acknowledgement capability, are well protected by this queue.)
</li>
<li class="listitem">
Data may be lost if an abnormal shutdown occurs before the checkpoint file has been committed.
</li>
<li class="listitem">
A persistent queue does not handle permanent machine failures such as disk corruption, disk failure, and machine loss.
The data persisted to disk is not replicated.
</li>
</ul>
</div>
<div class="tip admon">
<div class="icon"></div>
<div class="admon_content">
<p>Use the local filesystem for data integrity and performance. Network File System (NFS) is not supported.</p>
</div>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="configuring-persistent-queues"></a>Configuring persistent queues<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/logstash/edit/8.15/docs/static/persistent-queues.asciidoc">edit</a></h3>
</div></div></div>
<p>To configure persistent queues, specify options in the Logstash <a class="xref" href="logstash-settings-file.html" title="logstash.yml">settings file</a>.
Settings are applied to every pipeline.</p>
<p>When you set values for capacity and sizing settings, remember that the value you set is applied <em>per pipeline</em> rather than a total to be shared among all pipelines.</p>
<div class="tip admon">
<div class="icon"></div>
<div class="admon_content">
<p>If you want to define values for a specific pipeline, use <a class="xref" href="multiple-pipelines.html" title="Multiple Pipelines"><code class="literal">pipelines.yml</code></a>.</p>
</div>
</div>
<div class="variablelist">
<dl class="variablelist">
<dt>
<span class="term">
<code class="literal">queue.type</code>
</span>
</dt>
<dd>
Specify <code class="literal">persisted</code> to enable persistent queues. By default, persistent queues are disabled (default: <code class="literal">queue.type: memory</code>).
</dd>
<dt>
<span class="term">
<code class="literal">path.queue</code>
</span>
</dt>
<dd>
The directory path where the data files will be stored. By default, the files are stored in <code class="literal">path.data/queue</code>.
</dd>
<dt>
<span class="term">
<code class="literal">queue.page_capacity</code>
</span>
</dt>
<dd>
The queue data consists of append-only files called "pages." This value sets the maximum size of a queue page in bytes.
The default size of 64mb is a good value for most users, and changing this value is unlikely to have performance benefits.
If you change the page capacity of an existing queue, the new size applies only to the new page.
</dd>
<dt>
<span class="term">
<code class="literal">queue.drain</code>
</span>
</dt>
<dd>
Specify <code class="literal">true</code> if you want Logstash to wait until the persistent queue is drained before shutting down. The amount of time it takes to drain the queue depends on the number of events that have accumulated in the queue. Therefore, you should avoid using this setting unless the queue, even when full, is relatively small and can be drained quickly.
</dd>
<dt>
<span class="term">
<code class="literal">queue.max_events</code>
</span>
</dt>
<dd>
The maximum number of events not yet read by the pipeline worker. The default is 0 (unlimited).
We use this setting for internal testing.
Users generally shouldn&#8217;t be changing this value.
</dd>
<dt>
<span class="term">
<code class="literal">queue.max_bytes</code>
</span>
</dt>
<dd>
<p>
The total capacity of <em>each queue</em> in number of bytes.
Unless overridden in <code class="literal">pipelines.yml</code> or central management, each persistent
queue will be sized at the value of <code class="literal">queue.max_bytes</code> specified in
<code class="literal">logstash.yml</code>.
The default is 1024mb (1gb).
</p>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p>Be sure that your disk has sufficient capacity to handle the cumulative total of <code class="literal">queue.max_bytes</code> across all persistent queues.
The total of <code class="literal">queue.max_bytes</code> for <em>all</em> queues should be
lower than the capacity of your disk.</p>
</div>
</div>
<div class="tip admon">
<div class="icon"></div>
<div class="admon_content">
<p>If you are using persistent queues to protect against data loss, but don&#8217;t
require much buffering, you can set <code class="literal">queue.max_bytes</code> to a smaller value as long as it is not less than the value of <code class="literal">queue.page_capacity</code>.
A smaller value produces smaller queues and improves queue performance.</p>
</div>
</div>
</dd>
<dt>
<span class="term">
<code class="literal">queue.checkpoint.acks</code>
</span>
</dt>
<dd>
Sets the number of acked events before forcing a checkpoint.
Default is <code class="literal">1024</code>. Set to <code class="literal">0</code> for unlimited.
</dd>
<dt>
<span class="term">
<code class="literal">queue.checkpoint.writes</code>
</span>
</dt>
<dd>
<p>
Sets the maximum number of written events before a forced checkpoint.
Default is <code class="literal">1024</code>. Set to <code class="literal">0</code> for unlimited.
</p>
<p>To avoid losing data in the persistent queue, you can set <code class="literal">queue.checkpoint.writes: 1</code> to force a checkpoint after each event is
written. Keep in mind that disk writes have a resource cost. Setting this value
to <code class="literal">1</code> ensures maximum durability, but can severely impact performance.
See <a class="xref" href="persistent-queues.html#durability-persistent-queues" title="Controlling durability">Controlling durability</a> to better understand the trade-offs.</p>
</dd>
<dt>
<span class="term">
<code class="literal">queue.checkpoint.interval</code>
</span>
</dt>
<dd>
Sets the interval in milliseconds when a checkpoint is forced on the head page.
Default is <code class="literal">1000</code>. Set to <code class="literal">0</code> to eliminate periodic checkpoints.
</dd>
</dl>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="pq-config-notes"></a>Configuration notes<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/logstash/edit/8.15/docs/static/persistent-queues.asciidoc">edit</a></h3>
</div></div></div>
<p>Every situation and environment is different, and the "ideal" configuration varies.
If you optimize for performance, you may increase your risk of losing data.
If you optimize for data protection, you may impact performance.</p>
<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="pq-size"></a>Queue size<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/logstash/edit/8.15/docs/static/persistent-queues.asciidoc">edit</a></h4>
</div></div></div>
<p>You can control queue size with the <code class="literal">queue.max_events</code> and  <code class="literal">queue.max_bytes</code> settings.
If both settings are specified, Logstash uses whichever criteria is reached
first.
See <a class="xref" href="persistent-queues.html#backpressure-persistent-queue" title="Handling back pressure">Handling back pressure</a> for behavior when queue limits are
reached.</p>
<p>Appropriate sizing for the queue depends on the use-case.
As a general guiding principle, consider this formula to size your persistent queue.</p>
<div class="pre_wrapper lang-txt">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-txt">Bytes Received Per Second = Incoming Events Per Second * Raw Event Byte Size
Bytes Received Per Hour = Bytes Received per Second * 3600s
Required Queue Capacity = (Bytes Received Per Hour * Tolerated Hours of Downtime) * Multiplication Factor <a id="CO29-1"></a><i class="conum" data-value="1"></i></pre>
</div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO29-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>To start, you can set the <code class="literal">Multiplication Factor</code> to <code class="literal">1.10</code>, and then refine it for specific data types as indicated in the tables below.</p>
</td>
</tr>
</table>
</div>
<div class="section">
<div class="titlepage"><div><div>
<h5 class="title"><a id="sizing-by-type"></a>Queue size by data type<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/logstash/edit/8.15/docs/static/persistent-queues.asciidoc">edit</a></h5>
</div></div></div>
<p>Logstash serializes the events it receives before they are stored in the queue.
This process results in added overhead to the event inside Logstash.
This overhead depends on the type and the size of the <code class="literal">Original Event Size</code>.
As such, the <code class="literal">Multiplication Factor</code> changes depending on your use case.
These tables show examples of overhead by event type and how that affects the multiplication factor.</p>
<p><span class="strong strong"><strong>Raw string message</strong></span></p>
<div class="informaltable">
<table border="1" cellpadding="4px">
<colgroup>
<col class="col_1"/>
<col class="col_2"/>
<col class="col_3"/>
<col class="col_4"/>
<col class="col_5"/>
</colgroup>
<thead>
<tr>
<th align="left" valign="top">Plaintext size (bytes)</th>
<th align="left" valign="top">Serialized Logstash event size (bytes)</th>
<th align="left" valign="top">Overhead (bytes)</th>
<th align="left" valign="top">Overhead (%)</th>
<th align="left" valign="top">Multiplication Factor</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" valign="top"><p><span class="strong strong"><strong>11</strong></span></p></td>
<td align="left" valign="top"><p>213</p></td>
<td align="left" valign="top"><p><code class="literal">202</code></p></td>
<td align="left" valign="top"><p><code class="literal">1836%</code></p></td>
<td align="left" valign="top"><p><code class="literal">19.4</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p><span class="strong strong"><strong>1212</strong></span></p></td>
<td align="left" valign="top"><p>1416</p></td>
<td align="left" valign="top"><p><code class="literal">204</code></p></td>
<td align="left" valign="top"><p><code class="literal">17%</code></p></td>
<td align="left" valign="top"><p><code class="literal">1.17</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p><span class="strong strong"><strong>10240</strong></span></p></td>
<td align="left" valign="top"><p>10452</p></td>
<td align="left" valign="top"><p><code class="literal">212</code></p></td>
<td align="left" valign="top"><p><code class="literal">2%</code></p></td>
<td align="left" valign="top"><p><code class="literal">1.02</code></p></td>
</tr>
</tbody>
</table>
</div>
<p><span class="strong strong"><strong>JSON document</strong></span></p>
<div class="informaltable">
<table border="1" cellpadding="4px">
<colgroup>
<col class="col_1"/>
<col class="col_2"/>
<col class="col_3"/>
<col class="col_4"/>
<col class="col_5"/>
</colgroup>
<thead>
<tr>
<th align="left" valign="top">JSON document size (bytes)</th>
<th align="left" valign="top">Serialized Logstash event size (bytes)</th>
<th align="left" valign="top">Overhead (bytes)</th>
<th align="left" valign="top">Overhead (%)</th>
<th align="left" valign="top">Multiplication Factor</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" valign="top"><p><span class="strong strong"><strong>947</strong></span></p></td>
<td align="left" valign="top"><p>1133</p></td>
<td align="left" valign="top"><p><code class="literal">186</code></p></td>
<td align="left" valign="top"><p><code class="literal">20%</code></p></td>
<td align="left" valign="top"><p><code class="literal">1.20</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p><span class="strong strong"><strong>2707</strong></span></p></td>
<td align="left" valign="top"><p>3206</p></td>
<td align="left" valign="top"><p><code class="literal">499</code></p></td>
<td align="left" valign="top"><p><code class="literal">18%</code></p></td>
<td align="left" valign="top"><p><code class="literal">1.18</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p><span class="strong strong"><strong>6751</strong></span></p></td>
<td align="left" valign="top"><p>7388</p></td>
<td align="left" valign="top"><p><code class="literal">637</code></p></td>
<td align="left" valign="top"><p><code class="literal">9%</code></p></td>
<td align="left" valign="top"><p><code class="literal">1.9</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p><span class="strong strong"><strong>58901</strong></span></p></td>
<td align="left" valign="top"><p>59693</p></td>
<td align="left" valign="top"><p><code class="literal">792</code></p></td>
<td align="left" valign="top"><p><code class="literal">1%</code></p></td>
<td align="left" valign="top"><p><code class="literal">1.1</code></p></td>
</tr>
</tbody>
</table>
</div>
<p><span class="strong strong"><strong>Example</strong></span></p>
<p>Let&#8217;s consider a Logstash instance that receives 1000 EPS and each event is 1KB,
or 3.5GB every hour. In order to tolerate a downstream component being unavailable
for 12h without Logstash exerting back-pressure upstream, the persistent queue&#8217;s
<code class="literal">max_bytes</code> would have to be set to 3.6*12*1.10 = 47.25GB, or about 50GB.</p>
</div>

</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="pq-lower-max_bytes"></a>Smaller queue size<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/logstash/edit/8.15/docs/static/persistent-queues.asciidoc">edit</a></h4>
</div></div></div>
<p>If you are using persistent queues to protect against data loss, but don&#8217;t
require much buffering, you can set <code class="literal">queue.max_bytes</code> to a smaller value.
A smaller value may produce smaller queues and improves queue performance.</p>
<p><span class="strong strong"><strong>Sample configuration</strong></span></p>
<div class="pre_wrapper lang-yaml">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-yaml">queue.type: persisted
queue.max_bytes: 10mb</pre>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="pq-fewer-checkpoints"></a>Fewer checkpoints<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/logstash/edit/8.15/docs/static/persistent-queues.asciidoc">edit</a></h4>
</div></div></div>
<p>Setting <code class="literal">queue.checkpoint.writes</code> and <code class="literal">queue.checkpoint.acks</code> to <code class="literal">0</code> may
yield maximum performance, but may have potential impact on durability.</p>
<p>In a situation where Logstash is terminated or there is a hardware-level
failure, any data that has not been checkpointed, is lost.
See <a class="xref" href="persistent-queues.html#durability-persistent-queues" title="Controlling durability">Controlling durability</a> to better understand the trade-offs.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="pq-pline-pline"></a>PQs and pipeline-to-pipeline communication<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/logstash/edit/8.15/docs/static/persistent-queues.asciidoc">edit</a></h4>
</div></div></div>
<p>Persistent queues can play an important role in your <a class="xref" href="pipeline-to-pipeline.html" title="Pipeline-to-pipeline communication">pipeline-to-pipeline</a> configuration.</p>
<div class="section">
<div class="titlepage"><div><div>
<h5 class="title"><a id="uc-isolator"></a>Use case: PQs and output isolator pattern<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/logstash/edit/8.15/docs/static/persistent-queues.asciidoc">edit</a></h5>
</div></div></div>
<p>Here is a real world use case described by a Logstash user.</p>
<p>"<em>In our deployment, we use one pipeline per output, and each pipeline has a
large PQ. This configuration allows a single output to stall without blocking
the input (and thus all other outputs), until the operator can restore flow to
the stalled output and let the queue drain.</em>"</p>
<p>"<em>Our real-time outputs must be low-latency, and our bulk outputs must be
consistent. We use PQs to protect against stalling the real-time outputs more so than to protect against data loss in the bulk outputs. (Although the protection is nice, too).</em>"</p>
</div>

</div>

</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="troubleshooting-pqs"></a>Troubleshooting persistent queues<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/logstash/edit/8.15/docs/static/persistent-queues.asciidoc">edit</a></h3>
</div></div></div>
<p>Symptoms of persistent queue problems include Logstash or one or more pipelines not starting successfully, accompanied by an error message similar to this one.</p>
<pre class="screen">message=&gt;"java.io.IOException: Page file size is too small to hold elements"</pre>
<p>This error indicates that the head page (the oldest in a directory and the one with lowest page id) has a size &lt; 18 bytes, the size of a page header.</p>
<p>To research and resolve the issue:</p>
<div class="olist orderedlist">
<ol class="orderedlist">
<li class="listitem">
Identify the queue (or queues) that may be corrupt by checking log files, or running the <code class="literal">pqcheck</code> utility.
</li>
<li class="listitem">
Stop Logstash, and wait for it to shut down.
</li>
<li class="listitem">
Run <code class="literal">pqrepair &lt;path&gt;</code> for each of the corrupted queues.
</li>
</ol>
</div>
<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="pqcheck"></a><code class="literal">pqcheck</code> utility<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/logstash/edit/8.15/docs/static/persistent-queues.asciidoc">edit</a></h4>
</div></div></div>
<pre class="literallayout">the `pqcheck` utility to identify which persistent queue--or queues--have been corrupted.</pre>

<p>From LOGSTASH_HOME, run:</p>
<div class="pre_wrapper lang-txt">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-txt">bin/pqcheck &lt;queue_directory&gt;</pre>
</div>
<p>where <code class="literal">&lt;queue_directory&gt;</code> is the fully qualified path to the persistent queue location.</p>
<p>The <code class="literal">pqcheck utility</code> reads through the checkpoint files in the given directory and outputs information about the current state of those files.
The utility outputs this information for each checkpoint file:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
Checkpoint file name
</li>
<li class="listitem">
Whether or not the page file has been fully acknowledged.
A fully acknowledged page file indicates that all events have been read and processed.
</li>
<li class="listitem">
Page file name that the checkpoint file is referencing
</li>
<li class="listitem">
Size of the page file. A page file with a size of 0 results in the output <code class="literal">NOT FOUND</code>.
In this case, run <code class="literal">pqrepair</code> against the specified queue directory.
</li>
<li class="listitem">
Page number
</li>
<li class="listitem">
First unacknowledged page number (only relevant in the head checkpoint)
</li>
<li class="listitem">
First unacknowledged event sequence number in the page
</li>
<li class="listitem">
First event sequence number in the page
</li>
<li class="listitem">
Number of events in the page
</li>
<li class="listitem">
Whether or not the page has been fully acknowledged
</li>
</ul>
</div>
<p><span class="strong strong"><strong>Sample with healthy page file</strong></span></p>
<p>This sample represents a healthy queue with three page files.
In this sample, Logstash is currently writing to <code class="literal">page.2</code> as referenced by
<code class="literal">checkpoint.head</code>.
Logstash is reading from <code class="literal">page.0</code> as referenced by <code class="literal">checkpoint.0</code>.</p>
<div class="pre_wrapper lang-txt">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-txt">ubuntu@bigger:/usr/share/logstash$ bin/pqcheck /var/lib/logstash/queue/main/
Using bundled JDK: /usr/share/logstash/jdk
OpenJDK 64-Bit Server VM warning: Option UseConcMarkSweepGC was deprecated in version 9.0 and will likely be removed in a future release.
Checking queue dir: /var/lib/logstash/queue/main
checkpoint.1, fully-acked: NO, page.1 size: 67108864
  pageNum=1, firstUnackedPageNum=0, firstUnackedSeqNum=239675, minSeqNum=239675,
  elementCount=218241, isFullyAcked=no
checkpoint.head, fully-acked: NO, page.2 size: 67108864
  pageNum=2, firstUnackedPageNum=0, firstUnackedSeqNum=457916, minSeqNum=457916, elementCount=11805, isFullyAcked=no
checkpoint.0, fully-acked: NO, page.0 size: 67108864  <a id="CO30-1"></a><i class="conum" data-value="1"></i>
  pageNum=0, firstUnackedPageNum=0, firstUnackedSeqNum=176126, minSeqNum=1,
  elementCount=239674, isFullyAcked=no <a id="CO30-2"></a><i class="conum" data-value="2"></i></pre>
</div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO30-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>Represents <code class="literal">checkpoint.0</code>, which refers to the page file <code class="literal">page.0</code>, and has a size of <code class="literal">67108864</code>.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO30-2"><i class="conum" data-value="2"></i></a></p>
</td>
<td align="left" valign="top">
<p>Continuing for <code class="literal">checkpoint.0</code>, these lines indicate that the page number is <code class="literal">0</code>, the first unacknowledged event is number <code class="literal">176126</code>, there are <code class="literal">239674</code> events in the page file, the first event in this page file is event number <code class="literal">1</code>, and the page file has not been fully acknowledged. That is, there are still events left in the page file that need to be ingested.</p>
</td>
</tr>
</table>
</div>
<p><span class="strong strong"><strong>Sample with corrupted page file</strong></span></p>
<p>If Logstash doesn&#8217;t start and/or <code class="literal">pqcheck</code> shows an anomaly, such as <code class="literal">NOT_FOUND</code> for a page, run <code class="literal">pqrepair</code> on the queue directory.</p>
<div class="pre_wrapper lang-txt">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-txt">bin/pqcheck /var/lib/logstash/queue/main/
Using bundled JDK: /usr/share/logstash/jdk
OpenJDK 64-Bit Server VM warning: Option UseConcMarkSweepGC was deprecated in version 9.0 and will likely be removed in a future release.
Checking queue dir: /var/lib/logstash/queue/main
checkpoint.head, fully-acked: NO, page.2 size: NOT FOUND <a id="CO31-1"></a><i class="conum" data-value="1"></i>
  pageNum=2, firstUnackedPageNum=2, firstUnackedSeqNum=534041, minSeqNum=457916,
  elementCount=76127, isFullyAcked=no</pre>
</div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO31-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p><code class="literal">NOT FOUND</code> is an indication of a corrupted page file. Run <code class="literal">pqrepair</code> against the specified queue directory.</p>
</td>
</tr>
</table>
</div>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p>If the queue shows <code class="literal">fully-acked: YES</code> and 0 bytes, you can safely delete the file.</p>
</div>
</div>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="pqrepair"></a><code class="literal">pqrepair</code> utility<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/logstash/edit/8.15/docs/static/persistent-queues.asciidoc">edit</a></h4>
</div></div></div>
<p>The <code class="literal">pqrepair</code> utility tries to remove corrupt queue segments to bring the queue back into working order.
It starts searching from the directory where is launched and looks for <code class="literal">data/queue/main</code>.</p>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p>The queue may lose some data in this operation.</p>
</div>
</div>
<p>From LOGSTASH_HOME, run:</p>
<div class="pre_wrapper lang-txt">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-txt">bin/pqrepair &lt;queue_directory&gt;</pre>
</div>
<p>where <code class="literal">&lt;queue_directory&gt;</code> is the fully qualified path to the persistent queue location.</p>
<p>There is no output if the utility runs properly.</p>
<p>The <code class="literal">pqrepair</code> utility requires write access to the directory.
Folder permissions may cause problems when Logstash is run as a service.
In this situation, use <code class="literal">sudo</code>.</p>
<div class="pre_wrapper lang-txt">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-txt">/usr/share/logstash$ sudo -u logstash bin/pqrepair /var/lib/logstash/queue/main/</pre>
</div>
<p>After you run <code class="literal">pqrepair</code>, restart Logstash to verify that the repair operation was successful.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="draining-pqs"></a>Draining the queue<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/logstash/edit/8.15/docs/static/persistent-queues.asciidoc">edit</a></h4>
</div></div></div>
<p>You may encounter situations where you want to drain the queue.
Examples include:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
Pausing new ingestion. There may be situations where you want to stop new ingestion, but still keep a backlog of data.
</li>
<li class="listitem">
PQ repair. You can drain the queue to route to a different PQ while repairing an old one.
</li>
<li class="listitem">
Data or workflow migration. If you are moving off a disk/hardware and/or migrating to a new data flow, you may want to drain the existing queue.
</li>
</ul>
</div>
<p>To drain the persistent queue:</p>
<div class="olist orderedlist">
<ol class="orderedlist">
<li class="listitem">
In the <code class="literal">logstash.yml</code> file, set <code class="literal">queue.drain: true</code>.
</li>
<li class="listitem">
Restart Logstash for this setting to take effect.
</li>
<li class="listitem">
Shutdown Logstash (using CTRL+C or SIGTERM), and wait for the queue to empty.
</li>
</ol>
</div>
</div>

</div>

<div class="section">
<div class="titlepage"><div><div>
<h3 class="title"><a id="persistent-queues-architecture"></a>How persistent queues work<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/logstash/edit/8.15/docs/static/persistent-queues.asciidoc">edit</a></h3>
</div></div></div>
<p>The queue sits between the input and filter stages in the same
process:</p>
<p>input → queue → filter + output</p>
<p>When an input has events ready to process, it writes them to the queue. When
the write to the queue is successful, the input can send an acknowledgement to
its data source.</p>
<p>When processing events from the queue, Logstash acknowledges events as
completed, within the queue, only after filters and outputs have completed.
The queue keeps a record of events that have been processed by the pipeline.
An event is recorded as processed (in this document, called "acknowledged" or
"ACKed") if, and only if, the event has been processed completely by the
Logstash pipeline.</p>
<p>What does acknowledged mean? This means the event has been handled by all
configured filters and outputs. For example, if you have only one output,
Elasticsearch, an event is ACKed when the Elasticsearch output has successfully
sent this event to Elasticsearch.</p>
<p>During a normal shutdown (<span class="strong strong"><strong>CTRL+C</strong></span> or SIGTERM), Logstash stops reading
from the queue and finishes processing the in-flight events being processed
by the filters and outputs. Upon restart, Logstash resumes processing the
events in the persistent queue as well as accepting new events from inputs.</p>
<p>If Logstash is abnormally terminated, any in-flight events will not have been
ACKed and will be reprocessed by filters and outputs when Logstash is
restarted. Logstash processes events in batches, so it is possible
that for any given batch, some of that batch may have been successfully
completed, but not recorded as ACKed, when an abnormal termination occurs.</p>
<div class="note admon">
<div class="icon"></div>
<div class="admon_content">
<p>If you override the default behavior by setting <code class="literal">drain.queue: true</code>, Logstash reads from the queue until it is emptied&#8212;&#8203;even after a controlled shutdown.</p>
</div>
</div>
<p>For more details specific behaviors of queue writes and acknowledgement, see
<a class="xref" href="persistent-queues.html#durability-persistent-queues" title="Controlling durability">Controlling durability</a>.</p>
<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="backpressure-persistent-queue"></a>Handling back pressure<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/logstash/edit/8.15/docs/static/persistent-queues.asciidoc">edit</a></h4>
</div></div></div>
<p>When the queue is full, Logstash puts back pressure on the inputs to stall data
flowing into Logstash. This mechanism helps Logstash control the rate of data
flow at the input stage without overwhelming outputs like Elasticsearch.</p>
<p>Use <code class="literal">queue.max_bytes</code> setting to configure the total capacity of the queue on
disk. The following example sets the total capacity of the queue to 8gb:</p>
<div class="pre_wrapper lang-yaml">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-yaml">queue.type: persisted
queue.max_bytes: 8gb</pre>
</div>
<p>With these settings specified, Logstash buffers events on disk until the
size of the queue reaches 8gb. When the queue is full of unACKed events, and
the size limit has been reached, Logstash no longer accepts new events.</p>
<p>Each input handles back pressure independently. For example, when the
<a class="xref" href="plugins-inputs-beats.html" title="Beats input plugin">beats</a> input encounters back pressure, it no longer
accepts new connections and waits until the persistent queue has space to accept
more events. After the filter and output stages finish processing existing
events in the queue and ACKs them, Logstash automatically starts accepting new
events.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="durability-persistent-queues"></a>Controlling durability<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/logstash/edit/8.15/docs/static/persistent-queues.asciidoc">edit</a></h4>
</div></div></div>
<p>Durability is a property of storage writes that ensures data will be available after it&#8217;s written.</p>
<p>When the persistent queue feature is enabled, Logstash stores events on
disk. Logstash commits to disk in a mechanism called <em>checkpointing</em>.</p>
<p>The queue itself is a set of pages. There are two kinds of pages: head pages and tail pages. The head page is where new events are written. There is only one head page. When the head page is of a certain size (see <code class="literal">queue.page_capacity</code>), it becomes a tail page, and a new head page is created. Tail pages are immutable, and the head page is append-only.
Second, the queue records details about itself (pages, acknowledgements, etc) in a separate file called a checkpoint file.</p>
<p>When recording a checkpoint, Logstash:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
Calls <code class="literal">fsync</code> on the head page.
</li>
<li class="listitem">
Atomically writes to disk the current state of the queue.
</li>
</ul>
</div>
<p>The process of checkpointing is atomic, which means any update to the file is saved if successful.</p>
<div class="important admon">
<div class="icon"></div>
<div class="admon_content">
<p>If Logstash is terminated, or if there is a hardware-level failure,
any data that is buffered in the persistent queue, but not yet checkpointed, is
lost.</p>
</div>
</div>
<p>You can force Logstash to checkpoint more frequently by setting
<code class="literal">queue.checkpoint.writes</code>. This setting specifies the maximum number of events
that may be written to disk before forcing a checkpoint. The default is 1024. To
ensure maximum durability and avoid data loss in the persistent queue, you can
set <code class="literal">queue.checkpoint.writes: 1</code> to force a checkpoint after each event is
written. Keep in mind that disk writes have a resource cost. Setting this value
to <code class="literal">1</code> can severely impact performance.</p>
</div>

<div class="section">
<div class="titlepage"><div><div>
<h4 class="title"><a id="garbage-collection"></a>Disk garbage collection<a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/logstash/edit/8.15/docs/static/persistent-queues.asciidoc">edit</a></h4>
</div></div></div>
<p>On disk, the queue is stored as a set of pages where each page is one file. Each page can be at most <code class="literal">queue.page_capacity</code> in size. Pages are deleted (garbage collected) after all events in that page have been ACKed. If an older page has at least one event that is not yet ACKed, that entire page will remain on disk until all events in that page are successfully processed. Each page containing unprocessed events will count against the <code class="literal">queue.max_bytes</code> byte size.</p>
</div>

</div>

</div>
</div>
</div><div class="navfooter">
<span class="prev">
<a href="memory-queue.html">« Memory queue</a>
</span>
<span class="next">
<a href="dead-letter-queues.html">Dead letter queues (DLQ) »</a>
</span>
</div>
</body>
</html>
