<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Semantic search | Serverless | Elastic</title>
<meta class="elastic" name="content" content="Semantic search | Serverless">

<link rel="home" href="index.html" title="Serverless"/>
<link rel="up" href="elasticsearch-search-your-data.html" title="Search your data"/>
<link rel="prev" href="elasticsearch-knn-search.html" title="k-nearest neighbor (kNN) search"/>
<link rel="next" href="elasticsearch-reference-semantic-search-elser.html" title="Tutorial: Semantic search with ELSER"/>
<meta class="elastic" name="product_version" content="main"/>
<meta class="elastic" name="product_name" content="Serverless"/>
<meta class="elastic" name="website_area" content="documentation"/>
<meta name="DC.type" content="Learn/Docs/Serverless/Guide"/>
<meta name="DC.subject" content="Serverless"/>
<meta name="DC.identifier" content="main"/>
</head>
<body>
<div class="navheader">
<span class="prev">
<a href="elasticsearch-knn-search.html">« k-nearest neighbor (kNN) search</a>
</span>
<span class="next">
<a href="elasticsearch-reference-semantic-search-elser.html">Tutorial: Semantic search with ELSER »</a>
</span>
</div>
<div class="book" lang="en">
<div class="titlepage">
<div class="breadcrumbs">
<span class="breadcrumb-link"><a href="/guide/">Elastic Docs</a></span>
<span class="chevron-right">›</span><span class="breadcrumb-link"><a href="index.html">Serverless</a></span>
<span class="chevron-right">›</span><span class="breadcrumb-link"><a href="what-is-elasticsearch-serverless.html">Elasticsearch</a></span>
<span class="chevron-right">›</span><span class="breadcrumb-link"><a href="elasticsearch-search-your-data.html">Search your data</a></span>
</div>
<div>
<div><h1 class="title"><a id="id-1"></a>Semantic search</h1><a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/docs-content/edit/main/serverless/pages/search-your-data-semantic-search.asciidoc">edit</a></div>
</div>
<!--EXTRA-->
</div>
<div id="content">
<div class="section">
<div class="titlepage"><div><div>
<div class="position-relative"><h3 class="title"><a id="elasticsearch-reference-semantic-search"></a>Semantic search</h3><a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/docs-content/edit/main/serverless/pages/search-your-data-semantic-search.asciidoc">edit</a></div>
</div></div></div>
<p><span class="Admonishment Admonishment--preview">
[<span class="Admonishment-title u-mono">preview</span>]
<span class="Admonishment-detail">
This functionality is in technical preview and may be changed or removed in a future release. Elastic will work to fix any issues, but features in technical preview are not subject to the support SLA of official GA features.
</span>
</span></p>
<p>Semantic search is a search method that helps you find data based on the intent
and contextual meaning of a search query, instead of a match on query terms
(lexical search).</p>
<p>Elasticsearch provides semantic search capabilities using <a href="/guide/en/machine-learning/master/ml-nlp.html" class="ulink" target="_top">natural
language processing (NLP)</a> and vector search. Deploying an NLP model to Elasticsearch
enables it to extract text embeddings out of text. Embeddings are vectors that
provide a numeric representation of a text. Pieces of content with similar
meaning have similar representations.</p>
<div class="imageblock">
<div class="content">
<img src="images/vector-search-oversimplification.png" alt="A simplified representation of encoding textual concepts as vectors">
</div>
</div>
<p><em>A simplified representation of encoding textual concepts as vectors</em></p>
<p>At query time, Elasticsearch can use the same NLP model to convert a query into
embeddings, enabling you to find documents with similar text embeddings.</p>
<p>This guide shows you how to implement semantic search with Elasticsearch, from selecting
an NLP model, to writing queries.</p>
<div class="position-relative"><h5><a id="semantic-search-select-nlp-model"></a>Select an NLP model</h5><a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/docs-content/edit/main/serverless/pages/search-your-data-semantic-search.asciidoc">edit</a></div>
<p>Elasticsearch offers the usage of a
<a href="/guide/en/machine-learning/master/ml-nlp-model-ref.html#ml-nlp-model-ref-text-embedding" class="ulink" target="_top">wide range of NLP models</a>,
including both dense and sparse vector models. Your choice of the language model
is critical for implementing semantic search successfully.</p>
<p>While it is possible to bring your own text embedding model, achieving good
search results through model tuning is challenging. Selecting an appropriate
model from our third-party model list is the first step. Training the model on
your own data is essential to ensure better search results than using only BM25.
However, the model training process requires a team of data scientists and ML
experts, making it expensive and time-consuming.</p>
<p>To address this issue, Elastic provides a pre-trained representational model
called <a href="/guide/en/machine-learning/master/ml-nlp-elser.html" class="ulink" target="_top">Elastic Learned Sparse EncodeR (ELSER)</a>.
ELSER, currently available only for English, is an out-of-domain sparse vector
model that does not require fine-tuning. This adaptability makes it suitable for
various NLP use cases out of the box. Unless you have a team of ML specialists,
it is highly recommended to use the ELSER model.</p>
<p>In the case of sparse vector representation, the vectors mostly consist of zero
values, with only a small subset containing non-zero values. This representation
is commonly used for textual data. In the case of ELSER, each document in an
index and the query text itself are represented by high-dimensional sparse
vectors. Each non-zero element of the vector corresponds to a term in the model
vocabulary. The ELSER vocabulary contains around 30000 terms, so the sparse
vectors created by ELSER contain about 30000 values, the majority of which are
zero. Effectively the ELSER model is replacing the terms in the original query
with other terms that have been learnt to exist in the documents that best match
the original search terms in a training dataset, and weights to control how
important each is.</p>
<div class="position-relative"><h5><a id="semantic-search-deploy-nlp-model"></a>Deploy the model</h5><a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/docs-content/edit/main/serverless/pages/search-your-data-semantic-search.asciidoc">edit</a></div>
<p>After you decide which model you want to use for implementing semantic search,
you need to deploy the model in Elasticsearch.</p>
<div class="tabs" data-tab-group="partials-deploy-nlp-model-widget">
  <div role="tablist" aria-label="partials-deploy-nlp-model-widget">
    <button role="tab" aria-selected="true" aria-controls="partials-deploy-nlp-model-widget-elser-panel" id="partials-deploy-nlp-model-widget-elser-button">
      ELSER
    </button>
    <button role="tab" aria-selected="false" aria-controls="partials-deploy-nlp-model-widget-dense-vector-models-panel" id="partials-deploy-nlp-model-widget-dense-vector-models-button" tabindex="-1">
      Dense vector models
    </button>
  </div>
  <div tabindex="0" role="tabpanel" id="partials-deploy-nlp-model-widget-elser-panel" aria-labelledby="partials-deploy-nlp-model-widget-elser-button">
<p>To deploy ELSER, refer to
<a href="/guide/en/machine-learning/master/ml-nlp-elser.html#download-deploy-elser" class="ulink" target="_top">Download and deploy ELSER</a>.</p>
  </div>
  <div tabindex="0" role="tabpanel" id="partials-deploy-nlp-model-widget-dense-vector-models-panel" aria-labelledby="partials-deploy-nlp-model-widget-dense-vector-models-button" hidden="">
<p>To deploy a third-party text embedding model, refer to
<a href="/guide/en/machine-learning/master/ml-nlp-text-emb-vector-search-example.html#ex-te-vs-deploy" class="ulink" target="_top">Deploy a text embedding model</a>.</p>
  </div>
</div>
<div class="position-relative"><h5><a id="semantic-search-field-mappings"></a>Map a field for the text embeddings</h5><a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/docs-content/edit/main/serverless/pages/search-your-data-semantic-search.asciidoc">edit</a></div>
<p>Before you start using the deployed model to generate embeddings based on your
input text, you need to prepare your index mapping first. The mapping of the
index depends on the type of model.</p>
<div class="tabs" data-tab-group="partials-field-mappings-widget">
  <div role="tablist" aria-label="partials-field-mappings-widget">
    <button role="tab" aria-selected="true" aria-controls="partials-field-mappings-widget-elser-panel" id="partials-field-mappings-widget-elser-button">
      ELSER
    </button>
    <button role="tab" aria-selected="false" aria-controls="partials-field-mappings-widget-dense-vector-models-panel" id="partials-field-mappings-widget-dense-vector-models-button" tabindex="-1">
      Dense vector models
    </button>
  </div>
  <div tabindex="0" role="tabpanel" id="partials-field-mappings-widget-elser-panel" aria-labelledby="partials-field-mappings-widget-elser-button">
<p>ELSER produces token-weight pairs as output from the input text and the query.
The Elasticsearch <a href="/guide/en/elasticsearch/reference/master/sparse-vector.html" class="ulink" target="_top"><code class="literal">sparse_vector</code></a> field type can store these
token-weight pairs as numeric feature vectors. The index must have a field with
the <code class="literal">sparse_vector</code> field type to index the tokens that ELSER generates.</p>
<p>To create a mapping for your ELSER index, refer to the <a class="xref" href="elasticsearch-reference-semantic-search-elser.html#elser-mappings" title="Create the index mapping">Create the index mapping section</a>
of the tutorial. The example
shows how to create an index mapping for <code class="literal">my-index</code> that defines the
<code class="literal">my_embeddings.tokens</code> field - which will contain the ELSER output - as a
<code class="literal">sparse_vector</code> field.</p>
<div class="pre_wrapper lang-bash">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-bash">curl -X PUT "${ES_URL}/my-index" \
-H "Authorization: ApiKey ${API_KEY}" \
-H "Content-Type: application/json" \
-d'
{
  "mappings": {
    "properties": {
      "my_tokens": {   <a id="CO3-1"></a><i class="conum" data-value="1"></i>
        "type": "sparse_vector"   <a id="CO3-2"></a><i class="conum" data-value="2"></i>
      },
      "my_text_field": {   <a id="CO3-3"></a><i class="conum" data-value="3"></i>
        "type": "text"   <a id="CO3-4"></a><i class="conum" data-value="4"></i>
      }
    }
  }
}
'</pre>
</div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO3-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>The name of the field that will contain the tokens generated by ELSER.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO3-2"><i class="conum" data-value="2"></i></a></p>
</td>
<td align="left" valign="top">
<p>The field that contains the tokens must be a <code class="literal">sparse_vector</code> field.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO3-3"><i class="conum" data-value="3"></i></a></p>
</td>
<td align="left" valign="top">
<p>The name of the field from which to create the sparse vector representation.
In this example, the name of the field is <code class="literal">my_text_field</code>.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO3-4"><i class="conum" data-value="4"></i></a></p>
</td>
<td align="left" valign="top">
<p>The field type is <code class="literal">text</code> in this example.</p>
</td>
</tr>
</table>
</div>
  </div>
  <div tabindex="0" role="tabpanel" id="partials-field-mappings-widget-dense-vector-models-panel" aria-labelledby="partials-field-mappings-widget-dense-vector-models-button" hidden="">
<p>The models compatible with Elasticsearch NLP generate dense vectors as output. The
<a href="/guide/en/elasticsearch/reference/master/dense-vector.html" class="ulink" target="_top"><code class="literal">dense_vector</code></a> field type is suitable for storing dense vectors
of numeric values. The index must have a field with the <code class="literal">dense_vector</code> field
type to index the embeddings that the supported third-party model that you
selected generates. Keep in mind that the model produces embeddings with a
certain number of dimensions. The <code class="literal">dense_vector</code> field must be configured with
the same number of dimensions using the <code class="literal">dims</code> option. Refer to the respective
model documentation to get information about the number of dimensions of the
embeddings.</p>
<p>To review a mapping of an index for an NLP model, refer to the mapping code
snippet in the
<a href="/guide/en/machine-learning/master/ml-nlp-text-emb-vector-search-example.html#ex-text-emb-ingest" class="ulink" target="_top">Add the text embedding model to an ingest inference pipeline</a>
section of the tutorial. The example shows how to create an index mapping that
defines the <code class="literal">my_embeddings.predicted_value</code> field - which will contain the model
output - as a <code class="literal">dense_vector</code> field.</p>
<div class="pre_wrapper lang-bash">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-bash">curl -X PUT "${ES_URL}/my-index" \
-H "Authorization: ApiKey ${API_KEY}" \
-H "Content-Type: application/json" \
-d'
{
  "mappings": {
    "properties": {
      "my_embeddings.predicted_value": {   <a id="CO4-1"></a><i class="conum" data-value="1"></i>
        "type": "dense_vector",   <a id="CO4-2"></a><i class="conum" data-value="2"></i>
        "dims": 384  <a id="CO4-3"></a><i class="conum" data-value="3"></i>
      },
      "my_text_field": {   <a id="CO4-4"></a><i class="conum" data-value="4"></i>
        "type": "text"   <a id="CO4-5"></a><i class="conum" data-value="5"></i>
      }
    }
  }
}
'</pre>
</div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO4-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>The name of the field that will contain the embeddings generated by the
model.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO4-2"><i class="conum" data-value="2"></i></a></p>
</td>
<td align="left" valign="top">
<p>The field that contains the embeddings must be a <code class="literal">dense_vector</code> field.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO4-3"><i class="conum" data-value="3"></i></a></p>
</td>
<td align="left" valign="top">
<p>The model produces embeddings with a certain number of dimensions. The
<code class="literal">dense_vector</code> field must be configured with the same number of dimensions by
the <code class="literal">dims</code> option. Refer to the respective model documentation to get
information about the number of dimensions of the embeddings.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO4-4"><i class="conum" data-value="4"></i></a></p>
</td>
<td align="left" valign="top">
<p>The name of the field from which to create the dense vector representation.
In this example, the name of the field is <code class="literal">my_text_field</code>.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO4-5"><i class="conum" data-value="5"></i></a></p>
</td>
<td align="left" valign="top">
<p>The field type is <code class="literal">text</code> in this example.</p>
</td>
</tr>
</table>
</div>
  </div>
</div>
<div class="position-relative"><h5><a id="semantic-search-generate-embeddings"></a>Generate text embeddings</h5><a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/docs-content/edit/main/serverless/pages/search-your-data-semantic-search.asciidoc">edit</a></div>
<p>Once you have created the mappings for the index, you can generate text
embeddings from your input text. This can be done by using an
<a href="/guide/en/elasticsearch/reference/master/ingest.html" class="ulink" target="_top">ingest pipeline</a> with an <a href="/guide/en/elasticsearch/reference/master/inference-processor.html" class="ulink" target="_top">inference processor</a>.
The ingest pipeline processes the input data and indexes it into the destination
index. At index time, the inference ingest processor uses the trained model to
infer against the data ingested through the pipeline. After you created the
ingest pipeline with the inference processor, you can ingest your data through
it to generate the model output.</p>
<div class="tabs" data-tab-group="partials-generate-embeddings-widget">
  <div role="tablist" aria-label="partials-generate-embeddings-widget">
    <button role="tab" aria-selected="true" aria-controls="partials-generate-embeddings-widget-elser-panel" id="partials-generate-embeddings-widget-elser-button">
      ELSER
    </button>
    <button role="tab" aria-selected="false" aria-controls="partials-generate-embeddings-widget-dense-vector-models-panel" id="partials-generate-embeddings-widget-dense-vector-models-button" tabindex="-1">
      Dense vector models
    </button>
  </div>
  <div tabindex="0" role="tabpanel" id="partials-generate-embeddings-widget-elser-panel" aria-labelledby="partials-generate-embeddings-widget-elser-button">
<p>This is how an ingest pipeline that uses the ELSER model is created:</p>
<div class="pre_wrapper lang-bash">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-bash">curl -X PUT "${ES_URL}/_ingest/pipeline/my-text-embeddings-pipeline" \
-H "Authorization: ApiKey ${API_KEY}" \
-H "Content-Type: application/json" \
-d'
{
  "description": "Text embedding pipeline",
  "processors": [
    {
      "inference": {
        "model_id": ".elser_model_2",
        "input_output": [
          {
            "input_field": "my_text_field",
            "output_field": "my_tokens"
          }
        ]
      }
    }
  ]
}
'</pre>
</div>
<p>To ingest data through the pipeline to generate tokens with ELSER, refer to the
<a class="xref" href="elasticsearch-reference-semantic-search-elser.html#reindexing-data-elser" title="Ingest the data through the inference ingest pipeline">Ingest the data through the inference ingest pipeline</a> section of the tutorial. After you successfully
ingested documents by using the pipeline, your index will contain the tokens
generated by ELSER.</p>
  </div>
  <div tabindex="0" role="tabpanel" id="partials-generate-embeddings-widget-dense-vector-models-panel" aria-labelledby="partials-generate-embeddings-widget-dense-vector-models-button" hidden="">
<p>This is how an ingest pipeline that uses a text embedding model is created:</p>
<div class="pre_wrapper lang-bash">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-bash">curl -X PUT "${ES_URL}/_ingest/pipeline/my-text-embeddings-pipeline" \
-H "Authorization: ApiKey ${API_KEY}" \
-H "Content-Type: application/json" \
-d'
{
  "description": "Text embedding pipeline",
  "processors": [
    {
      "inference": {
        "model_id": "sentence-transformers__msmarco-minilm-l-12-v3",   <a id="CO5-1"></a><i class="conum" data-value="1"></i>
        "target_field": "my_embeddings",
        "field_map": {   <a id="CO5-2"></a><i class="conum" data-value="2"></i>
          "my_text_field": "text_field"
        }
      }
    }
  ]
}
'</pre>
</div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO5-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>The model ID of the text embedding model you want to use.</p>
</td>
</tr>
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO5-2"><i class="conum" data-value="2"></i></a></p>
</td>
<td align="left" valign="top">
<p>The <code class="literal">field_map</code> object maps the input document field name (which is
<code class="literal">my_text_field</code> in this example) to the name of the field that the model expects
(which is always <code class="literal">text_field</code>).</p>
</td>
</tr>
</table>
</div>
<p>To ingest data through the pipeline to generate text embeddings with your chosen
model, refer to the
<a href="/guide/en/machine-learning/master/ml-nlp-text-emb-vector-search-example.html#ex-text-emb-ingest" class="ulink" target="_top">Add the text embedding model to an inference ingest pipeline</a>
section. The example shows how to create the pipeline with the inference
processor and reindex your data through the pipeline. After you successfully
ingested documents by using the pipeline, your index will contain the text
embeddings generated by the model.</p>
  </div>
</div>
<p>Now it is time to perform semantic search!</p>
<div class="position-relative"><h5><a id="semantic-search-search"></a>Search the data</h5><a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/docs-content/edit/main/serverless/pages/search-your-data-semantic-search.asciidoc">edit</a></div>
<p>Depending on the type of model you have deployed, you can query sparse vectors
with a sparse vector query, or dense vectors with a kNN search.</p>
<div class="tabs" data-tab-group="partials-search-widget">
  <div role="tablist" aria-label="partials-search-widget">
    <button role="tab" aria-selected="true" aria-controls="partials-search-widget-elser-panel" id="partials-search-widget-elser-button">
      ELSER
    </button>
    <button role="tab" aria-selected="false" aria-controls="partials-search-widget-dense-vector-models-panel" id="partials-search-widget-dense-vector-models-button" tabindex="-1">
      Dense vector models
    </button>
  </div>
  <div tabindex="0" role="tabpanel" id="partials-search-widget-elser-panel" aria-labelledby="partials-search-widget-elser-button">
<p>ELSER text embeddings can be queried using a
<a href="/guide/en/elasticsearch/reference/master/query-dsl-sparse-vector-query.html" class="ulink" target="_top">sparse vector query</a>. The sparse vector
query enables you to query a sparse vector field, by providing an inference ID, and the query text:</p>
<div class="pre_wrapper lang-bash">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-bash">curl -X GET "${ES_URL}/my-index/_search" \
-H "Authorization: ApiKey ${API_KEY}" \
-H "Content-Type: application/json" \
-d'
{
   "query":{
      "sparse_vector":{
         "field": "my_tokens",   <a id="CO6-1"></a><i class="conum" data-value="1"></i>
         "inference_id": "my-elser-endpoint",
         "query": "the query string"
         }
      }
   }
}
'</pre>
</div>
<div class="calloutlist">
<table border="0" summary="Callout list">
<tr>
<td align="left" valign="top" width="5%">
<p><a href="#CO6-1"><i class="conum" data-value="1"></i></a></p>
</td>
<td align="left" valign="top">
<p>The field of type <code class="literal">sparse_vector</code>.</p>
</td>
</tr>
</table>
</div>
  </div>
  <div tabindex="0" role="tabpanel" id="partials-search-widget-dense-vector-models-panel" aria-labelledby="partials-search-widget-dense-vector-models-button" hidden="">
<p>Text embeddings produced by dense vector models can be queried using a
<a class="xref" href="elasticsearch-knn-search.html" title="k-nearest neighbor (kNN) search">kNN search</a>.
In the <code class="literal">knn</code> clause, provide the name of the
dense vector field, and a <code class="literal">query_vector_builder</code> clause with the model ID and
the query text.</p>
<div class="pre_wrapper lang-bash">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-bash">curl -X GET "${ES_URL}/my-index/_search" \
-H "Authorization: ApiKey ${API_KEY}" \
-H "Content-Type: application/json" \
-d'
{
  "knn": {
    "field": "my_embeddings.predicted_value",
    "k": 10,
    "num_candidates": 100,
    "query_vector_builder": {
      "text_embedding": {
        "model_id": "sentence-transformers__msmarco-minilm-l-12-v3",
        "model_text": "the query string"
      }
    }
  }
}
'</pre>
</div>
  </div>
</div>
<div class="position-relative"><h5><a id="semantic-search-hybrid-search"></a>Beyond semantic search with hybrid search</h5><a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/docs-content/edit/main/serverless/pages/search-your-data-semantic-search.asciidoc">edit</a></div>
<p>In some situations, lexical search may perform better than semantic search. For
example, when searching for single words or IDs, like product numbers.</p>
<p>Combining semantic and lexical search into one hybrid search request using
<a href="/guide/en/elasticsearch/reference/master/rrf.html" class="ulink" target="_top">reciprocal rank fusion</a> provides the best of both worlds. Not only that,
but hybrid search using reciprocal rank fusion <a href="/blog/improving-information-retrieval-elastic-stack-hybrid" class="ulink" target="_top">has been shown to perform better
in general</a>.</p>
<div class="tabs" data-tab-group="partials-hybrid-search-widget">
  <div role="tablist" aria-label="partials-hybrid-search-widget">
    <button role="tab" aria-selected="true" aria-controls="partials-hybrid-search-widget-elser-panel" id="partials-hybrid-search-widget-elser-button">
      ELSER
    </button>
    <button role="tab" aria-selected="false" aria-controls="partials-hybrid-search-widget-dense-vector-models-panel" id="partials-hybrid-search-widget-dense-vector-models-button" tabindex="-1">
      Dense vector models
    </button>
  </div>
  <div tabindex="0" role="tabpanel" id="partials-hybrid-search-widget-elser-panel" aria-labelledby="partials-hybrid-search-widget-elser-button">
<p>Hybrid search between a semantic and lexical query can be achieved by using retrievers in your search request.
The following example uses retrievers to perform a match query and a sparse vector query, and rank them using RRF.</p>
<div class="pre_wrapper lang-bash">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-bash">curl -X GET "${ES_URL}/my-index/_search" \
-H "Authorization: ApiKey ${API_KEY}" \
-H "Content-Type: application/json" \
-d'
{
  "retriever": {
    "rrf": {
      "retrievers": [
        {
          "standard": {
            "query": {
              "match": {
                "my_text_field": "the query string"
              }
            }
          }
        },
        {
          "standard": {
            "query": {
              "sparse_vector": {
                "field": "my_tokens",
                "inference_id": "my-elser-endpoint",
                "query": "the query string"
              }
            }
          }
        }
      ],
      "window_size": 50,
      "rank_constant": 20
    }
  }
}
'</pre>
</div>
  </div>
  <div tabindex="0" role="tabpanel" id="partials-hybrid-search-widget-dense-vector-models-panel" aria-labelledby="partials-hybrid-search-widget-dense-vector-models-button" hidden="">
<p>Hybrid search between a semantic and lexical query can be achieved by providing:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
a <code class="literal">query</code> clause for the full-text query;
</li>
<li class="listitem">
a <code class="literal">knn</code> clause with the kNN search that queries the dense vector field;
</li>
<li class="listitem">
and a <code class="literal">rank</code> clause with the <code class="literal">rrf</code> parameter to rank documents using
reciprocal rank fusion.
</li>
</ul>
</div>
<div class="pre_wrapper lang-bash">
<div class="console_code_copy" title="Copy to clipboard"></div>
<pre class="programlisting prettyprint lang-bash">curl -X GET "${ES_URL}/my-index/_search" \
-H "Authorization: ApiKey ${API_KEY}" \
-H "Content-Type: application/json" \
-d'
{
  "query": {
    "match": {
      "my_text_field": "the query string"
    }
  },
  "knn": {
    "field": "text_embedding.predicted_value",
    "k": 10,
    "num_candidates": 100,
    "query_vector_builder": {
      "text_embedding": {
        "model_id": "sentence-transformers__msmarco-minilm-l-12-v3",
        "model_text": "the query string"
      }
    }
  },
  "rank": {
    "rrf": {}
  }
}
'</pre>
</div>
  </div>
</div>
<div class="position-relative"><h5><a id="semantic-search-read-more"></a>Read more</h5><a class="edit_me" rel="nofollow" title="Edit this page on GitHub" href="https://github.com/elastic/docs-content/edit/main/serverless/pages/search-your-data-semantic-search.asciidoc">edit</a></div>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
<p>Tutorials:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
<a class="xref" href="elasticsearch-reference-semantic-search-elser.html" title="Tutorial: Semantic search with ELSER">Semantic search with ELSER</a>
</li>
<li class="listitem">
<a href="/guide/en/machine-learning/master/ml-nlp-text-emb-vector-search-example.html" class="ulink" target="_top">Semantic search with the msmarco-MiniLM-L-12-v3 sentence-transformer model</a>
</li>
</ul>
</div>
</li>
<li class="listitem">
<p>Blogs:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
<a href="/blog/may-2023-launch-sparse-encoder-ai-model" class="ulink" target="_top">Introducing Elastic Learned Sparse Encoder: Elastic&#8217;s AI model for semantic search</a>
</li>
<li class="listitem">
<a href="/blog/lexical-ai-powered-search-elastic-vector-database" class="ulink" target="_top">How to get the best of lexical and AI-powered search with Elastic&#8217;s vector database</a>
</li>
<li class="listitem">
<p>Information retrieval blog series:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
<a href="/blog/improving-information-retrieval-elastic-stack-search-relevance" class="ulink" target="_top">Part 1: Steps to improve search relevance</a>
</li>
<li class="listitem">
<a href="/blog/improving-information-retrieval-elastic-stack-benchmarking-passage-retrieval" class="ulink" target="_top">Part 2: Benchmarking passage retrieval</a>
</li>
<li class="listitem">
<a href="/blog/may-2023-launch-information-retrieval-elasticsearch-ai-model" class="ulink" target="_top">Part 3: Introducing Elastic Learned Sparse Encoder, our new retrieval model</a>
</li>
<li class="listitem">
<a href="/blog/improving-information-retrieval-elastic-stack-hybrid" class="ulink" target="_top">Part 4: Hybrid retrieval</a>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li class="listitem">
<p>Interactive examples:</p>
<div class="ulist itemizedlist">
<ul class="itemizedlist">
<li class="listitem">
The <a href="https://github.com/elastic/elasticsearch-labs" class="ulink" target="_top"><code class="literal">elasticsearch-labs</code></a> repo contains a number of interactive semantic search examples in the form of executable Python notebooks, using the Elasticsearch Python client.
</li>
</ul>
</div>
</li>
</ul>
</div>

</div>
</div>
</div><div class="navfooter">
<span class="prev">
<a href="elasticsearch-knn-search.html">« k-nearest neighbor (kNN) search</a>
</span>
<span class="next">
<a href="elasticsearch-reference-semantic-search-elser.html">Tutorial: Semantic search with ELSER »</a>
</span>
</div>
</body>
</html>
